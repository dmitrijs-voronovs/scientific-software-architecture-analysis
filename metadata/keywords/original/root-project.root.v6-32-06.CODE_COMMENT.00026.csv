id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependence,14,"// Adjust the dependence latency using operand def/use information,; // then allow the target to perform its own adjustments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,Performance,latency,latency,25,"// Adjust the dependence latency using operand def/use information,; // then allow the target to perform its own adjustments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:97,Performance,perform,perform,97,"// Adjust the dependence latency using operand def/use information,; // then allow the target to perform its own adjustments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:79,Energy Efficiency,schedul,scheduling,79,// Set the hasPhysRegDefs only for physreg defs that have a use within; // the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:115,Energy Efficiency,schedul,scheduling,115,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:18,Integrability,depend,dependencies,18,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:138,Integrability,depend,depend,138,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:31,Integrability,depend,dependencies,31,// We do not need to track any dependencies for constant registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:34,Integrability,depend,dependencies,34,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:61,Integrability,depend,dependencies,61,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:279,Integrability,depend,dependencies,279,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:83,Performance,latency,latency,83,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:250,Performance,latency,latency,250,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Usability,Clear,Clear,3,// Clear previous uses and defs of this register and its subregisters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:48,Integrability,depend,dependencies,48,"// Calls will not be reordered because of chain dependencies (see; // below). Since call operands are dead, calls may continue to be added; // to the DefList making dependence checking quadratic in the size of; // the block. Instead, we leave only one call at the back of the; // DefList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:165,Integrability,depend,dependence,165,"// Calls will not be reordered because of chain dependencies (see; // below). Since call operands are dead, calls may continue to be added; // to the DefList making dependence checking quadratic in the size of; // the block. Instead, we leave only one call at the back of the; // DefList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:113,Energy Efficiency,schedul,scheduling,113,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:312,Energy Efficiency,schedul,scheduling,312,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:34,Integrability,depend,dependencies,34,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:244,Modifiability,variab,variable,244,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Usability,Clear,Clear,3,"// Clear undef flag, we'll re-add it later once we know which subregister; // Def is first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:12,Integrability,depend,dependence,12,// Add data dependence to all uses we found so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:58,Integrability,depend,dependencies,58,// Shortcut: Singly defined vregs do not have output/anti dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:153,Availability,redundant,redundant,153,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:326,Energy Efficiency,schedul,scheduling,326,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependence,14,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:115,Integrability,depend,dependence,115,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:349,Integrability,depend,dependence,349,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:394,Performance,latency,latency,394,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:418,Performance,latency,latency,418,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:153,Safety,redund,redundant,153,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:17,Integrability,depend,dependence,17,// Add an output dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:277,Security,access,access,277,"// Ignore additional defs of the same lanes in one instruction. This can; // happen because lanemasks are shared for targets with too many; // subregisters. We also use some representration tricks/hacks where we; // add super-register defs/uses, to imply that although we only access parts; // of the reg we care about the full one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Deployability,Update,Update,3,// Update current definition. This can get tricky if the def was about a; // bigger lanemask before. We then have to shrink it and create a new; // VReg2SUnit for the non-overlapping part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:234,Energy Efficiency,schedul,scheduling,234,"/// Adds a register data dependency if the instruction that defines the; /// virtual register used at OperIdx is mapped to an SUnit. Add a register; /// antidependency from this SUnit to instructions that occur later in the same; /// scheduling region if they write the virtual register.; ///; /// TODO: Handle ExitSU ""uses"" properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,Integrability,depend,dependency,25,"/// Adds a register data dependency if the instruction that defines the; /// virtual register used at OperIdx is mapped to an SUnit. Add a register; /// antidependency from this SUnit to instructions that occur later in the same; /// scheduling region if they write the virtual register.; ///; /// TODO: Handle ExitSU ""uses"" properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:26,Integrability,depend,dependencies,26,// Remember the use. Data dependencies will be added when we find the def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:64,Availability,down,down,64,"/// Creates an SUnit for each real instruction, numbered in top-down; /// topological order. The instruction order A < B, implies that no edge exists; /// from B to A.; ///; /// Map each real instruction to its SUnit.; ///; /// After initSUnits, the SUnits vector cannot be resized and the scheduler may; /// hang onto SUnit pointers. We may relax this in the future by using SUnit IDs; /// instead of pointers.; ///; /// MachineScheduler relies on initSUnits numbering the nodes by their order in; /// the original instruction list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:290,Energy Efficiency,schedul,scheduler,290,"/// Creates an SUnit for each real instruction, numbered in top-down; /// topological order. The instruction order A < B, implies that no edge exists; /// from B to A.; ///; /// Map each real instruction to its SUnit.; ///; /// After initSUnits, the SUnits vector cannot be resized and the scheduler may; /// hang onto SUnit pointers. We may relax this in the future by using SUnit IDs; /// instead of pointers.; ///; /// MachineScheduler relies on initSUnits numbering the nodes by their order in; /// the original instruction list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Performance,Latency,Latency,14,// Assign the Latency field of SU using target-provided information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:160,Deployability,pipeline,pipeline,160,"// If this SUnit uses a reserved or unbuffered resource, mark it as such.; //; // Reserved resources block an instruction from issuing and stall the; // entire pipeline. These are identified by BufferSize=0.; //; // Unbuffered resources prevent execution of subsequent instructions that; // require the same resources. This is used for in-order execution pipelines; // within an out-of-order core. These are identified by BufferSize=1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:355,Deployability,pipeline,pipelines,355,"// If this SUnit uses a reserved or unbuffered resource, mark it as such.; //; // Reserved resources block an instruction from issuing and stall the; // entire pipeline. These are identified by BufferSize=0.; //; // Unbuffered resources prevent execution of subsequent instructions that; // require the same resources. This is used for in-order execution pipelines; // within an out-of-order core. These are identified by BufferSize=1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,Performance,load,loads,10,"/// 1 for loads, 0 for stores. (see comment in SUList)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:51,Energy Efficiency,reduce,reduce,51,"/// Adds SU to the SUList of V. If Map grows huge, reduce its size by calling; /// reduce().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:83,Energy Efficiency,reduce,reduce,83,"/// Adds SU to the SUList of V. If Map grows huge, reduce its size by calling; /// reduce().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:4,Usability,Clear,Clears,4,/// Clears the list of SUs mapped to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:4,Usability,Clear,Clears,4,/// Clears map from all contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:12,Energy Efficiency,schedul,scheduling,12,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:287,Integrability,depend,depending,287,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:394,Integrability,depend,depend,394,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:319,Performance,load,loads,319,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:74,Performance,Load,Loads,74,"// Certain memory accesses are known to not alias any SU in Stores; // or Loads, and have therefore their own 'NonAlias'; // domain. E.g. spill / reload instructions never alias LLVM I/R; // Values. It would be nice to assume that this type of memory; // accesses always have a proper memory operand modelling, and are; // therefore never unanalyzable, but this is conservatively not; // done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:18,Security,access,accesses,18,"// Certain memory accesses are known to not alias any SU in Stores; // or Loads, and have therefore their own 'NonAlias'; // domain. E.g. spill / reload instructions never alias LLVM I/R; // Values. It would be nice to assume that this type of memory; // accesses always have a proper memory operand modelling, and are; // therefore never unanalyzable, but this is conservatively not; // done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:255,Security,access,accesses,255,"// Certain memory accesses are known to not alias any SU in Stores; // or Loads, and have therefore their own 'NonAlias'; // domain. E.g. spill / reload instructions never alias LLVM I/R; // Values. It would be nice to assume that this type of memory; // accesses always have a proper memory operand modelling, and are; // therefore never unanalyzable, but this is conservatively not; // done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:85,Integrability,depend,depend,85,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:116,Performance,load,loads,116,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:329,Usability,simpl,simply,329,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:54,Energy Efficiency,schedul,scheduled,54,// Model data dependencies between instructions being scheduled and the; // ExitSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependencies,14,// Model data dependencies between instructions being scheduled and the; // ExitSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:22,Integrability,depend,dependencies,22,"// Add register-based dependencies (data, anti, and output).; // For some instructions (calls, returns, inline-asm, etc.) there can; // be explicit uses and implicit defs, in which case the use will appear; // on the operand list before the def. Do two passes over the operand; // list to make sure that defs are processed before any uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:137,Integrability,depend,dependence,137,// Only look at use operands.; // We do not need to check for MO.readsReg() here because subsequent; // subregister defs will get output dependence edges and need no; // additional use dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:185,Integrability,depend,dependencies,185,// Only look at use operands.; // We do not need to check for MO.readsReg() here because subsequent; // subregister defs will get output dependence edges and need no; // additional use dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:39,Energy Efficiency,schedul,scheduling,39,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:71,Integrability,depend,dependence,71,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:119,Performance,latency,latency,119,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependencies,14,// Add memory dependencies (Note: isStoreToStackSlot and; // isLoadFromStackSLot are not usable after stack slots are lowered to; // actual addresses).; // This is a barrier event that acts as a pivotal node in the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:89,Usability,usab,usable,89,// Add memory dependencies (Note: isStoreToStackSlot and; // isLoadFromStackSLot are not usable after stack slots are lowered to; // actual addresses).; // This is a barrier event that acts as a pivotal node in the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Integrability,depend,dependencies,7,// Add dependencies against everything below it and clear maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:52,Usability,clear,clear,52,// Add dependencies against everything below it and clear maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:36,Performance,load,load,36,"// If it's not a store or a variant load, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependecy,14,// Always add dependecy edge to BarrierChain if present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:140,Integrability,depend,depends,140,"// Find the underlying objects for MI. The Objs vector is either; // empty, or filled with the Values of memory locations which this; // SU depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:20,Integrability,depend,depends,20,// An unknown store depends on all stores and loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:46,Performance,load,loads,46,// An unknown store depends on all stores and loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:15,Integrability,depend,dependencies,15,// Add precise dependencies against all previously seen memory; // accesses mapped to the same Value(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:67,Security,access,accesses,67,// Add precise dependencies against all previously seen memory; // accesses mapped to the same Value(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Integrability,depend,dependencies,7,// Add dependencies to previous stores and loads mapped to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:43,Performance,load,loads,43,// Add dependencies to previous stores and loads mapped to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Deployability,Update,Update,3,// Update the store map after all chains have been added to avoid adding; // self-loop edge if multiple underlying objects are present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:60,Safety,avoid,avoid,60,// Update the store map after all chains have been added to avoid adding; // self-loop edge if multiple underlying objects are present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:22,Integrability,depend,dependencies,22,// The store may have dependencies to unanalyzable loads and; // stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:51,Performance,load,loads,51,// The store may have dependencies to unanalyzable loads and; // stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:11,Performance,load,load,11,// SU is a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:19,Integrability,depend,depends,19,// An unknown load depends on all stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Performance,load,load,14,// An unknown load depends on all stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:15,Integrability,depend,dependencies,15,// Add precise dependencies against all previously seen stores; // mapping to the same Value(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:12,Performance,load,load,12,// Map this load to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:21,Integrability,depend,dependencies,21,// The load may have dependencies to unanalyzable stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Performance,load,load,7,// The load may have dependencies to unanalyzable stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce maps if they grow huge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:171,Integrability,depend,dependency,171,"// The N last elements in NodeNums will be removed, and the SU with; // the lowest NodeNum of them will become the new BarrierChain to; // let the not yet seen SUs have a dependency to the removed SUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:38,Energy Efficiency,reduce,reduce,38,"// The aliasing and non-aliasing maps reduce independently of each; // other, but share a common BarrierChain. Check if the; // newBarrierChain is above the former one. If it is not, it may; // introduce a loop to use newBarrierChain, so keep the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:19,Availability,avail,available,19,// Things that are available after the instruction are killed by it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Deployability,Update,Update,3,// Update liveness. Registers that are defed but not used in this; // instruction are now dead. Mark register and all subregs as they; // are completely defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:103,Energy Efficiency,schedul,scheduling,103,/// Return the basic block label. It is not necessarilly unique because a block; /// contains multiple scheduling regions. But it is fine for visualization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:45,Energy Efficiency,schedul,scheduling,45,"// Do not use WillCreateCycle, it assumes SD scheduling.; // If Pred is reachable from Succ, then the edge creates a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:175,Deployability,update,updated,175,"/// Returns true if this node been visited by the DFS traversal.; ///; /// During visitPostorderNode the Node's SubtreeID is assigned to the Node; /// ID. Later, SubtreeID is updated but remains valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:45,Energy Efficiency,schedul,scheduled,45,"/// The root of the given SubtreeID was just scheduled. For all subtrees; /// connected to this tree, record the depth of the connection so that the; /// nearest connected subtrees can be prioritized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp:8,Energy Efficiency,Schedul,ScheduleDAGPrinter,8,"//===-- ScheduleDAGPrinter.cpp - Implement ScheduleDAG::viewGraph() -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements the ScheduleDAG::viewGraph method.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp:43,Energy Efficiency,Schedul,ScheduleDAG,43,"//===-- ScheduleDAGPrinter.cpp - Implement ScheduleDAG::viewGraph() -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements the ScheduleDAG::viewGraph method.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp:403,Energy Efficiency,Schedul,ScheduleDAG,403,"//===-- ScheduleDAGPrinter.cpp - Implement ScheduleDAG::viewGraph() -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements the ScheduleDAG::viewGraph method.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:40,Energy Efficiency,Schedul,Scheduler,40,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:496,Energy Efficiency,schedul,scheduling,496,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:525,Energy Efficiency,schedul,scheduling,525,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:464,Safety,hazard,hazard-avoidance,464,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:157,Safety,avoid,avoid,157,// Determine the maximum depth of any itinerary. This determines the depth of; // the scoreboard. We always make the scoreboard at least 1 cycle deep to; // avoid dealing with the boundary condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:17,Energy Efficiency,power,power-of-,17,// Find the next power-of-2 >= ItinDepth,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:176,Safety,hazard,hazard,176,"// Don't set MaxLookAhead until we find at least one nonzero stage.; // This way, an itinerary with no stages has MaxLookAhead==0, which; // completely bypasses the scoreboard hazard logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:183,Testability,log,logic,183,"// Don't set MaxLookAhead until we find at least one nonzero stage.; // This way, an itinerary with no stages has MaxLookAhead==0, which; // completely bypasses the scoreboard hazard logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:51,Energy Efficiency,schedul,scheduling,51,// Note that stalls will be negative for bottom-up scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:15,Safety,hazard,hazards,15,// Don't check hazards for non-machineinstr Nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:33,Deployability,pipeline,pipeline,33,"// This stage was stalled beyond pipeline depth, so cannot conflict.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:3,Energy Efficiency,reduce,reduce,3,// reduce to a single unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:93,Integrability,depend,dependence,93,// Returns true if there are expensive instructions in the cold value; // operand's (if any) dependence slice of any of the selects of the given; // group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,Integrability,depend,dependence,57,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for producing the operands; // of the source instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,Safety,predict,predictable,57,// Returns true if the condition of the select is highly predictable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:15,Performance,latency,latency,15,// Returns the latency cost of a given instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,Safety,predict,prediction,41,// Returns the cost of a branch when the prediction is correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:81,Performance,optimiz,optimization,81,// If none of the select types are supported then skip this pass.; // This is an optimization pass. Legality issues will be handled by; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing for size, selects are preferable over branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:81,Performance,optimiz,optimization,81,// If none of the select types are supported then skip this pass.; // This is an optimization pass. Legality issues will be handled by; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing for size, selects are preferable over branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:107,Performance,optimiz,optimizeSelectInst,107,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:306,Performance,optimiz,optimizeSelectInst,306,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:329,Performance,optimiz,optimizing,329,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:1137,Performance,optimiz,optimized,1137,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:221,Safety,redund,redundancy,221,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:235,Testability,log,logic,235,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,Integrability,depend,dependence,41,"// For each select, compute the sinkable dependence chains of the true and; // false operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:362,Availability,down,downside,362,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:315,Energy Efficiency,schedul,scheduling,315,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:549,Energy Efficiency,schedul,scheduling,549,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:637,Energy Efficiency,schedul,scheduler,637,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:87,Integrability,depend,dependent,87,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:137,Integrability,depend,dependence,137,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:203,Performance,perform,performance,203,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:428,Usability,simpl,simple,428,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:106,Modifiability,variab,variable,106,"// Iterate over all instructions in between SI and LastSI, not including; // SI itself. These are all the variable assignments that happen ""in the; // middle"" of the select group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:49,Performance,optimiz,optimizing,49,"// If the select type is not supported, no point optimizing it.; // Instruction selection will take care of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:623,Availability,avail,available,623,"// For each select group in an inner-most loop,; // a branch is more preferable than a select/conditional-move if:; // i) conversion to branches for all the select groups of the loop satisfies; // loop-level heuristics including reducing the loop's critical path by; // some threshold (see SelectOptimizeImpl::checkLoopHeuristics); and; // ii) the total cost of the select group is cheaper with a branch compared; // to its predicated version. The cost is in terms of latency and the cost; // of a select group is the cost of its most expensive select instruction; // (assuming infinite resources and thus fully leveraging available ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:468,Performance,latency,latency,468,"// For each select group in an inner-most loop,; // a branch is more preferable than a select/conditional-move if:; // i) conversion to branches for all the select groups of the loop satisfies; // loop-level heuristics including reducing the loop's critical path by; // some threshold (see SelectOptimizeImpl::checkLoopHeuristics); and; // ii) the total cost of the select group is cheaper with a branch compared; // to its predicated version. The cost is in terms of latency and the cost; // of a select group is the cost of its most expensive select instruction; // (assuming infinite resources and thus fully leveraging available ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:37,Performance,optimiz,optimize,37,// Skip cold basic blocks. Better to optimize for size for cold blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:13,Safety,predict,predictable,13,"// If highly predictable, branch form is more profitable, unless a; // predictable select is inexpensive in the target architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:71,Safety,predict,predictable,71,"// If highly predictable, branch form is more profitable, unless a; // predictable select is inexpensive in the target architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:66,Integrability,depend,dependence,66,// Look for expensive instructions in the cold operand's (if any) dependence; // slice of any of the selects in the group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:28,Integrability,depend,dependence,28,// Check if the cold path's dependence slice is expensive for any of the; // selects of the group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:31,Performance,Load,LoadI,31,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:158,Performance,load,load,158,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:18,Safety,safe,safe,18,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:85,Safety,safe,safe,85,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:10,Performance,load,loads,10,// Assume loads from different basic blocks are unsafe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:48,Safety,unsafe,unsafe,48,// Assume loads from different basic blocks are unsafe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,Integrability,depend,dependence,57,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for the purpose of producing; // the operands of the source instruction. As an approximation; // (sufficiently-accurate in practice), we populate this set with the; // instructions of the backwards dependence slice that only have one-use and; // form an one-use chain that leads to the source instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:324,Integrability,depend,dependence,324,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for the purpose of producing; // the operands of the source instruction. As an approximation; // (sufficiently-accurate in practice), we populate this set with the; // instructions of the backwards dependence slice that only have one-use and; // form an one-use chain that leads to the source instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Safety,Avoid,Avoid,3,// Avoid cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:110,Safety,Avoid,Avoid,110,// Cannot soundly sink instructions with side-effects.; // Terminator or phi instructions cannot be sunk.; // Avoid sinking other select instructions (should be handled separetely).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:17,Performance,load,loads,17,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:102,Performance,load,loaded,102,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:144,Performance,load,loads,144,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Safety,Avoid,Avoid,3,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:219,Safety,safe,safe,219,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:126,Integrability,depend,dependence,126,"// Avoid considering instructions with less frequency than the source; // instruction (i.e., avoid colder code regions of the dependence slice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Safety,Avoid,Avoid,3,"// Avoid considering instructions with less frequency than the source; // instruction (i.e., avoid colder code regions of the dependence slice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:93,Safety,avoid,avoid,93,"// Avoid considering instructions with less frequency than the source; // instruction (i.e., avoid colder code regions of the dependence slice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:45,Integrability,depend,dependence,45,// Eligible one-use instruction added to the dependence slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:45,Energy Efficiency,reduce,reduce,45,// Profitably converting to branches need to reduce the loop's critical path; // by at least some threshold (absolute gain of GainCycleThreshold cycles and; // relative gain of 12.5%).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:53,Integrability,depend,dependences,53,"// If the loop's critical path involves loop-carried dependences, the gradient; // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).; // This check ensures that the latency reduction for the loop's critical path; // keeps decreasing with sufficient rate beyond the two analyzed loop; // iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:190,Performance,latency,latency,190,"// If the loop's critical path involves loop-carried dependences, the gradient; // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).; // This check ensures that the latency reduction for the loop's critical path; // keeps decreasing with sufficient rate beyond the two analyzed loop; // iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:61,Availability,avail,available,61,"// Assume infinite resources that allow to fully exploit the available; // instruction-level parallelism.; // InstCost = InstLatency + max(Op1Cost, Op2Cost,  OpNCost)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:126,Safety,Predict,PredictedPathCost,126,"// For a select that can be converted to branch,; // compute its cost as a branch (non-predicated cost).; //; // BranchCost = PredictedPathCost + MispredictCost; // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb; // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:165,Safety,Predict,PredictedPathCost,165,"// For a select that can be converted to branch,; // compute its cost as a branch (non-predicated cost).; //; // BranchCost = PredictedPathCost + MispredictCost; // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb; // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:40,Safety,predict,predictable,40,"// If the select condition is obviously predictable, then the misprediction; // rate is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:106,Integrability,depend,dependence,106,// CondCost is included to account for cases where the computation of the; // condition is part of a long dependence chain (potentially loop-carried); // that would delay detection of a misprediction and increase its cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:171,Safety,detect,detection,171,// CondCost is included to account for cases where the computation of the; // condition is part of a long dependence chain (potentially loop-carried); // that would delay detection of a misprediction and increase its cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,Safety,predict,prediction,41,// Returns the cost of a branch when the prediction is correct.; // TrueCost * TrueProbability + FalseCost * FalseProbability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:574,Deployability,pipeline,pipeline,574,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:129,Safety,safe,safe,129,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:264,Safety,safe,safe,264,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:643,Testability,assert,asserts,643,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:171,Usability,simpl,simple,171,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:23,Modifiability,variab,variable,23,// Specifies length of variable length array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:34,Performance,load,load,34,// Initialize the map pointer and load the current head of the shadow stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:131,Safety,avoid,avoids,131,// Delete the original allocas (which are no longer used) and the intrinsic; // calls (which are no longer valid). Doing this last avoids invalidating; // iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:1743,Deployability,update,updated,1743,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:32,Safety,safe,safe,32,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:403,Safety,safe,safe,403,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:475,Safety,safe,safe,475,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:571,Safety,safe,safe,571,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:873,Safety,safe,safe,873,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:1302,Safety,safe,safe,1302,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:172,Integrability,wrap,wrapping,172,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:33,Safety,safe,safe,33,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:378,Safety,safe,safe,378,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:12,Safety,safe,safe,12,/// Current safe point found for the prologue.; /// The prologue will be inserted before the first instruction; /// in this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:12,Safety,safe,safe,12,/// Current safe point found for the epilogue.; /// The epilogue will be inserted before the first terminator instruction; /// in this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:64,Security,access,access,64,/// Is `true` for block numbers where we can guarantee no stack access; /// or computation of stack-relative addresses on any CFG path including; /// the block itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:4,Deployability,Update,Update,4,/// Update the Save and Restore points such that \p MBB is in; /// the region that is dominated by Save and post-dominated by Restore; /// and Save and Restore still match the safe point definition.; /// Such point may not exist and Save and/or Restore may be null after; /// this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:176,Safety,safe,safe,176,/// Update the Save and Restore points such that \p MBB is in; /// the region that is dominated by Save and post-dominated by Restore; /// and Save and Restore still match the safe point definition.; /// Such point may not exist and Save and/or Restore may be null after; /// this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:15,Safety,safe,safe,15,// Try to find safe point based on dominance and block frequency without; // any change in IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:87,Integrability,wrap,wrapping,87,/// Check whether or not Save and Restore points are still interesting for; /// shrink-wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:20,Integrability,wrap,wrapping,20,/// Check if shrink wrapping is enabled for this target and function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:45,Deployability,update,update,45,/// Perform the shrink-wrapping analysis and update; /// the MachineFrameInfo attached to \p MF with the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:23,Integrability,wrap,wrapping,23,/// Perform the shrink-wrapping analysis and update; /// the MachineFrameInfo attached to \p MF with the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:4,Performance,Perform,Perform,4,/// Perform the shrink-wrapping analysis and update; /// the MachineFrameInfo attached to \p MF with the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:31,Security,access,access,31,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:99,Security,access,accesses,99,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:212,Security,access,accesses,212,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:264,Security,access,accessed,264,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Performance,Load,Load,3,// Load/store operations may access the stack indirectly when we previously; // computed an address to a stack location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:29,Security,access,access,29,// Load/store operations may access the stack indirectly when we previously; // computed an address to a stack location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:18,Deployability,update,updates,18,/// This function updates the branches post restore point split.; ///; /// Restore point has been split.; /// Old restore point: MBB; /// New restore point: NMBB; /// Any basic block(say BBToUpdate) which had a fallthrough to MBB; /// previously should; /// 1. Fallthrough to NMBB iff NMBB is inserted immediately above MBB in the; /// block layout OR; /// 2. Branch unconditionally to NMBB iff NMBB is inserted at any other place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:106,Performance,optimiz,optimizer,106,// Insert this block at the end of the function. Inserting in between may; // interfere with control flow optimizer decisions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:18,Usability,undo,undoes,18,/// This function undoes the restore point split done earlier.; ///; /// DirtyPreds: All predecessors of \p NMBB that are ReachableByDirty.; ///; /// Restore point was split and the change needs to be unrolled. Make necessary; /// changes to reset restore point from \p NMBB to \p MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:19,Performance,optimiz,optimization,19,// Bail out of the optimization if any of the basic block is target of; // INLINEASM_BR instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:63,Integrability,depend,depending,63,"// Make sure if the new restore point is valid as an epilogue, depending on; // targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Safety,Abort,Abort,3,"// Abort, we can't find a restore point in this case.; // Make sure we would be able to insert the restore code before the; // terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Safety,Abort,Abort,3,"// Abort, we can't find a restore point in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:54,Integrability,wrap,wrapping,54,// Make sure Save and Restore are suitable for shrink-wrapping:; // 1. all path from Save needs to lead to Restore before exiting.; // 2. all path to Restore needs to go through Save from Entry.; // We achieve that by making sure that:; // A. Save dominates Restore.; // B. Restore post-dominates Save.; // C. Save and Restore are in the same loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:160,Safety,safe,safe,160,"// If the immediate post-dominator is not in a less nested loop,; // then we are stuck in a program with an infinite loop.; // In that case, we will not find a safe point, hence, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:31,Security,access,accesses,31,// Check if we found any stack accesses in the predecessors. We are not; // doing a full dataflow analysis here to keep things simple but just; // rely on a reverse portorder traversal (RPOT) to guarantee predecessors; // are already processed except for loops (and accept the conservative; // result for loops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:127,Usability,simpl,simple,127,// Check if we found any stack accesses in the predecessors. We are not; // doing a full dataflow analysis here to keep things simple but just; // rely on a reverse portorder traversal (RPOT) to guarantee predecessors; // are already processed except for loops (and accept the conservative; // result for loops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:83,Integrability,wrap,wrapping,83,// Windows with CFI has some limitations that make it impossible; // to use shrink-wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Security,Sanitiz,Sanitizers,3,"// Sanitizers look at the value of the stack at the location; // of the crash. Since a crash can happen anywhere, the; // frame must be lowered before anything else happen for the; // sanitizers to be able to get a correct stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:184,Security,sanitiz,sanitizers,184,"// Sanitizers look at the value of the stack at the location; // of the crash. Since a crash can happen anywhere, the; // frame must be lowered before anything else happen for the; // sanitizers to be able to get a correct stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:163,Integrability,wrap,wrapping,163,"// If EnableShrinkWrap is set, it takes precedence on whatever the; // target sets. The rational is that we assume we want to test; // something related to shrink-wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:126,Testability,test,test,126,"// If EnableShrinkWrap is set, it takes precedence on whatever the; // target sets. The rational is that we assume we want to test; // something related to shrink-wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:10,Integrability,Interface,Interface,10,// Public Interface To the SjLjEHPrepare pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:27,Energy Efficiency,Allocate,Allocate,27,/// setupFunctionContext - Allocate the function context on the stack and fill; /// it with all of the data that we know at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:32,Safety,avoid,avoid,32,"/// lowerIncomingArguments - To avoid having to handle incoming arguments; /// specially, we lower each arg to a copy instruction in the entry block. This; /// ensures that the argument value itself cannot be live out of the entry; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:9,Availability,error,error,9,// Swift error really is a register that we model as memory -- instruction; // selection will perform mem-to-reg for us and spill/reload appropriately; // around calls that clobber it. There is no need to spill this; // value to the stack and doing so would not be allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:94,Performance,perform,perform,94,// Swift error really is a register that we model as memory -- instruction; // selection will perform mem-to-reg for us and spill/reload appropriately; // around calls that clobber it. There is no need to spill this; // value to the stack and doing so would not be allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:58,Availability,alive,alive,58,/// lowerAcrossUnwindEdges - Find all variables which are alive across an unwind; /// edge and spill them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:38,Modifiability,variab,variables,38,/// lowerAcrossUnwindEdges - Find all variables which are alive across an unwind; /// edge and spill them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid iterator invalidation by copying users to a temporary vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:28,Safety,avoid,avoid,28,// Place PHIs into a set to avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:37,Deployability,update,update,37,"// At this point, we are all set up, update the invoke instructions to mark; // their call_site values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:49,Deployability,update,update,49,"// Following any allocas not in the entry block, update the saved SP in the; // jmpbuf to the new value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:33,Energy Efficiency,allocate,allocated,33,// The indexList's nodes are all allocated in the BumpPtrAllocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:294,Testability,assert,assert,294,"// Compute numbering as follows:; // Grab an iterator to the start of the index list.; // Iterate over all MBBs, and within each MBB all MIs, keeping the MI; // iterator in lock-step (though skipping it over indexes which have; // null pointers in the instruction field).; // At each iteration assert that the instruction pointed to in the index; // is the same one pointed to by the MI iterator. This; // FIXME: This can be simplified. The mi2iMap_, Idx2MBBMap, etc. should; // only need to be set up once after the first numbering is computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:425,Usability,simpl,simplified,425,"// Compute numbering as follows:; // Grab an iterator to the start of the index list.; // Iterate over all MBBs, and within each MBB all MIs, keeping the MI; // iterator in lock-step (though skipping it over indexes which have; // null pointers in the instruction field).; // At each iteration assert that the instruction pointed to in the index; // is the same one pointed to by the MI iterator. This; // FIXME: This can be simplified. The mi2iMap_, Idx2MBBMap, etc. should; // only need to be set up once after the first numbering is computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:51,Deployability,update,update,51,// When removing the first instruction of a bundle update mapping to next; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:3,Availability,Repair,Repair,3,// Repair indexes after adding and removing instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:84,Deployability,update,update,84,"// In theory this could be combined with the previous loop, but it is tricky; // to update the IndexList while we are iterating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:1160,Deployability,update,updated,1160,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:893,Energy Efficiency,energy,energy,893,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:990,Energy Efficiency,energy,energy,990,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:658,Modifiability,variab,variable,658,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:125,Integrability,depend,depends,125,"/// Node - Each edge bundle corresponds to a Hopfield node.; ///; /// The node contains precomputed frequency data that only depends on the CFG,; /// but Bias and Links are computed each time placeSpills is called.; ///; /// The node Value is positive when the variable should be in a register. The; /// value can change when linked nodes change, but convergence is very fast; /// because all weights are positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:261,Modifiability,variab,variable,261,"/// Node - Each edge bundle corresponds to a Hopfield node.; ///; /// The node contains precomputed frequency data that only depends on the CFG,; /// but Bias and Links are computed each time placeSpills is called.; ///; /// The node Value is positive when the variable should be in a register. The; /// value can change when linked nodes change, but convergence is very fast; /// because all weights are positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:154,Modifiability,variab,variable,154,"/// Value - Output value of this node computed from the Bias and links.; /// This is always on of the values {-1, 0, 1}. A positive number means the; /// variable should go in a register through this bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:21,Performance,Cache,Cached,21,/// SumLinkWeights - Cached sum of the weights of all links + ThresHold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:69,Integrability,depend,depend,69,"/// clear - Reset per-query data, but preserve frequencies that only depend on; /// the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:4,Usability,clear,clear,4,"/// clear - Reset per-query data, but preserve frequencies that only depend on; /// the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:3,Deployability,Update,Update,3,// Update cached sum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:10,Performance,cache,cached,10,// Update cached sum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:4,Deployability,update,update,4,/// update - Recompute Value from Bias and Links. Return true when node; /// preference changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:333,Availability,error,errors,333,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:214,Safety,avoid,avoids,214,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:104,Usability,simpl,simply,104,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:156,Energy Efficiency,allocate,allocate,156,"// Very large bundles usually come from big switches, indirect branches,; // landing pads, or loops with many 'continue' statements. It is difficult to; // allocate registers when so many different blocks are involved.; //; // Give a small negative bias to large bundles such that a substantial; // fraction of the connected blocks need to be interested before we consider; // expanding the region through the bundle. This helps compile time by; // limiting the number of blocks visited and the number of links in the; // Hopfield network.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:25,Deployability,update,update,25,/// iterate - Repeatedly update the Hopfield nodes until stability or the; /// maximum number of iterations is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:116,Deployability,Update,Update,116,"// Since the last iteration, the todolist have been augmented by calls; // to addConstraints, addLinks, and co.; // Update the network energy starting at this new frontier.; // The call to ::update will add the nodes that changed into the todolist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:191,Deployability,update,update,191,"// Since the last iteration, the todolist have been augmented by calls; // to addConstraints, addLinks, and co.; // Update the network energy starting at this new frontier.; // The call to ::update will add the nodes that changed into the todolist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:135,Energy Efficiency,energy,energy,135,"// Since the last iteration, the todolist have been augmented by calls; // to addConstraints, addLinks, and co.; // Update the network energy starting at this new frontier.; // The call to ::update will add the nodes that changed into the todolist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:697,Modifiability,variab,variable,697,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:805,Modifiability,variab,variable,805,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:872,Modifiability,variab,variable,872,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:938,Modifiability,variab,variable,938,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:34,Deployability,update,updated,34,/// List of nodes that need to be updated in ::iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:26,Modifiability,variab,variable,26,///< Block doesn't care / variable not live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:31,Modifiability,variab,variable,31,"///< A register is impossible, variable must be spilled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:154,Modifiability,variab,variable,154,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:263,Modifiability,variab,variable,263,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:348,Modifiability,variab,variable,348,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:328,Usability,clear,clear,328,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:182,Modifiability,variab,variable,182,/// addConstraints - Add constraints and biases. This method may be called; /// more than once to accumulate constraints.; /// @param LiveBlocks Constraints for blocks that have the variable live in or; /// live out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:24,Performance,Perform,Perform,24,"/// scanActiveBundles - Perform an initial scan of all bundles activated by; /// addConstraints and addLinks, updating their state. Add all the bundles; /// that now prefer a register to RecentPositive.; /// Prepare internal data structures for iterate.; /// Return true is there are any positive nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:14,Deployability,Update,Update,14,"/// iterate - Update the network iteratively until convergence, or new bundles; /// are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:392,Modifiability,variab,variable,392,"/// finish - Compute the optimal spill code placement given the; /// constraints. No MustSpill constraints will be violated, and the smallest; /// possible number of PrefX constraints will be violated, weighted by; /// expected execution frequencies.; /// The selected bundles are returned in the bitvector passed to prepare().; /// @return True if a perfect solution was found, allowing the variable to be; /// in a register through all relevant bundles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:73,Availability,alive,alive,73,// The def of statepoint instruction is a gc relocation and it should be alive; // in landing pad. So we cannot split interval after statepoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:52,Availability,mask,mask,52,/// Find a subrange corresponding to the exact lane mask @p LM in the live; /// interval @p LI. The interval @p LI is assumed to contain such a subrange.; /// This function is used to find corresponding subranges between the; /// original interval and the new intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:46,Availability,mask,mask,46,"/// Find a subrange corresponding to the lane mask @p LM, or a superset of it,; /// in the live interval @p LI. The interval @p LI is assumed to contain such; /// a subrange. This function is used to find corresponding subranges between; /// the original interval and the new intervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:82,Deployability,update,update,82,"// If we are transferring a def from the original interval, make sure; // to only update the subranges for which the original subranges had; // a def at this location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:203,Deployability,update,updated,203,"// This is a new def: either from rematerialization, or from an inserted; // copy. Since rematerialization can regenerate a definition of a sub-; // register, we need to check which subranges need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:98,Usability,simpl,simple,98,"// This was the first time (RegIdx, ParentVNI) was mapped, and it is not; // forced. Keep it as a simple def without any liveness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:31,Usability,simpl,simple,31,"// If the previous value was a simple mapping, add liveness for it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:15,Usability,simpl,simple,15,"// No longer a simple mapping. Switch to a complex mapping. If the; // interval has subranges, make it a forced mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:65,Usability,simpl,simple,65,// Only a subset of lanes needs to be copied. The following is a simple; // heuristic to construct a sequence of COPYs. We could add a target; // specific callback if this turns out to be suboptimal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Safety,Abort,Abort,3,// Abort if we cannot possibly implement the COPY with the given indexes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:23,Safety,avoid,avoid,23,"// We may be trying to avoid interference that ends at a deleted instruction,; // so always begin RegIdx 0 early and all others late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:35,Modifiability,extend,extended,35,// The complement interval will be extended as needed by LICalc.extend().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:64,Modifiability,extend,extend,64,// The complement interval will be extended as needed by LICalc.extend().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:78,Safety,avoid,avoid,78,// Adjust RegAssign if a register assignment is killed at Def. We want to; // avoid calculating the live range of the source register if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:103,Usability,simpl,simply,103,// Leave loop by going to the immediate dominator of the loop header.; // This is a bigger stride than simply walking up the dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:71,Availability,redundant,redundant,71,"// For VNI aggregation of each ParentVNI, collect dominated, i.e.,; // redundant VNIs to BackCopies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:71,Safety,redund,redundant,71,"// For VNI aggregation of each ParentVNI, collect dominated, i.e.,; // redundant VNIs to BackCopies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:249,Usability,simpl,simply,249,"/// For SM_Size mode, find a common dominator for all the back-copies for; /// the same ParentVNI and hoist the backcopies to the dominator BB.; /// For SM_Speed mode, if the common dominator is hot and it is not beneficial; /// to do the hoisting, simply remove the dominated backcopies for the same; /// ParentVNI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:10,Availability,redundant,redundant,10,// Remove redundant back-copies that are now known to be dominated by another; // def with the same value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:10,Safety,redund,redundant,10,// Remove redundant back-copies that are now known to be dominated by another; // def with the same value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:74,Availability,redundant,redundant,74,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:74,Safety,redund,redundant,74,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:56,Usability,simpl,simply,56,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:144,Modifiability,extend,extend,144,"/// transferValues - Transfer all possible values to the new live ranges.; /// Values that were rematerialized are left alone, they need LICalc.extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:31,Deployability,continuous,continuously,31,"// The interval [Start;End) is continuously mapped to RegIdx, ParentVNI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:15,Usability,simpl,simply,15,// Check for a simply defined value that can be blitted directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Extend,Extend,3,"// Extend live ranges to be live-out for successor PHI values.; // Visit each PHI def slot in the parent live interval. If the def is dead,; // remove it. Otherwise, extend the live interval to reach the end indexes; // of all predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:166,Modifiability,extend,extend,166,"// Extend live ranges to be live-out for successor PHI values.; // Visit each PHI def slot in the parent live interval. If the def is dead,; // remove it. Otherwise, extend the live interval to reach the end indexes; // of all predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:4,Modifiability,rewrite,rewriteAssigned,4,/// rewriteAssigned - Rewrite all uses of Edit->getReg().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:22,Modifiability,Rewrite,Rewrite,22,/// rewriteAssigned - Rewrite all uses of Edit->getReg().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite to the mapped register at Idx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Extend,Extend,3,// Extend liveness to Idx if the instruction reads reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:18,Modifiability,extend,extend,18,"// We may want to extend a live range for a partial redef, or for a use; // tied to an early clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:14,Modifiability,extend,extend,14,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:320,Modifiability,extend,extend,320,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:382,Modifiability,extend,extend,382,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:459,Modifiability,extend,extend,459,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:20,Modifiability,extend,extending,20,"// We have to delay extending subranges until we have seen all operands; // defining the register. This is because a <def,read-undef> operand; // will create an ""undef"" point, and we cannot extend any subranges; // until all of them have been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:190,Modifiability,extend,extend,190,"// We have to delay extending subranges until we have seen all operands; // defining the register. This is because a <def,read-undef> operand; // will create an ""undef"" point, and we cannot extend any subranges; // until all of them have been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:16,Usability,simpl,simply,16,"// Transfer the simply mapped values, check if any are skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite virtual registers, possibly extending ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:39,Modifiability,extend,extending,39,"// Rewrite virtual registers, possibly extending ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:413,Safety,avoid,avoiding,413,//===----------------------------------------------------------------------===//; // Global Live Range Splitting Support; //===----------------------------------------------------------------------===//; // These methods support a method of global live range splitting that uses a; // global algorithm to decide intervals for CFG edges. They will insert split; // points and color intervals in basic blocks while avoiding interference.; //; // Note that splitSingleBlock is also useful for blocks where both CFG edges; // are on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:132,Energy Efficiency,allocate,allocated,132,// The interference is overlapping somewhere we wanted to use IntvIn. That; // means we need to create a local interval that can be allocated a; // different register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:133,Energy Efficiency,allocate,allocated,133,// The interference is overlapping somewhere we wanted to use IntvOut. That; // means we need to create a local interval that can be allocated a; // different register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:26,Safety,safe,safe,26,"/// Determines the latest safe point in a block in which we can insert a split,; /// spill or other instruction related with CurLI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:198,Modifiability,variab,variable,198,"/// Last legal insert point in each basic block in the current function.; /// The first entry is the first terminator, the second entry is the; /// last valid point to insert a split or spill for a variable that is; /// live into a landing pad or inlineasm_br successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:21,Usability,simpl,simple,21,// Inline the common simple case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:64,Modifiability,variab,variable,64,"/// Additional information about basic blocks where the current variable is; /// live. Such a block will look like one of these templates:; ///; /// 1. | o---x | Internal to block. Variable is only live in this block.; /// 2. |---x | Live-in, kill.; /// 3. | o---| Def, live-out.; /// 4. |---x o---| Live-in, kill, def, live-out. Counted by NumGapBlocks.; /// 5. |---o---o---| Live-through with uses or defs.; /// 6. |-----------| Live-through without uses. Counted by NumThroughBlocks.; ///; /// Two BlockInfo entries are created for template 4. One for the live-in; /// segment, and one for the live-out segment. These entries look as if the; /// block were split in the middle where the live range isn't live.; ///; /// Live-through blocks without any uses don't get BlockInfo entries. They; /// are simply listed in ThroughBlocks instead.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:181,Modifiability,Variab,Variable,181,"/// Additional information about basic blocks where the current variable is; /// live. Such a block will look like one of these templates:; ///; /// 1. | o---x | Internal to block. Variable is only live in this block.; /// 2. |---x | Live-in, kill.; /// 3. | o---| Def, live-out.; /// 4. |---x o---| Live-in, kill, def, live-out. Counted by NumGapBlocks.; /// 5. |---o---o---| Live-through with uses or defs.; /// 6. |-----------| Live-through without uses. Counted by NumThroughBlocks.; ///; /// Two BlockInfo entries are created for template 4. One for the live-in; /// segment, and one for the live-out segment. These entries look as if the; /// block were split in the middle where the live range isn't live.; ///; /// Live-through blocks without any uses don't get BlockInfo entries. They; /// are simply listed in ThroughBlocks instead.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:803,Usability,simpl,simply,803,"/// Additional information about basic blocks where the current variable is; /// live. Such a block will look like one of these templates:; ///; /// 1. | o---x | Internal to block. Variable is only live in this block.; /// 2. |---x | Live-in, kill.; /// 3. | o---| Def, live-out.; /// 4. |---x o---| Live-in, kill, def, live-out. Counted by NumGapBlocks.; /// 5. |---o---o---| Live-through with uses or defs.; /// 6. |-----------| Live-through without uses. Counted by NumThroughBlocks.; ///; /// Two BlockInfo entries are created for template 4. One for the live-in; /// segment, and one for the live-out segment. These entries look as if the; /// block were split in the middle where the live range isn't live.; ///; /// Live-through blocks without any uses don't get BlockInfo entries. They; /// are simply listed in ThroughBlocks instead.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:17,Security,access,accessing,17,///< First instr accessing current reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:16,Security,access,accessing,16,///< Last instr accessing current reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:26,Modifiability,variab,variable,26,"/// LooksLikeLoopIV - The variable defines what looks like it could be a loop; /// IV, where it defs a variable in the latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:103,Modifiability,variab,variable,103,"/// LooksLikeLoopIV - The variable defines what looks like it could be a loop; /// IV, where it defs a variable in the latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:4,Usability,clear,clear,4,/// clear - clear all data structures so SplitAnalysis is ready to analyze a; /// new interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:12,Usability,clear,clear,12,/// clear - clear all data structures so SplitAnalysis is ready to analyze a; /// new interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:474,Modifiability,Rewrite,Rewrite,474,/// SplitEditor - Edit machine code and LiveIntervals for live range; /// splitting.; ///; /// - Create a SplitEditor from a SplitAnalysis.; /// - Start a new live interval with openIntv.; /// - Mark the places where the new interval is entered using enterIntv*; /// - Mark the ranges where the new interval is used with useIntv*; /// - Mark the places where the interval is exited with exitIntv*.; /// - Finish the current interval with closeIntv and repeat from 2.; /// - Rewrite instructions with finish().; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:589,Modifiability,extend,extend,589,"/// Values - keep track of the mapping from parent values to values in the new; /// intervals. Given a pair (RegIdx, ParentVNI->id), Values contains:; ///; /// 1. No entry - the value is not mapped to Edit.get(RegIdx).; /// 2. (Null, false) - the value is mapped to multiple values in; /// Edit.get(RegIdx). Each value is represented by a minimal live range at; /// its def. The full live range can be inferred exactly from the range; /// of RegIdx in RegAssign.; /// 3. (Null, true). As above, but the ranges in RegAssign are too large, and; /// the live range must be recomputed using ::extend().; /// 4. (VNI, false) The value is mapped to a single new value.; /// The new value has no live ranges anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:53,Deployability,update,update,53,"/// LICalc - Cache for computing live ranges and SSA update. Each instance; /// can only handle non-overlapping live ranges, so use a separate; /// LiveIntervalCalc instance for the complement interval when in spill mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:13,Performance,Cache,Cache,13,"/// LICalc - Cache for computing live ranges and SSA update. Each instance; /// can only handle non-overlapping live ranges, so use a separate; /// LiveIntervalCalc instance for the complement interval when in spill mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:386,Deployability,update,updated,386,"/// Add a segment to the interval LI for the value number VNI. If LI has; /// subranges, corresponding segments will be added to them as well, but; /// with newly created value numbers. If Original is true, dead def will; /// only be added a subrange of LI if the corresponding subrange of the; /// original interval has a def at this index. Otherwise, all subranges; /// of LI will be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:105,Modifiability,extend,extend,105,"/// forceRecompute - Force the live range of ParentVNI in RegIdx to be; /// recomputed by LiveRangeCalc::extend regardless of the number of defs.; /// This is used for values whose live range doesn't match RegAssign exactly.; /// They could have rematerialized, or back-copies may have been moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:151,Availability,redundant,redundant,151,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:151,Safety,redund,redundant,151,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:132,Usability,simpl,simply,132,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:47,Availability,Mask,Mask,47,"/// Live range @p LR corresponding to the lane Mask @p LM has a live; /// PHI def at the beginning of block @p B. Extend the range @p LR of; /// all predecessor values that reach this def. If @p LR is a subrange,; /// the array @p Undefs is the set of all locations where it is undefined; /// via <def,read-undef> in other subranges for the same register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:114,Modifiability,Extend,Extend,114,"/// Live range @p LR corresponding to the lane Mask @p LM has a live; /// PHI def at the beginning of block @p B. Extend the range @p LR of; /// all predecessor values that reach this def. If @p LR is a subrange,; /// the array @p Undefs is the set of all locations where it is undefined; /// via <def,read-undef> in other subranges for the same register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:4,Modifiability,extend,extendPHIKillRanges,4,/// extendPHIKillRanges - Extend the ranges of all values killed by original; /// parent PHIDefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:26,Modifiability,Extend,Extend,26,/// extendPHIKillRanges - Extend the ranges of all values killed by original; /// parent PHIDefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:4,Modifiability,rewrite,rewriteAssigned,4,/// rewriteAssigned - Rewrite all uses of Edit.getReg() to assigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:22,Modifiability,Rewrite,Rewrite,22,/// rewriteAssigned - Rewrite all uses of Edit.getReg() to assigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:105,Modifiability,rewrite,rewrite,105,"/// finish - after all the new live ranges have been created, compute the; /// remaining live range, and rewrite instructions to use the new registers.; /// @param LRMap When not null, this vector will map each live range in Edit; /// back to the indices returned by openIntv.; /// There may be extra indices created by dead code elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:185,Safety,avoid,avoids,185,"/// splitRegInBlock - Split CurLI in the given block such that it enters the; /// block in IntvIn and leaves it on the stack (or not at all). Split points; /// are placed in a way that avoids putting uses in the stack interval. This; /// may require creating a local interval when there is interference.; ///; /// @param BI Block descriptor.; /// @param IntvIn Interval index entering the block. Not 0.; /// @param LeaveBefore When set, leave IntvIn before this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:186,Safety,avoid,avoid,186,"/// splitRegOutBlock - Split CurLI in the given block such that it enters the; /// block on the stack (or isn't live-in at all) and leaves it in IntvOut.; /// Split points are placed to avoid interference and such that the uses are; /// not in the stack interval. This may require creating a local interval; /// when there is interference.; ///; /// @param BI Block descriptor.; /// @param IntvOut Interval index leaving the block.; /// @param EnterAfter When set, enter IntvOut after this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:636,Energy Efficiency,reduce,reduce,636,"//===- StackColoring.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the stack-coloring optimization that looks for; // lifetime markers machine instructions (LIFETIME_START and LIFETIME_END),; // which represent the possible lifetime of stack slots. It attempts to; // merge disjoint stack slots and reduce the used stack space.; // NOTE: This pass is not StackSlotColoring, which optimizes spill slots.; //; // TODO: In the future we plan to improve stack coloring in the following ways:; // 1. Allow merging multiple small slots into a single larger slot at different; // offsets.; // 2. Merge this pass with StackSlotColoring and allow merging of allocas with; // spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:423,Performance,optimiz,optimization,423,"//===- StackColoring.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the stack-coloring optimization that looks for; // lifetime markers machine instructions (LIFETIME_START and LIFETIME_END),; // which represent the possible lifetime of stack slots. It attempts to; // merge disjoint stack slots and reduce the used stack space.; // NOTE: This pass is not StackSlotColoring, which optimizes spill slots.; //; // TODO: In the future we plan to improve stack coloring in the following ways:; // 1. Allow merging multiple small slots into a single larger slot at different; // offsets.; // 2. Merge this pass with StackSlotColoring and allow merging of allocas with; // spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:717,Performance,optimiz,optimizes,717,"//===- StackColoring.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the stack-coloring optimization that looks for; // lifetime markers machine instructions (LIFETIME_START and LIFETIME_END),; // which represent the possible lifetime of stack slots. It attempts to; // merge disjoint stack slots and reduce the used stack space.; // NOTE: This pass is not StackSlotColoring, which optimizes spill slots.; //; // TODO: In the future we plan to improve stack coloring in the following ways:; // 1. Allow merging multiple small slots into a single larger slot at different; // offsets.; // 2. Merge this pass with StackSlotColoring and allow merging of allocas with; // spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:216,Performance,optimiz,optimize,216,"/// The user may write code that uses allocas outside of the declared lifetime; /// zone. This can happen when the user returns a reference to a local; /// data-structure. We can detect these cases and decide not to optimize the; /// code. If this flag is enabled, we try to save the user. This option; /// is treated as overriding LifetimeStartOnFirstUse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:179,Safety,detect,detect,179,"/// The user may write code that uses allocas outside of the declared lifetime; /// zone. This can happen when the user returns a reference to a local; /// data-structure. We can detect these cases and decide not to optimize the; /// code. If this flag is enabled, we try to save the user. This option; /// is treated as overriding LifetimeStartOnFirstUse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:11,Modifiability,enhance,enhanced,11,"/// Enable enhanced dataflow scheme for lifetime analysis (treat first; /// use of stack slot as start of slot lifetime, as opposed to looking; /// for LIFETIME_START marker). See ""Implementation notes"" below for; /// more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:209,Energy Efficiency,reduce,reduces,209,"//===----------------------------------------------------------------------===//; // StackColoring Pass; //===----------------------------------------------------------------------===//; //; // Stack Coloring reduces stack usage by merging stack slots when they; // can't be used together. For example, consider the following C program:; //; // void bar(char *, int);; // void foo(bool var) {; // A: {; // char z[4096];; // bar(z, 0);; // }; //; // char *p;; // char x[4096];; // char y[4096];; // if (var) {; // p = x;; // } else {; // bar(y, 1);; // p = y + 1024;; // }; // B:; // bar(p, 2);; // }; //; // Naively-compiled, this program would use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:5830,Modifiability,Variab,Variables,5830," facts.; //; // However, we aren't interested in the *set* of points of interference; // between 2 stack slots, only *whether* there *is* such a point. So we; // can rely on a little trick: for `S` and `T` to be in-use together,; // one of them needs to become in-use while the other is in-use (or; // they might both become in use simultaneously). We can check this; // by also keeping track of the points at which a stack slot might *start*; // being in-use.; //; // Exact first use:; // ----------------; //; // Consider the following motivating example:; //; // int foo() {; // char b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6020,Modifiability,variab,variables,6020,"; // can rely on a little trick: for `S` and `T` to be in-use together,; // one of them needs to become in-use while the other is in-use (or; // they might both become in use simultaneously). We can check this; // by also keeping track of the points at which a stack slot might *start*; // being in-use.; //; // Exact first use:; // ----------------; //; // Consider the following motivating example:; //; // int foo() {; // char b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above st",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7035,Modifiability,variab,variables,7035,"ever, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifeti",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7207,Modifiability,variab,variable,7207,"b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7537,Modifiability,variab,variables,7537," -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7972,Modifiability,variab,variable,7972,"8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +---",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:10150,Modifiability,variab,variable,10150,"-------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a first reference to slot; // K before we hit the slot K lifetime start marker. For such slots,; // we fall back on using the lifetime start marker as the beginning of; // the variable's lifetime. NB: with this implementation, slots can; // appear degenerate in cases where there is unstructured control flow:; //; // if (q) goto mid;; // if (x > 9) {; // int b[100];; // memcpy(&b[0], ...);; // mid: b[k] = ...;; // abc(&b);; // }; //; // If in RPO ordering chosen to walk the CFG we happen to visit the b[k]; // before visiting the memcpy block (which will contain the lifetime start; // for ""b"" then it will appear that 'b' has a degenerate lifetime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:1256,Performance,optimiz,optimization,1256,"-----------------------------------------===//; //; // Stack Coloring reduces stack usage by merging stack slots when they; // can't be used together. For example, consider the following C program:; //; // void bar(char *, int);; // void foo(bool var) {; // A: {; // char z[4096];; // bar(z, 0);; // }; //; // char *p;; // char x[4096];; // char y[4096];; // if (var) {; // p = x;; // } else {; // bar(y, 1);; // p = y + 1024;; // }; // B:; // bar(p, 2);; // }; //; // Naively-compiled, this program would use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7922,Performance,optimiz,optimizations,7922,"8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +---",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:8259,Performance,optimiz,optimization,8259,"TIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9089,Performance,optimiz,optimization,9089,"able outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a f",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9311,Performance,load,load,9311," the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a first reference to slot; // K before we hit the slot K lifetime start marker. For such slots,; // we fall back on using the lifetime start marker as the beginning of; // the variable's lifetime. NB: with this implementation, slots can; // appear degenerate in cases where there is unstructured control flow:; //; // if (q) goto mid;; // if (x > 9) {; // int b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9388,Performance,load,loaded,9388," the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a first reference to slot; // K before we hit the slot K lifetime start marker. For such slots,; // we fall back on using the lifetime start marker as the beginning of; // the variable's lifetime. NB: with this implementation, slots can; // appear degenerate in cases where there is unstructured control flow:; //; // if (q) goto mid;; // if (x > 9) {; // int b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:1517,Security,access,accessed,1517,"r y[4096];; // if (var) {; // p = x;; // } else {; // bar(y, 1);; // p = y + 1024;; // }; // B:; // bar(p, 2);; // }; //; // Naively-compiled, this program would use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.; // L2) on a `lifetime.start`, a stack slot is marked as *in-scope* and; // the stack slot is overwritten with `undef`.; // L3) on a `lifetime.end`, a stack slot is marked as *out-of-scope*.; // L4) on function exit, all stack slots are marked as *out-of-scope*.; // L5) `lifetime.end` is a no-op when called on a slot that is already; // *ou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:1680,Security,access,accesses,1680,"uld use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.; // L2) on a `lifetime.start`, a stack slot is marked as *in-scope* and; // the stack slot is overwritten with `undef`.; // L3) on a `lifetime.end`, a stack slot is marked as *out-of-scope*.; // L4) on function exit, all stack slots are marked as *out-of-scope*.; // L5) `lifetime.end` is a no-op when called on a slot that is already; // *out-of-scope*.; // L6) memory accesses to *out-of-scope* stack slots are UB.; // L7) when a stack-slot is marked as *out-of-scope*, all pointers to it; // are in",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:2511,Security,access,accesses,2511," // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.; // L2) on a `lifetime.start`, a stack slot is marked as *in-scope* and; // the stack slot is overwritten with `undef`.; // L3) on a `lifetime.end`, a stack slot is marked as *out-of-scope*.; // L4) on function exit, all stack slots are marked as *out-of-scope*.; // L5) `lifetime.end` is a no-op when called on a slot that is already; // *out-of-scope*.; // L6) memory accesses to *out-of-scope* stack slots are UB.; // L7) when a stack-slot is marked as *out-of-scope*, all pointers to it; // are invalidated, unless the slot is ""degenerate"". This is used to; // justify not marking slots as in-use until the pointer to them is; // used, but feels a bit hacky in the presence of things like LICM. See; // the ""Degenerate Slots"" section for more details.; //; // Now, let's ground stack coloring on these rules. We'll define a slot; // as *in-use* at a (dynamic) point in execution if it either can be; // written to at that point, or if it has a live and non-undef content; // at that point.; //; // Obviously, slots that are never *in-use* together can be merged, and; // in our example `foo`, the slots for `x`, `y` and `z` are never; // in-use together (of course, sometimes slots that *are* in-use together; // might still be mergable, but we don't care about that here).; //; // In this implementation, we successively merge pairs of slots that are; // not *in-use* together. We",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6034,Security,access,accessed,6034,"; // can rely on a little trick: for `S` and `T` to be in-use together,; // one of them needs to become in-use while the other is in-use (or; // they might both become in use simultaneously). We can check this; // by also keeping track of the points at which a stack slot might *start*; // being in-use.; //; // Exact first use:; // ----------------; //; // Consider the following motivating example:; //; // int foo() {; // char b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above st",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6524,Testability,test,test,6524,"har b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the int",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:8422,Testability,test,test,8422,"TIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6386,Usability,simpl,simplified,6386,"har b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the int",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:4,Performance,Perform,Perform,4,"/// Perform the dataflow calculation and calculate the lifetime for each of; /// the slots, based on the BEGIN/END vectors. Set the LifetimeLIVE_IN and; /// LifetimeLIVE_OUT maps that represent which stack slots are live coming; /// in and out blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:217,Modifiability,variab,variable,217,"/// The input program may contain instructions which are not inside lifetime; /// markers. This can happen due to a bug in the compiler or due to a bug in; /// user code (for example, returning a reference to a local variable).; /// This procedure checks all of the instructions in the function and; /// invalidates lifetime ranges which do not contain all of the instructions; /// which access that frame slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:388,Security,access,access,388,"/// The input program may contain instructions which are not inside lifetime; /// markers. This can happen due to a bug in the compiler or due to a bug in; /// user code (for example, returning a reference to a local variable).; /// This procedure checks all of the instructions in the function and; /// invalidates lifetime ranges which do not contain all of the instructions; /// which access that frame slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:228,Integrability,interface,interface,228,"// At the moment the only way to end a variable lifetime is with; // a VARIABLE_LIFETIME op (which can't contain a start). If things; // change and the IR allows for a single inst that both begins; // and ends lifetime(s), this interface will need to be reworked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:39,Modifiability,variab,variable,39,"// At the moment the only way to end a variable lifetime is with; // a VARIABLE_LIFETIME op (which can't contain a start). If things; // change and the IR allows for a single inst that both begins; // and ends lifetime(s), this interface will need to be reworked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:70,Safety,safe,safe,70,"// PR27903: slots with multiple start or end lifetime ops are not; // safe to enable for ""lifetime-start-on-first-use"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:23,Safety,avoid,avoid,23,// Keep a reference to avoid repeated lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update statistics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:22,Safety,avoid,avoid,22,// Use an iterator to avoid repeated lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:131,Safety,safe,safely,131,// PR37130: transformations prior to stack coloring can; // sometimes leave behind statically unreachable blocks; these; // can be safely skipped here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,"// Update block LiveIn set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,"// Update block LiveOut set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:73,Deployability,update,update,73,"// For each block, find which slots are active within this block; // and update the live intervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:325,Deployability,update,update,325,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:42,Energy Efficiency,schedul,scheduling,42,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:237,Safety,safe,safe,237,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:72,Modifiability,variab,variable,72,"// The new alloca might not be valid in a llvm.dbg.declare for this; // variable, so undef out the use to make the verifier happy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:61,Deployability,update,update,61,"// Note that this will not replace uses in MMOs (which we'll update below),; // or anywhere else (which is why we won't delete the original; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update the MachineMemOperand to use the new alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update all of the machine instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:420,Security,validat,validating,420,"// In a debug build, check that the instruction that we are modifying is; // inside the expected live range. If the instruction is not inside; // the calculated range then it means that the alloca usage moved; // outside of the lifetime markers, or that the user has a bug.; // NOTE: Alloca address calculations which happen outside the lifetime; // zone are okay, despite the fact that we don't have a good way; // for validating all of the usages of the calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:73,Security,validat,validating,73,"// If we *don't* protect the user from escaped allocas, don't bother; // validating the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:28,Deployability,update,updated,28,"// If any memory operand is updated, set memory references of; // this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite MachineMemOperands that reference old frame indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update the location of C++ catch objects for the MSVC personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:69,Integrability,rout,routine,69,// Update the location of C++ catch objects for the MSVC personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:159,Security,access,accesses,159,"// Some intervals are suspicious! In some cases we find address; // calculations outside of the lifetime zone, but not actual memory; // read or write. Memory accesses outside of the lifetime zone are a clear; // violation, but address calculations are okay. This can happen when; // GEPs are hoisted outside of the lifetime zone.; // So, in here we only check instructions which can read or write memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:203,Usability,clear,clear,203,"// Some intervals are suspicious! In some cases we find address; // calculations outside of the lifetime zone, but not actual memory; // read or write. Memory accesses outside of the lifetime zone are a clear; // violation, but address calculations are okay. This can happen when; // GEPs are hoisted outside of the lifetime zone.; // So, in here we only check instructions which can read or write memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:118,Performance,optimiz,optimize,118,"// Don't continue because there are not enough lifetime markers, or the; // stack is too small, or we are told not to optimize the slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:257,Deployability,update,update,257,"// This is a simple greedy algorithm for merging allocas. First, sort the; // slots, placing the largest slots first. Next, perform an n^2 scan and look; // for disjoint slots. When you find disjoint slots, merge the smaller one; // into the bigger one and update the live interval. Remove the small alloca; // and continue.; // Sort the slots according to their size. Place unused slots at the end.; // Use stable sort to guarantee deterministic code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:124,Performance,perform,perform,124,"// This is a simple greedy algorithm for merging allocas. First, sort the; // slots, placing the largest slots first. Next, perform an n^2 scan and look; // for disjoint slots. When you find disjoint slots, merge the smaller one; // into the bigger one and update the live interval. Remove the small alloca; // and continue.; // Sort the slots according to their size. Place unused slots at the end.; // Use stable sort to guarantee deterministic code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:13,Usability,simpl,simple,13,"// This is a simple greedy algorithm for merging allocas. First, sort the; // slots, placing the largest slots first. Next, perform an n^2 scan and look; // for disjoint slots. When you find disjoint slots, merge the smaller one; // into the bigger one and update the live interval. Remove the small alloca; // and continue.; // Sort the slots according to their size. Place unused slots at the end.; // Use stable sort to guarantee deterministic code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:32,Deployability,update,update,32,// Scan the entire function and update all machine operands that use frame; // indices to use the remapped frame index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:667,Availability,avail,available,667,"//===-- StackFrameLayoutAnalysisPass.cpp; //------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // StackFrameLayoutAnalysisPass implementation. Outputs information about the; // layout of the stack frame, using the remarks interface. On the CLI it prints; // a textual representation of the stack frame. When possible it prints the; // values that occupy a stack slot using any available debug information. Since; // output is remarks based, it is also available in a machine readable file; // format, such as YAML.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:742,Availability,avail,available,742,"//===-- StackFrameLayoutAnalysisPass.cpp; //------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // StackFrameLayoutAnalysisPass implementation. Outputs information about the; // layout of the stack frame, using the remarks interface. On the CLI it prints; // a textual representation of the stack frame. When possible it prints the; // values that occupy a stack slot using any available debug information. Since; // output is remarks based, it is also available in a machine readable file; // format, such as YAML.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:512,Integrability,interface,interface,512,"//===-- StackFrameLayoutAnalysisPass.cpp; //------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // StackFrameLayoutAnalysisPass implementation. Outputs information about the; // layout of the stack frame, using the remarks interface. On the CLI it prints; // a textual representation of the stack frame. When possible it prints the; // values that occupy a stack slot using any available debug information. Since; // output is remarks based, it is also available in a machine readable file; // format, such as YAML.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:11,Availability,error,error,11,// It's an error for a slot to have this type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:7,Modifiability,variab,variables,7,// add variables to the map,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:582,Deployability,patch,patchpoint,582,"//===-- StackMapLivenessAnalysis.cpp - StackMap live Out Analysis ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the StackMap Liveness analysis pass. The pass calculates; // the liveness for each basic block in a function and attaches the register; // live-out information to a stackmap or patchpoint intrinsic if present.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:142,Deployability,patch,patchpoint,142,/// This pass calculates the liveness information for each basic block in; /// a function and attaches the register live-out information to a patchpoint; /// intrinsic if present.; ///; /// This pass can be disabled via the -enable-patchpoint-liveness=false flag.; /// The pass skips functions that don't have any patchpoint intrinsics. The; /// information provided by this pass is optional and not required by the; /// aformentioned intrinsic to function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:232,Deployability,patch,patchpoint-liveness,232,/// This pass calculates the liveness information for each basic block in; /// a function and attaches the register live-out information to a patchpoint; /// intrinsic if present.; ///; /// This pass can be disabled via the -enable-patchpoint-liveness=false flag.; /// The pass skips functions that don't have any patchpoint intrinsics. The; /// information provided by this pass is optional and not required by the; /// aformentioned intrinsic to function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:314,Deployability,patch,patchpoint,314,/// This pass calculates the liveness information for each basic block in; /// a function and attaches the register live-out information to a patchpoint; /// intrinsic if present.; ///; /// This pass can be disabled via the -enable-patchpoint-liveness=false flag.; /// The pass skips functions that don't have any patchpoint intrinsics. The; /// information provided by this pass is optional and not required by the; /// aformentioned intrinsic to function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:42,Integrability,depend,depend,42,/// Tell the pass manager which passes we depend on and what; /// information we preserve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:4,Performance,Perform,Performs,4,/// Performs the actual liveness calculation for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:22,Availability,mask,mask,22,/// Create a register mask and initialize it with the registers from; /// the register live set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:42,Integrability,depend,depend,42,/// Tell the pass manager which passes we depend on and what information we; /// preserve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:38,Deployability,patch,patchpoints,38,// Skip this function if there are no patchpoints to process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:4,Performance,Perform,Performs,4,/// Performs the actual liveness calculation for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:119,Deployability,patch,patchpoint,119,// Reverse iterate over all instructions and add the current live register; // set to an instruction if we encounter a patchpoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:22,Availability,mask,mask,22,/// Create a register mask and initialize it with the registers from the; /// register live set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:7,Availability,mask,mask,7,// The mask is owned and cleaned up by the Machine Function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:42,Availability,mask,mask,42,// Give the target a chance to adjust the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:32,Availability,mask,mask,32,/// Parse the register live-out mask and return a vector of live-out registers; /// that need to be recorded in the stackmap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:64,Availability,mask,mask,64,// Create a LiveOutReg for each bit that is set in the register mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:7,Testability,log,logical,7,// Map logical index of GC ptr to MI operand index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:53,Deployability,update,update,53,// Record the stack size of the current function and update callsite count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:97,Deployability,Patch,PatchPoint,97,"/// Emit the callsite info for each callsite.; ///; /// StkMapRecord[NumRecords] {; /// uint64 : PatchPoint ID; /// uint32 : Instruction Offset; /// uint16 : Reserved (record flags); /// uint16 : NumLocations; /// Location[NumLocations] {; /// uint8 : Register | Direct | Indirect | Constant | ConstantIndex; /// uint8 : Size in Bytes; /// uint16 : Dwarf RegNum; /// int32 : Offset; /// }; /// uint16 : Padding; /// uint16 : NumLiveOuts; /// LiveOuts[NumLiveOuts] {; /// uint16 : Dwarf RegNum; /// uint8 : Reserved; /// uint8 : Size in Bytes; /// }; /// uint32 : Padding (only if required to align to 8 byte); /// }; ///; /// Location Encoding, Type, Value:; /// 0x1, Register, Reg (value in register); /// 0x2, Direct, Reg + Offset (frame index); /// 0x3, Indirect, [Reg + Offset] (spilled value); /// 0x4, Constant, Offset (small constant); /// 0x5, ConstIndex, Constants[Offset] (large constant)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:230,Availability,error,errors,230,"// Verify stack map entry. It's better to communicate a problem to the; // runtime than crash in case of in-process compilation. Currently, we do; // simple overflow checks, but we may eventually communicate other; // compilation errors this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:150,Usability,simpl,simple,150,"// Verify stack map entry. It's better to communicate a problem to the; // runtime than crash in case of in-process compilation. Currently, we do; // simple overflow checks, but we may eventually communicate other; // compilation errors this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:551,Energy Efficiency,allocate,allocated,551,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:452,Modifiability,variab,variable,452,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:533,Modifiability,variab,variables,533,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:690,Safety,abort,aborts,690,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:123,Performance,load,loads,123,/// InsertStackProtectors - Insert code into the prologue and epilogue of the; /// function.; ///; /// - The prologue code loads and stores the stack guard onto the stack.; /// - The epilogue checks the value stored in the prologue against the original; /// value. It calls __stack_chk_fail if they differ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:52,Energy Efficiency,allocate,allocated,52,"// If an array has more than SSPBufferSize bytes of allocated space, then we; // emit stack protectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:96,Energy Efficiency,allocate,allocated,96,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:23,Security,access,accesses,23,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:60,Security,access,access,60,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:40,Performance,load,load,40,"// cmpxchg conceptually includes both a load and store from the same; // location. So, like store, the value being stored is what matters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:136,Security,access,access,136,"// If the GEP offset is out-of-bounds, or is non-constant and so has to be; // assumed to be potentially out-of-bounds, then any memory access that; // would use it could also be out-of-bounds meaning stack protection is; // required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:107,Performance,scalab,scalable,107,"// Adjust AllocSize to be the space remaining after this offset.; // We can't subtract a fixed size from a scalable one, so in that case; // assume the scalable value is of minimum size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:152,Performance,scalab,scalable,152,"// Adjust AllocSize to be the space remaining after this offset.; // We can't subtract a fixed size from a scalable one, so in that case; // assume the scalable value is of minimum size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:56,Performance,load,load-like,56,"// These instructions take an address operand, but have load-like or; // other innocuous behavior that should not trigger a stack protector.; // atomicrmw conceptually has both load and store semantics, but the; // value being stored must be integer; so if a pointer is being stored,; // we'll catch it in the PtrToInt case above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:177,Performance,load,load,177,"// These instructions take an address operand, but have load-like or; // other innocuous behavior that should not trigger a stack protector.; // atomicrmw conceptually has both load and store semantics, but the; // value being stored must be integer; so if a pointer is being stored,; // we'll catch it in the PtrToInt case above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:231,Modifiability,variab,variable,231,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:291,Modifiability,variab,variable,291,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:532,Modifiability,variab,variables,532,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:780,Modifiability,variab,variables,780,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:54,Modifiability,variab,variable,54,// The set of PHI nodes visited when determining if a variable's reference has; // been taken. This set is maintained to ensure we don't visit the same PHI; // node multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:167,Availability,avail,available,167,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:197,Deployability,pipeline,pipeline,197,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:27,Performance,Optimiz,OptimizationRemarkEmitter,27,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:107,Safety,avoid,avoid,107,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:27,Modifiability,variab,variable,27,// A call to alloca with a variable size requires protectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:3,Usability,Clear,Clear,3,"// Clear any PHIs that we visited, to make sure we examine all uses of; // any subsequent allocas that we look at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:25,Performance,load,loading,25,/// Create a stack guard loading and populate whether SelectionDAG SSP is; /// supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:150,Performance,perform,perform,150,"// Use SelectionDAG SSP handling, since there isn't an IR guard.; //; // This is more or less weird, since we optionally output whether we; // should perform a SelectionDAG SP here. The reason is that it's strictly; // defined as !TLI->getIRStackGuard(B), where getIRStackGuard is also; // mutating. There is no way to get this bit without mutating the IR, so; // getting this bit has to happen in this right time.; //; // We could have define a new function TLI::supportsSelectionDAGSP(), but that; // will put more burden on the backends' overriding work, especially when it; // actually conveys the same information getIRStackGuard() already gives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:70,Modifiability,variab,variable,70,"/// Insert code into the entry block that stores the stack guard; /// variable onto the stack:; ///; /// entry:; /// StackGuardSlot = alloca i8*; /// StackGuard = <stack guard>; /// call void @llvm.stackprotector(StackGuard, StackGuardSlot); ///; /// Returns true if the platform/triple supports the stackprotectorcreate pseudo; /// node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:103,Integrability,depend,depending,103,// Generate epilogue instrumentation. The epilogue intrumentation can be; // function-based or inlined depending on which mechanism the target is; // providing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:309,Performance,load,load,309,"// Generate the epilogue with inline instrumentation.; // If we do not support SelectionDAG based calls, generate IR level; // calls.; //; // For each block with a return instruction, convert this:; //; // return:; // ...; // ret ...; //; // into this:; //; // return:; // ...; // %1 = <stack guard>; // %2 = load StackGuardSlot; // %3 = icmp ne i1 %1, %2; // br i1 %3, label %CallStackCheckFailBlk, label %SP_return; //; // SP_return:; // ret ...; //; // CallStackCheckFailBlk:; // call void @__stack_chk_fail(); // unreachable; // Create the FailBB. We duplicate the BB every time since the MI tail; // merge pass will merge together all of the various BB into one including; // fail BB generated by the stack protector pseudo instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:101,Testability,test,test,101,// Join all intervals sharing one color into a single LiveIntervalUnion to; // speedup range overlap test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:29,Safety,avoid,avoid,29,// Single liverange (used to avoid creation of LiveIntervalUnion).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:24,Performance,perform,perform,24,// LiveIntervalUnion to perform overlap test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:40,Testability,test,test,40,// LiveIntervalUnion to perform overlap test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:124,Deployability,update,update,124,// end anonymous namespace; /// ScanForSpillSlotRefs - Scan all the machine instructions for spill slot; /// references and update spill slot weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:26,Availability,avail,available,26,// Assign it to the first available color (assumed to be the best) if it's; // not possible to share a used color with other objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:36,Energy Efficiency,allocate,allocated,36,"// Change size and alignment of the allocated slot. If there are multiple; // objects sharing the same slot, then make sure the size and alignment; // are large enough for all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:49,Modifiability,rewrite,rewrite,49,/// Colorslots - Color all spill stack slots and rewrite all frameindex machine; /// operands in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all MachineMemOperands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all MO_FrameIndex operands. Look for dead stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:4,Modifiability,Rewrite,RewriteInstruction,4,/// RewriteInstruction - Rewrite specified instruction by replacing references; /// to old frame index with new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:25,Modifiability,Rewrite,Rewrite,25,/// RewriteInstruction - Rewrite specified instruction by replacing references; /// to old frame index with new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:3,Deployability,Update,Update,3,// Update the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:44,Deployability,update,updated,44,// The MachineMemOperands have already been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:63,Performance,load,loads,63,"/// RemoveDeadStores - Scan through a basic block and look for loads followed; /// by stores. If they're both using the same stack slot, then the store is; /// definitely dead. This could obviously be much more aggressive (consider; /// pairs with instructions between them), but such extensions might have a; /// considerable compile time impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:58,Performance,load,load,58,// Skip the ...pseudo debugging... instructions between a load and store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:52,Performance,perform,perform,52,"// If there are calls to setjmp or sigsetjmp, don't perform stack slot; // coloring. The stack could be modified before the longjmp is executed,; // resulting in the wrong value being used afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:179,Security,expose,exposed,179,"// If this is the first use of this swifterror value in this basic block,; // create a new virtual register.; // After we processed all basic blocks we will satisfy this ""upwards exposed; // use"" by inserting a copy or phi at the beginning of this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:156,Availability,down,downward,156,// If there is no upwards exposed use and an entry for the swifterror in; // the def map for this value we don't need to do anything: We already; // have a downward def for this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:26,Security,expose,exposed,26,// If there is no upwards exposed use and an entry for the swifterror in; // the def map for this value we don't need to do anything: We already; // have a downward def for this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:111,Availability,down,downward,111,// Otherwise we either have an upwards exposed use vreg that we need to; // materialize or need to forward the downward def from predecessors.; // Check whether we have a single vreg def from all predecessors.; // Otherwise we need a phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:39,Security,expose,exposed,39,// Otherwise we either have an upwards exposed use vreg that we need to; // materialize or need to forward the downward def from predecessors.; // Check whether we have a single vreg def from all predecessors.; // Otherwise we need a phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:78,Availability,down,downward,78,// We need a phi node if we have more than one predecessor with different; // downward defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:26,Security,expose,exposed,26,// If there is no upwards exposed used and we don't need a phi just; // forward the swifterror vreg from the predecessor(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:54,Security,expose,exposed,54,// If we don't need a phi create a copy to the upward exposed vreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:41,Security,expose,exposed,41,// We need a phi: if there is an upwards exposed use we already have a; // destination virtual register number otherwise we generate a new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:93,Availability,down,downward,93,// We did not have a definition in this block before: store the phi's vreg; // as this block downward exposed def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:102,Security,expose,exposed,102,// We did not have a definition in this block before: store the phi's vreg; // as this block downward exposed def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:5,Performance,load,load,5,// A load is a use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:423,Performance,optimiz,optimizations,423,"//===- SwitchLoweringUtils.cpp - Switch Lowering --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains switch inst lowering optimizations and utilities for; // codegen, so that it can be used for both SelectionDAG and GlobalISel.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:36,Safety,avoid,avoid,36,// Note: loop indexes are signed to avoid underflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:50,Testability,test,tests,50,// Clusters[First..Last] should be lowered as bit tests instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:28,Performance,load,load,28,"// Create the MBB that will load from and jump through the table.; // Note: We create it here, but it's not inserted into the function yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:61,Testability,test,tests,61,"// If target does not have legal shift left, do not emit bit tests at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:63,Testability,test,test,63,// FIXME: This might not be the best algorithm for finding bit test clusters.; // Base case: There is only one way to partition Clusters[N-1].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:36,Safety,avoid,avoid,36,// Note: loop indexes are signed to avoid underflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:93,Energy Efficiency,efficient,efficient,93,"// Check nbr of destinations and cluster types.; // FIXME: This works, but doesn't seem very efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:51,Testability,test,test,51,"// Iterate over the partitions, replacing with bit-test clusters in-place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the case where all the case values fit in a word without having; // to subtract minValue. In this case, we can optimize away the subtraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:123,Performance,optimiz,optimize,123,"// Optimize the case where all the case values fit in a word without having; // to subtract minValue. In this case, we can optimize away the subtraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:10,Availability,Mask,Mask,10,"// Update Mask, Bits and ExtraProb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:3,Deployability,Update,Update,3,"// Update Mask, Bits and ExtraProb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:57,Availability,mask,mask,57,"// Sort by probability first, number of bits second, bit mask third.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:236,Energy Efficiency,efficient,efficient,236,"// Our binary search tree differs from a typical BST in that ours can have; // up to three values in each leaf. The pivot selection above doesn't take; // that into account, which means the tree might require more nodes and be; // less efficient. We compensate for this here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:60,Availability,avail,available,60,"// If the original definition is still around, add it as an available; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:24,Availability,avail,available,24,// Add the new vregs as available values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite uses that are outside of the original def's block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite debug uses last so that they can take advantage of any; // register mappings introduced by other users in its BB, since we; // cannot create new register definitions specifically for the debug; // instruction (as debug instructions should not affect CodeGen).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:63,Deployability,update,update,63,/// Add a definition and source virtual registers pair for SSA update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:135,Deployability,update,update,135,/// Process PHI node in TailBB by turning it into a copy in PredBB. Remember the; /// source register that's contributed by PredBB and update SSA update map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:146,Deployability,update,update,146,/// Process PHI node in TailBB by turning it into a copy in PredBB. Remember the; /// source register that's contributed by PredBB and update SSA update map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:82,Availability,avail,available,82,// Insert a copy from source to the end of the block. The def register is the; // available value liveout of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:49,Deployability,update,update,49,/// Duplicate a TailBB instruction to PredBB and update; /// the source operands due to earlier PHI translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:56,Usability,simpl,simply,56,"// For mapped registers that do not have sub-registers, simply; // restrict their class to match the original one.; // We don't want debug instructions affecting the resulting code so; // if we're cloning a debug instruction then just use MappedRC; // rather than constraining the register class further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:47,Usability,simpl,simply,47,"// If the class constraining succeeded, we can simply replace; // the old register with the mapped one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Usability,Clear,Clear,3,"// Clear any kill flags from this operand. The new register could; // have uses after this one, so kills are not valid here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:115,Deployability,Update,Update,115,"/// After FromBB is tail duplicated into its predecessor blocks, the successors; /// have gained new predecessors. Update the PHI instructions in them; /// accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:94,Safety,avoid,avoid,94,"// If Idx is set, the operands at Idx and Idx+1 must be removed.; // We reuse the location to avoid expensive removeOperand calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:163,Safety,avoid,avoid,163,"// If we didn't duplicate a bb into a particular predecessor, we; // might still have added an entry to SSAUpdateVals to correcly; // recompute SSA. If that case, avoid adding a dummy extra argument; // this PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:48,Performance,optimiz,optimizing,48,"// Set the limit on the cost to duplicate. When optimizing for size,; // duplicate only one, because one branch instruction can be eliminated to; // compensate for the duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:279,Performance,optimiz,optimizations,279,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:37,Safety,predict,prediction,37,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:124,Safety,predict,predictable,124,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:233,Usability,undo,undoing,233,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:90,Integrability,depend,dependencies,90,"// Convergent instructions can be duplicated only if doing so doesn't add; // new control dependencies, which is what we're going to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicating calls before register allocation. Calls presents a; // barrier to register allocation so duplicating them may end up increasing; // spills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:479,Safety,abort,abort,479,"// Check if any of the successors of TailBB has a PHI node in which the; // value corresponding to TailBB uses a subregister.; // If a phi node uses a register paired with a subregister, the actual; // ""value type"" of the phi may differ from the type of the register without; // any subregisters. Due to a bug, tail duplication may add a new operand; // without a necessary subregister, producing an invalid code. This is; // demonstrated by test/CodeGen/Hexagon/tail-dup-subreg-abort.ll.; // Disable tail duplication for this case for now, until the problem is; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:442,Testability,test,test,442,"// Check if any of the successors of TailBB has a PHI node in which the; // value corresponding to TailBB uses a subregister.; // If a phi node uses a register paired with a subregister, the actual; // ""value type"" of the phi may differ from the type of the register without; // any subregisters. Due to a bug, tail duplication may add a new operand; // without a necessary subregister, producing an invalid code. This is; // demonstrated by test/CodeGen/Hexagon/tail-dup-subreg-abort.ll.; // Disable tail duplication for this case for now, until the problem is; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding fall through branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:487,Availability,redundant,redundant,487,"/// If it is profitable, duplicate TailBB's contents in each; /// of its predecessors.; /// \p IsSimple result of isSimpleBB; /// \p TailBB Block to be duplicated.; /// \p ForcedLayoutPred When non-null, use this block as the layout predecessor; /// instead of the previous block in MF's order.; /// \p TDBBs A vector to keep track of all blocks tail-duplicated; /// into.; /// \p Copies A vector of copy instructions inserted. Used later to; /// walk all the inserted copies and remove redundant ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:487,Safety,redund,redundant,487,"/// If it is profitable, duplicate TailBB's contents in each; /// of its predecessors.; /// \p IsSimple result of isSimpleBB; /// \p TailBB Block to be duplicated.; /// \p ForcedLayoutPred When non-null, use this block as the layout predecessor; /// instead of the previous block in MF's order.; /// \p TDBBs A vector to keep track of all blocks tail-duplicated; /// into.; /// \p Copies A vector of copy instructions inserted. Used later to; /// walk all the inserted copies and remove redundant ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:145,Safety,avoid,avoids,145,"// Iterate through all the unique predecessors and tail-duplicate this; // block into them, if possible. Copying the list ahead of time also; // avoids trouble with the predecessor list reallocating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:89,Availability,avail,available,89,"// Don't duplicate into a fall-through predecessor (at least for now).; // If profile is available, findDuplicateCandidates can choose better; // fall-through predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:60,Deployability,update,update,60,"// Replace def of virtual registers with new registers, and update; // uses with PHI source register or the new registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:39,Deployability,Update,Update,39,// subtract one for removed branch; // Update the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update branches in pred to jump to tail's layout successor if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:41,Safety,abort,abort,41,"// If there are still tail instructions, abort the merge",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:60,Deployability,update,update,60,"// Replace def of virtual registers with new registers, and update; // uses with PHI source register or the new registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update branches in PrevBB based on Tail's layout successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:40,Safety,safe,safe,40,"// If we made no changes so far, we are safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp:60,Integrability,interface,interface,60,"//===- TargetFrameLoweringImpl.cpp - Implement target frame interface ------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements the layout of a stack frame on the target machine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp:26,Performance,optimiz,optimized,26,// Function should not be optimized as tail call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:335,Modifiability,Variab,Variable-length,335,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:699,Testability,log,logical,699,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:862,Testability,test,testing,862,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:680,Usability,simpl,simple--i,680,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Deployability,Update,Update,3,// Update call site info and remove all the dead instructions; // from the end of MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid calling isRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:60,Testability,assert,assert,60,// Avoid calling isRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:89,Deployability,update,updated,89,"// If destination is tied to either of the commuted source register, then; // it must be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid calling setIsRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:63,Testability,assert,assert,63,// Avoid calling setIsRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:7,Deployability,Patch,PatchPoint,7,"// For PatchPoint, the call args are not foldable (even if reported in the; // stackmap e.g. via anyregcc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:64,Deployability,patch,patchpoint,64,// getPatchpointUnfoldableRange throws guarantee if MI is not a patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Deployability,Update,Update,3,"// Update mayload/maystore metadata, and memoperands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:26,Performance,load,load,26,"// If we're not folding a load into a subreg, the size of the load is the; // size of the spill slot. But if we are, we need to figure out what the; // actual load size is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:62,Performance,load,load,62,"// If we're not folding a load into a subreg, the size of the load is the; // size of the spill slot. But if we are, we need to figure out what the; // actual load size is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:159,Performance,load,load,159,"// If we're not folding a load into a subreg, the size of the load is the; // size of the spill slot. But if we are, we need to figure out what the; // actual load size is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:17,Deployability,patch,patchpoint,17,// Fold stackmap/patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:29,Performance,load,load,29,"// The pass ""x86 speculative load hardening"" always attaches symbols to; // call instructions. We need copy it form old instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:29,Performance,load,load,29,// Straight COPY may fold as load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:17,Deployability,patch,patchpoint,17,// Fold stackmap/patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:33,Performance,load,load,33,// Copy the memoperands from the load to the folded instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:44,Performance,load,loads,44,// Handle the rare case of folding multiple loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:348,Deployability,pipeline,pipeline,348,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:253,Integrability,depend,dependency,253,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:369,Integrability,depend,depending,369,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:656,Performance,optimiz,optimization,656,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:54,Performance,throughput,throughput,54,/// Return true when a code sequence can improve loop throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:48,Energy Efficiency,reduce,reduce,48,/// Attempt the reassociation transformation to reduce critical path length.; /// See the above comments before getMachineCombinerPatterns().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:62,Usability,clear,clear,62,// Propagate FP flags from the original instructions.; // But clear poison-generating flags because those may not be valid now.; // TODO: There should be a helper function for copying only fast-math-flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:237,Safety,safe,safely,237,// A sub-register definition can only be rematerialized if the instruction; // doesn't read the other parts of the register. Otherwise it is really a; // read-modify-write operation on the full virtual register which cannot be; // moved safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:73,Availability,redundant,redundant,73,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:5,Performance,load,load,5,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:73,Safety,redund,redundant,73,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:140,Usability,simpl,simple,140,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid instructions obviously unsafe for remat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:32,Safety,unsafe,unsafe,32,// Avoid instructions obviously unsafe for remat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:28,Performance,load,load,28,// Avoid instructions which load from potentially varying memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid instructions which load from potentially varying memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:27,Security,access,accessed,27,"// If any of the registers accessed are non-constant, conservatively assume; // the instruction is not rematerializable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:85,Energy Efficiency,schedul,scheduling,85,/// isSchedulingBoundary - Test if the given instruction should be; /// considered a scheduling boundary. This primarily includes labels; /// and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:27,Testability,Test,Test,27,/// isSchedulingBoundary - Test if the given instruction should be; /// considered a scheduling boundary. This primarily includes labels; /// and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:35,Energy Efficiency,schedul,scheduled,35,// Terminators and labels can't be scheduled around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:20,Energy Efficiency,schedul,schedule,20,"// Don't attempt to schedule around any instruction that defines; // a stack-oriented pointer, as it's unlikely to be profitable. This; // saves compile time, because it doesn't require every single; // stack slot reference to depend on the instruction that does the; // modification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:227,Integrability,depend,depend,227,"// Don't attempt to schedule around any instruction that defines; // a stack-oriented pointer, as it's unlikely to be profitable. This; // saves compile time, because it doesn't require every single; // stack slot reference to depend on the instruction that does the; // modification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:49,Safety,hazard,hazard,49,// Provide a global flag for disabling the PreRA hazard recognizer that targets; // may choose to honor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:9,Safety,hazard,hazard,9,// Dummy hazard recognizer allows all instructions to issue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:106,Integrability,interface,interface,106,//===----------------------------------------------------------------------===//; // SelectionDAG latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:98,Performance,latency,latency,98,//===----------------------------------------------------------------------===//; // SelectionDAG latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:106,Integrability,interface,interface,106,//===----------------------------------------------------------------------===//; // MachineInstr latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:98,Performance,latency,latency,98,//===----------------------------------------------------------------------===//; // MachineInstr latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:32,Performance,latency,latency,32,/// Return the default expected latency for a def based on it's opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:6,Usability,simpl,simplify,6,"// To simplify the sub-register handling, verify that we only need to; // consider physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:10,Performance,Scalab,Scalable,10,// FIXME: Scalable offsets are not yet handled in the offset code below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:26,Safety,safe,safely,26,// Labels generally can't safely be outlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:692,Availability,down,down,692,"// Make sure none of the operands of this instruction do anything that; // might break if they're moved outside their current function.; // This includes MachineBasicBlock references, BlockAddressses,; // Constant pool indices and jump table indices.; //; // A quick note on MO_TargetIndex:; // This doesn't seem to be used in any of the architectures that the; // MachineOutliner supports, but it was still filtered out in all of them.; // There was one exception (RISC-V), but MO_TargetIndex also isn't used there.; // As such, this check is removed both here and in the target-specific; // implementations. Instead, we assert to make sure this doesn't; // catch anyone off-guard somewhere down the line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:622,Testability,assert,assert,622,"// Make sure none of the operands of this instruction do anything that; // might break if they're moved outside their current function.; // This includes MachineBasicBlock references, BlockAddressses,; // Constant pool indices and jump table indices.; //; // A quick note on MO_TargetIndex:; // This doesn't seem to be used in any of the architectures that the; // MachineOutliner supports, but it was still filtered out in all of them.; // There was one exception (RISC-V), but MO_TargetIndex also isn't used there.; // As such, this check is removed both here and in the target-specific; // implementations. Instead, we assert to make sure this doesn't; // catch anyone off-guard somewhere down the line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:19,Testability,assert,assertion,19,"// If you hit this assertion, please remove it and adjust; // `getOutliningTypeImpl` for your target appropriately if necessary.; // Adding the assertion back to other supported architectures; // would be nice too :)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:144,Testability,assert,assertion,144,"// If you hit this assertion, please remove it and adjust; // `getOutliningTypeImpl` for your target appropriately if necessary.; // Adding the assertion back to other supported architectures; // would be nice too :)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:33,Testability,test,test,33,"// FIXME: This option is only to test if the strict fp operation processed; // correctly by preventing mutating strict fp operation to normal fp operation; // during development. When the backend supports strict float operation, this; // option will be meaningless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,Performance,optimiz,optimized,24,// Some darwins have an optimized __bzero/bzero function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Performance,Perform,Perform,3,// Perform these initializations only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:23,Performance,load,load,23,// Default all indexed load / store to expand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:69,Performance,load,loaded,69,// Most backends expect to see the node which just returns the value loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:155,Performance,optimiz,optimize,155,"// ConstantFP nodes default to expand. Targets can either change this to; // Legal, in which case all fp constants are legal, or use isFPImmLegal(); // to optimize expansions for certain constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:52,Safety,abort,abort,52,// Default ISD::TRAP to expand (which turns it into abort).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:86,Safety,safe,safe,86,"// If any possible shift value won't fit in the prefered type, just use; // something safe. Assume it will be legalized when the shift is expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:16,Usability,simpl,simple,16,"// If this is a simple type, use the ComputeRegisterProp mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:10,Modifiability,Extend,Extended,10,// Handle Extended Scalar Types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:22,Energy Efficiency,power,power-of-two,22,"// First promote to a power-of-two size, then expand if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Safety,Avoid,Avoid,3,// Avoid multi-step promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:60,Energy Efficiency,power,power,60,"// Try to widen vector elements until the element type is a power of two and; // promote it to a legal type later on, for example:; // <3 x i8> -> <4 x i8> -> <4 x i32>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:51,Energy Efficiency,power,power,51,"// Vectors with a number of elements that is not a power of two are always; // widened, for example <3 x i8> -> <4 x i8>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:34,Usability,simpl,simple,34,// Stop trying when getting a non-simple element type.; // Note that vector elements may be greater than legal vector element; // types. Example: X86 XMM registers hold 64bit element on 32bit; // systems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,Energy Efficiency,power,power,24,// Round up to the next power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:18,Usability,simpl,simple,18,// If there is no simple vector type with this many elements then there; // cannot be a larger legal vector type. Note that this assumes that; // there are no skipped intermediate vector types in the simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:200,Usability,simpl,simple,200,// If there is no simple vector type with this many elements then there; // cannot be a larger legal vector type. Note that this assumes that; // there are no skipped intermediate vector types in the simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:29,Energy Efficiency,power,power,29,// Widen odd vectors to next power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so splitting or widening is; // required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:92,Availability,down,down,92,// FIXME: We don't support non-power-of-2-sized vectors for now.; // Ideally we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:31,Energy Efficiency,power,power-of-,31,// FIXME: We don't support non-power-of-2-sized vectors for now.; // Ideally we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:26,Performance,scalab,scalable,26,// Split EC to unit size (scalable property is preserved).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:122,Performance,scalab,scalable,122,// Divide the input until we get to a supported size. This will; // always end up with an EC that represent a scalar or a scalable; // scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:63,Integrability,depend,dependent,63,/// Replace/modify any TargetFrameIndex operands with a targte-dependent; /// sequence of memory operands that is recognized by PrologEpilogInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:55,Deployability,PATCH,PATCHPOINT,55,"// We're handling multiple types of operands here:; // PATCHPOINT MetaArgs - live-in, read only, direct; // STATEPOINT Deopt Spill - live-through, read only, indirect; // STATEPOINT Deopt Alloca - live-through, read only, direct; // (We're currently conservative and mark the deopt slots read/write in; // practice.); // STATEPOINT GC Spill - live-through, read/write, indirect; // STATEPOINT GC Alloca - live-through, read/write, direct; // The live-in vs live-through is handled already (the live through ones are; // all stack slots), but we need to handle the different type of stackmap; // operands and memory effects here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit previous memory operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:130,Deployability,patch,patchpoints,130,"// indirect-mem-ref tag, size, #FI, offset.; // Used for spills inserted by StatepointLowering. This codepath is not; // used for patchpoints/stackmaps at all, for these spilling is done via; // foldMemoryOperand callback only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:48,Deployability,patch,patchpoint,48,"// direct-mem-ref tag, #FI, offset.; // Used by patchpoint, and direct alloca arguments to statepoints",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:74,Deployability,PATCH,PATCHPOINT,74,"// Note: STATEPOINT MMOs are added during SelectionDAG. STACKMAP, and; // PATCHPOINT should be updated to do the same. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:95,Deployability,update,updated,95,"// Note: STATEPOINT MMOs are added during SelectionDAG. STACKMAP, and; // PATCHPOINT should be updated to do the same. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:129,Security,expose,expose,129,"/// computeRegisterProperties - Once all of the register classes are added,; /// this allows us to compute derived properties we expose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:26,Energy Efficiency,power,power,26,// Only widen to the next power of 2 to keep consistency with EVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:21,Energy Efficiency,power,power,21,// Type is already a power of 2. The default action is to split.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:53,Availability,down,down,53,"/// getVectorTypeBreakdown - Vector types are broken down into some number of; /// legal first class types. For example, MVT::v8f32 maps to 2 MVT::v4f32; /// with Altivec or SSE1, or 8 promoted MVT::f64 values with the X86 FP stack.; /// Similarly, MVT::v2i64 turns into 4 MVT::i32 values with both PPC and X86.; ///; /// This method returns the number of registers needed, and the VT for each; /// register. It also returns the VT and quantity of the intermediate values; /// before they are promoted/expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so handle the legalisation of the; // types like done elsewhere in SelectionDAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:92,Availability,down,down,92,// FIXME: We don't support non-power-of-2-sized vectors for now. Ideally; // we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:31,Energy Efficiency,power,power-of-,31,// FIXME: We don't support non-power-of-2-sized vectors for now. Ideally; // we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:228,Performance,perform,performed,228,"// FIXME: This function check the maximum table size and density, but the; // minimum size is not checked. It would be nice if the minimum size is; // also combined within this function. Currently, the minimum size check is; // performed in findJumpTable() in SelectionDAGBuiler and; // getEstimatedNumberOfCaseClusters() in BasicTTIImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:174,Testability,log,logarithm,174,"/// getByValTypeAlignment - Return the desired alignment for ByVal aggregate; /// function arguments in the caller parameter area. This is the actual; /// alignment, not its logarithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:18,Security,access,access,18,// Assume that an access that meets the ABI-specified alignment is fast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,Security,access,access,24,// This is a misaligned access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:26,Modifiability,variab,variable,26,// compiler-rt provides a variable with a magic name. Targets that do not; // link with compiler-rt may also provide such a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:124,Modifiability,variab,variable,124,// compiler-rt provides a variable with a magic name. Targets that do not; // link with compiler-rt may also provide such a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:14,Modifiability,variab,variable,14,"// The global variable is not defined yet, define it ourselves.; // We use the initial-exec TLS model because we do not support the; // variable living anywhere other than in the main executable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:136,Modifiability,variab,variable,136,"// The global variable is not defined yet, define it ourselves.; // We use the initial-exec TLS model because we do not support the; // variable living anywhere other than in the main executable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:7,Modifiability,variab,variable,7,"// The variable exists, check its type and attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:88,Safety,unsafe,unsafe,88,// Android provides a libc function to retrieve the address of the current; // thread's unsafe stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:316,Performance,load,load,316,"//===----------------------------------------------------------------------===//; // Loop Strength Reduction hooks; //===----------------------------------------------------------------------===//; /// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:116,Modifiability,extend,extended,116,"// The default implementation of this implements a conservative RISCy, r+r and; // r+i addr mode.; // Allows a sign-extended 16-bit immediate field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:224,Modifiability,variab,variable,224,"//===----------------------------------------------------------------------===//; // Stack Protector; //===----------------------------------------------------------------------===//; // For OpenBSD return its special guard variable. Otherwise return nullptr,; // so that SelectionDAG handle SSP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:65,Safety,avoid,avoid,65,"// Single-element vectors are scalarized, so we should generally avoid having; // any memory operations on such types, as they would get scalarized too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:38,Performance,load,load,38,"// Don't do if we could do an indexed load on the original type, but not on; // the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:267,Safety,avoid,avoid,267,"// The small model guarantees static code/data size < 4GB, but not where it; // will be in memory. Most of these could end up >2GB away so even a signed; // pc-relative 32-bit address is insufficient, theoretically.; //; // Use DW_EH_PE_indirect even for -fno-pic to avoid copy relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:77,Availability,avail,available,77,// Emit a descriptor for every function including functions that have an; // available external linkage. We may not want this for imported functions; // that has code in another thinLTO module but we don't have a good way to; // tell them apart from inline functions defined in header files. Therefore; // we put each descriptor in a separate comdat section and rely on the; // linker to deduplicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:66,Testability,stub,stub,66,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:98,Modifiability,variab,variable,98,"// Use SHT_NOTE for section whose name starts with "".note"" to allow; // emitting ELF notes from C variable declaration.; // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=77609",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:58,Deployability,update,update,58,"/// Calculate an appropriate unique ID for a section, and update Flags,; /// EntrySize and NextUniqueID where appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:137,Safety,avoid,avoid,137,"// If two symbols with differing sizes end up in the same mergeable section; // that section can be assigned an incorrect entry size. To avoid this we; // usually put symbols of the same size into distinct mergeable sections with; // the same name. Doing so relies on the "",unique ,"" assembly feature. This; // feature is not avalible until bintuils version 2.35; // (https://sourceware.org/bugzilla/show_bug.cgi?id=25380).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:129,Availability,error,error,129,"// If we are using GNU as before 2.35, then this symbol might have; // been placed in an incompatible mergeable section. Emit an error if this; // is the case to avoid creating broken output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:162,Safety,avoid,avoid,162,"// If we are using GNU as before 2.35, then this symbol might have; // been placed in an incompatible mergeable section. Emit an error if this; // is the case to avoid creating broken output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:26,Availability,error,error,26,"// If invalid, report the error with report_fatal_error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:26,Availability,error,error,26,"// If invalid, report the error with report_fatal_error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:60,Testability,Stub,StubSize,60,"// Okay, now that we got the section, verify that the TAA & StubSize agree.; // If the user declared multiple globals with different section flags, we need; // to reject it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:26,Availability,error,error,26,"// If invalid, report the error with report_fatal_error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:91,Integrability,depend,depending,91,"// If this is weak/linkonce, put this in a coalescable section, either in text; // or data depending on if it is writable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:19,Modifiability,variab,variables,19,"// With MachO only variables whose corresponding symbol starts with 'l' or; // 'L' can be merged, so we only try merging GVs with private linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:68,Performance,optimiz,optimize,68,"// Otherwise, if it is readonly, but not something we can specially optimize,; // just drop it in .const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:28,Modifiability,variab,variable,28,"// Otherwise, just drop the variable in the normal data section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Testability,stub,stub,61,// The mach-o version of this method defaults to returning a stub reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:68,Testability,stub,stub,68,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Testability,stub,stub,61,// The mach-o version of this method defaults to returning a stub reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:68,Testability,stub,stub,68,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:129,Security,access,accessing,129,"// Although MachO 32-bit targets do not explicitly have a GOTPCREL relocation; // as 64-bit do, we replace the GOT equivalent by accessing the final symbol; // through a non_lazy_ptr stub instead. One advantage is that it allows the; // computation of deltas to final external symbols. Example:; //; // _extgotequiv:; // .long _extfoo; //; // _delta:; // .long _extgotequiv-_delta; //; // is transformed to:; //; // _delta:; // .long L_extfoo$non_lazy_ptr-(_delta+0); //; // .section __IMPORT,__pointers,non_lazy_symbol_pointers; // L_extfoo$non_lazy_ptr:; // .indirect_symbol _extfoo; // .long 0; //; // The indirect symbol table (and sections of non_lazy_symbol_pointers type); // may point to both local (same translation unit) and global (other; // translation units) symbols. Example:; //; // .section __DATA,__pointers,non_lazy_symbol_pointers; // L1:; // .indirect_symbol _myGlobal; // .long 0; // L2:; // .indirect_symbol _myLocal; // .long _myLocal; //; // If the symbol is local, instead of the symbol's index, the assembler; // places the constant INDIRECT_SYMBOL_LOCAL into the indirect symbol table.; // Then the linker will notice the constant in the table and will look at the; // content of the symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:183,Testability,stub,stub,183,"// Although MachO 32-bit targets do not explicitly have a GOTPCREL relocation; // as 64-bit do, we replace the GOT equivalent by accessing the final symbol; // through a non_lazy_ptr stub instead. One advantage is that it allows the; // computation of deltas to final external symbols. Example:; //; // _extgotequiv:; // .long _extfoo; //; // _delta:; // .long _extgotequiv-_delta; //; // is transformed to:; //; // _delta:; // .long L_extfoo$non_lazy_ptr-(_delta+0); //; // .section __IMPORT,__pointers,non_lazy_symbol_pointers; // L_extfoo$non_lazy_ptr:; // .indirect_symbol _extfoo; // .long 0; //; // The indirect symbol table (and sections of non_lazy_symbol_pointers type); // may point to both local (same translation unit) and global (other; // translation units) symbols. Example:; //; // .section __DATA,__pointers,non_lazy_symbol_pointers; // L1:; // .indirect_symbol _myGlobal; // .long 0; // L2:; // .indirect_symbol _myLocal; // .long _myLocal; //; // If the symbol is local, instead of the symbol's index, the assembler; // places the constant INDIRECT_SYMBOL_LOCAL into the indirect symbol table.; // Then the linker will notice the constant in the table and will look at the; // content of the symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:3,Security,Access,Access,3,// Access the final symbol via sym$non_lazy_ptr and generate the appropriated; // non_lazy_ptr stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:95,Testability,stub,stubs,95,// Access the final symbol via sym$non_lazy_ptr and generate the appropriated; // non_lazy_ptr stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:228,Safety,safe,safety,228,"// FIXME: we should be able to use private labels for sections that can't be; // dead-stripped (there's no issue with blocking atomization there), but `ld; // -r` sometimes drops the no_dead_strip attribute from sections so for safety; // we don't allow it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:110,Availability,error,error,110,"// Global symbols with internal or private linkage are not visible to; // the linker, and thus would cause an error when the linker tried to; // preserve the symbol due to the `/include:` directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:438,Integrability,contract,contract,438,"// Otherwise, we need to compute a new section name. Low priorities should; // run earlier. The linker will sort sections ASCII-betically, and we need a; // string that sorts between .CRT$XCA and .CRT$XCU. In the general case, we; // make a name like "".CRT$XCT12345"", since that runs before .CRT$XCU. Really; // low priorities need to sort before 'L', since the CRT uses that; // internally, so we use "".CRT$XCA00001"" for them. We have a contract with; // the frontend that ""init_seg(compiler)"" corresponds to priority 200 and; // ""init_seg(lib)"" corresponds to priority 400, and those respectively use; // 'C' and 'L' without the priority suffix. Priorities between 200 and 400; // use 'C' with the priority as a suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:35,Integrability,wrap,wrap,35,"// Both ptrtoint instructions must wrap global objects:; // - Only global variables are eligible for image relative relocations.; // - The subtrahend refers to the special symbol __ImageBase, a GlobalVariable.; // We expect __ImageBase to be a global variable without a section, externally; // defined.; //; // It should look something like this: @__ImageBase = external constant i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:74,Modifiability,variab,variables,74,"// Both ptrtoint instructions must wrap global objects:; // - Only global variables are eligible for image relative relocations.; // - The subtrahend refers to the special symbol __ImageBase, a GlobalVariable.; // We expect __ImageBase to be a global variable without a section, externally; // defined.; //; // It should look something like this: @__ImageBase = external constant i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:251,Modifiability,variab,variable,251,"// Both ptrtoint instructions must wrap global objects:; // - Only global variables are eligible for image relative relocations.; // - The subtrahend refers to the special symbol __ImageBase, a GlobalVariable.; // We expect __ImageBase to be a global variable without a section, externally; // defined.; //; // It should look something like this: @__ImageBase = external constant i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:221,Availability,error,error,221,"// This creates comdat sections with the given symbol name, but unless; // AsmPrinter::GetCPISymbol actually makes the symbol global, the symbol; // will be created with a null storage class, which makes GNU binutils; // error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:127,Safety,avoid,avoided,127,// Certain data sections we treat as named custom sections rather than; // segments within the data section.; // This could be avoided if all data segements (the wasm sense) were; // represented as their own sections (in the llvm sense).; // TODO(sbc): https://github.com/WebAssembly/tool-conventions/issues/138,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:143,Modifiability,variab,variables,143,// We don't use PersonalityEncoding and LSDAEncoding because we don't emit; // .cfi directives. We use TTypeEncoding to encode typeinfo global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:28,Deployability,canary,canary,28,// FIXME: check presence of canary word; // There are cases that the stack protectors are not really inserted even if; // the attributes are on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:256,Safety,avoid,avoided,256,"// We always use a qualname symbol for a GV that represents; // a declaration, a function descriptor, or a common symbol.; // If a GV represents a GlobalVariable and -fdata-sections is enabled, we; // also return a qualname so that a label symbol could be avoided.; // It is inherently ambiguous when the GO represents the address of a; // function, as the GO could either represent a function descriptor or a; // function entry point. We choose to always return a function descriptor; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:161,Availability,error,error,161,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Deployability,integrat,integrated,61,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Integrability,integrat,integrated,61,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:130,Modifiability,variab,variable,130,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:234,Modifiability,variab,variables,234,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:223,Energy Efficiency,allocate,allocated,223,"// Use TE storage-mapping class when large code model is enabled so that; // the chance of needing -bbigtoc is decreased. Also, the toc-entry for; // EH info is never referenced directly using instructions so it can be; // allocated with TE storage-mapping class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp:82,Performance,optimiz,optimization,82,/// DisableFramePointerElim - This returns true if frame pointer elimination; /// optimization should be disabled for the given machine function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp:343,Testability,test,testing,343,"/// NOTE: There are targets that still do not support the debug entry values; /// production and that is being controlled with the SupportsDebugEntryValues.; /// In addition, SCE debugger does not have the feature implemented, so prefer; /// not to emit the debug entry values in that case.; /// The EnableDebugEntryValues can be used for the testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:401,Integrability,interface,interfaces,401,"//===- TargetPassConfig.cpp - Target independent code generation passes ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:415,Security,access,access,415,"//===- TargetPassConfig.cpp - Target independent code generation passes ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:87,Deployability,pipeline,pipeline,87,"// Disable the pass to fix unwind information. Whether the pass is included in; // the pipeline is controlled via the target options, this option serves as; // manual override.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:82,Energy Efficiency,schedul,scheduler,82,"// Temporary option to allow experimenting with MachineScheduler as a post-RA; // scheduler. Targets can ""properly"" enable this with; // substitutePass(&PostRASchedulerID, &PostMachineSchedulerID).; // Targets can return true in targetSchedulesPostRAScheduling() and; // insert a PostRA scheduling pass wherever it wants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:287,Energy Efficiency,schedul,scheduling,287,"// Temporary option to allow experimenting with MachineScheduler as a post-RA; // scheduler. Targets can ""properly"" enable this with; // substitutePass(&PostRASchedulerID, &PostMachineSchedulerID).; // Targets can return true in targetSchedulesPostRAScheduling() and; // insert a PostRA scheduling pass wherever it wants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:75,Availability,error,error,75,/// Option names for limiting the codegen pipeline.; /// Those are used in error reporting and we didn't want; /// to duplicate their names all over the place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:42,Deployability,pipeline,pipeline,42,/// Option names for limiting the codegen pipeline.; /// Those are used in error reporting and we didn't want; /// to duplicate their names all over the place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:43,Testability,test,testing,43,/// Disable the expand reductions pass for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:23,Performance,optimiz,optimization,23,/// Disable the select optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:85,Usability,simpl,simple,85,/// Allow standard passes to be disabled by command line options. This supports; /// simple binary flags that either suppress the pass or do nothing.; /// i.e. -disable-mypass=false has no effect.; /// These should be converted to boolOrDefault in order to use applyOverride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:170,Deployability,pipeline,pipeline,170,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:624,Deployability,pipeline,pipeline,624,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:593,Integrability,depend,depending,593,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:399,Modifiability,config,configured,399,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:188,Deployability,pipeline,pipeline,188,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:232,Deployability,pipeline,pipeline,232,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:317,Integrability,interface,interface,317,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:282,Modifiability,inherit,inherit,282,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:37,Deployability,configurat,configuration,37,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:117,Deployability,pipeline,pipeline,117,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:37,Modifiability,config,configuration,37,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:184,Modifiability,extend,extend,184,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:74,Availability,redundant,redundant,74,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:114,Availability,avail,available,114,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:102,Energy Efficiency,schedul,scheduled,102,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:3,Performance,Cache,Cache,3,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:74,Safety,redund,redundant,74,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:20,Integrability,message,message,20,// Construct banner message before PM->add() as that may delete the pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:44,Deployability,pipeline,pipeline,44,/// Add a CodeGen pass at this point in the pipeline after checking for target; /// and command line overrides.; ///; /// addPass cannot return a pointer to the pass instance because is internal the; /// PassManager and the instance we create here may already be freed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:22,Modifiability,config,configurable,22,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:47,Performance,perform,perform,47,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:115,Performance,optimiz,optimization,115,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:110,Performance,optimiz,optimizer,110,"// Before running any passes, run the verifier to determine if the input; // coming from the front-end and/or optimizer is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:80,Performance,load,loads,80,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:175,Performance,load,loads,175,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:96,Safety,avoid,avoid,96,"// For MachO, lower @llvm.global_dtors into @llvm.global_ctors with; // __cxa_atexit() calls to avoid emitting the deprecated __mod_term_func.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:45,Availability,mask,masked,45,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:213,Availability,mask,mask,213,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:169,Performance,load,loads,169,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:105,Testability,test,testing,105,// Expand reduction intrinsics into shuffle sequences if the target wants to.; // Allow disabling it for testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:27,Performance,perform,perform,27,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:16,Safety,safe,safe,16,// Add both the safe stack and the stack protection passes: each of them will; // only protect functions that have corresponding attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:37,Deployability,pipeline,pipeline,37,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:147,Energy Efficiency,schedul,schedule,147,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:10,Integrability,Inject,Injecting,10,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:378,Integrability,inject,injecting,378,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:10,Security,Inject,Injecting,10,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:378,Security,inject,injecting,378,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:562,Testability,test,testing,562,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:240,Usability,clear,clear,240,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:50,Safety,abort,abort,50,// Provide a fallback path when we do not want to abort on; // not-yet-supported input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:186,Deployability,configurat,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:258,Integrability,rout,routines,258,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:306,Integrability,rout,routine,306,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:415,Integrability,inject,injecting,415,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:627,Integrability,rout,routines,627,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:855,Integrability,depend,dependencies,855,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:1012,Integrability,inject,injection,1012,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:186,Modifiability,config,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:667,Modifiability,maintainab,maintainability,667,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:415,Security,inject,injecting,415,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:1012,Security,inject,injection,1012,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:19,Performance,optimiz,optimize,19,// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:166,Safety,safe,safe,166,// Debugifying the register allocator passes seems to provoke some; // non-determinism that affects CodeGen and there doesn't seem to be a point; // where it becomes safe again so stop debugifying here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:106,Energy Efficiency,schedul,scheduling,106,"// Run register allocation and passes that are tightly coupled with it,; // including phi elimination and scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:44,Energy Efficiency,schedul,scheduling,44,// Expand pseudo instructions before second scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:15,Energy Efficiency,schedul,scheduler,15,// Second pass scheduler.; // Let Target optionally insert this pass by itself at some other; // point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:61,Availability,mask,mask,61,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:108,Performance,optimiz,optimize,108,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:240,Deployability,Update,Update,240,"// Machine function splitter uses the basic block sections feature. Both; // cannot be enabled at the same time. Basic block sections takes precedence.; // FIXME: In principle, BasicBlockSection::Labels and splitting can used; // together. Update this check once we have addressed any issues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:87,Performance,perform,performance,87,"// Sample profile is given, but FSDiscriminator is not; // enabled, this may result in performance regression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:3,Performance,Optimiz,Optimize,3,// Optimize PHIs before DCE: removing dead PHI cycles may make more; // instructions dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:8,Performance,optimiz,optimization,8,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:250,Testability,test,test,250,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:110,Deployability,Configurat,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:110,Modifiability,Config,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:88,Performance,optimiz,optimized,88,/// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:253,Performance,optimiz,optimized,253,/// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:343,Performance,optimiz,optimized,343,/// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:296,Availability,avail,available,296,"/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.; ///; /// This helper ensures that the regalloc= option is always available,; /// even for targets that override the default allocator.; ///; /// FIXME: When MachinePassRegistry register pass IDs instead of function ptrs,; /// this can be folded into addPass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:99,Performance,optimiz,optimization,99,"/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.; ///; /// This helper ensures that the regalloc= option is always available,; /// even for targets that override the default allocator.; ///; /// FIXME: When MachinePassRegistry register pass IDs instead of function ptrs,; /// this can be folded into addPass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:11,Modifiability,rewrite,rewrite,11,// Finally rewrite virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:62,Usability,learn,learning,62,// Regalloc scoring for ML-driven eviction - noop except when learning a new; // eviction policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:118,Energy Efficiency,schedul,scheduling,118,/// Add the minimum set of target-independent passes that are required for; /// register allocation. No coalescing or scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:156,Energy Efficiency,schedul,scheduling,156,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:78,Performance,optimiz,optimized,78,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:324,Integrability,depend,depend,324,"// LiveVariables currently requires pure SSA form.; //; // FIXME: Once TwoAddressInstruction pass no longer uses kill flags,; // LiveVariables can be removed completely, and LiveIntervals can be directly; // computed. (We still either need to regenerate kill flags after regalloc, or; // preferably fix the scavenger to not depend on them).; // FIXME: UnreachableMachineBlockElim is a dependant pass of LiveVariables.; // When LiveVariables is removed this has to be removed/moved either.; // Explicit addition of UnreachableMachineBlockElim allows stopping before or; // after it with -stop-before/-stop-after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:385,Integrability,depend,dependant,385,"// LiveVariables currently requires pure SSA form.; //; // FIXME: Once TwoAddressInstruction pass no longer uses kill flags,; // LiveVariables can be removed completely, and LiveIntervals can be directly; // computed. (We still either need to regenerate kill flags after regalloc, or; // preferably fix the scavenger to not depend on them).; // FIXME: UnreachableMachineBlockElim is a dependant pass of LiveVariables.; // When LiveVariables is removed this has to be removed/moved either.; // Explicit addition of UnreachableMachineBlockElim allows stopping before or; // after it with -stop-before/-stop-after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:15,Energy Efficiency,schedul,scheduler,15,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:121,Safety,avoid,avoid,121,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:21,Energy Efficiency,schedul,scheduling,21,// PreRA instruction scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:3,Performance,Perform,Perform,3,// Perform stack slot coloring and post-ra machine LICM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:47,Integrability,depend,depending,47,// Allow targets to expand pseudo instructions depending on the choice of; // registers before MachineCopyPropagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:104,Deployability,Configurat,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:104,Modifiability,Config,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:220,Performance,optimiz,optimize,220,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:14,Availability,redundant,redundant,14,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:42,Performance,load,loads,42,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:14,Safety,redund,redundant,14,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:94,Performance,perform,performance,94,// Tail duplication.; // Note that duplicating tail just increases code size and degrades; // performance for targets that require Structured Control Flow.; // In addition it can also make CFG irreducible. Thus we disable it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:96,Deployability,Configurat,Configuration,96,//===---------------------------------------------------------------------===//; /// GlobalISel Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:96,Modifiability,Config,Configuration,96,//===---------------------------------------------------------------------===//; /// GlobalISel Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:427,Integrability,interface,interface,427,"//==- TargetRegisterInfo.cpp - Target Register Information Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TargetRegisterInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:77,Safety,avoid,avoid,77,// We transitively check superregs. So we can remember this for later; // to avoid compiletime explosion in deep register hierarchies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:29,Deployability,Toggle,Toggle,29,/// getAllocatableSetForRC - Toggle the bits that represent allocatable; /// registers for the specific register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:3,Availability,Mask,Mask,3,// Mask out the reserved registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:11,Availability,mask,mask,11,// The bit mask contains all register classes that are projected into B; // by Idx. Find a class that is also a sub-class of A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:65,Safety,avoid,avoid,65,"// At most one of the register is a sub register, make it Src to avoid; // duplicating the test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:91,Testability,test,test,91,"// At most one of the register is a sub register, make it Src to avoid; // duplicating the test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:86,Energy Efficiency,allocate,allocated,86,// Don't add the same reg twice (Hints_MRI may contain multiple virtual; // registers allocated to the same physreg).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:7,Usability,clear,clear,7,"// All clear, tell the register allocator to prefer this register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:28,Availability,avail,available,28,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:86,Security,access,access,86,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:3,Safety,Abort,Abort,3,// Abort if we cannot possibly implement the COPY with the given indexes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:41,Safety,avoid,avoid,41,// Do not cover already-covered lanes to avoid creating cycles; // in copy bundles (= bundle contains copies that write to the; // registers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:507,Availability,avail,available,507,"//===- llvm/Target/TargetSchedule.cpp - Sched Machine Model ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a wrapper around MCSchedModel that allows the interface; // to benefit from information currently only available in TargetInstrInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:406,Integrability,wrap,wrapper,406,"//===- llvm/Target/TargetSchedule.cpp - Sched Machine Model ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a wrapper around MCSchedModel that allows the interface; // to benefit from information currently only available in TargetInstrInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:450,Integrability,interface,interface,450,"//===- llvm/Target/TargetSchedule.cpp - Sched Machine Model ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a wrapper around MCSchedModel that allows the interface; // to benefit from information currently only available in TargetInstrInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:55,Performance,latency,latency,55,"// The machine model may explicitly specify an invalid latency, which; // effectively means infinite latency. Since users of the TargetSchedule API; // don't know how to handle this, we convert it to a very large latency that is; // easy to distinguish when debugging the DAG but won't induce overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:101,Performance,latency,latency,101,"// The machine model may explicitly specify an invalid latency, which; // effectively means infinite latency. Since users of the TargetSchedule API; // don't know how to handle this, we convert it to a very large latency that is; // easy to distinguish when debugging the DAG but won't induce overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:213,Performance,latency,latency,213,"// The machine model may explicitly specify an invalid latency, which; // effectively means infinite latency. Since users of the TargetSchedule API; // don't know how to handle this, we convert it to a very large latency that is; // easy to distinguish when debugging the DAG but won't induce overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:115,Integrability,depend,depend,115,/// Return the MCSchedClassDesc for this instruction. Some SchedClasses require; /// evaluation of predicates that depend on instruction operands or flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:24,Energy Efficiency,schedul,scheduling,24,// Get the definition's scheduling class descriptor from this machine model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:191,Usability,simpl,simply,191,"/// Find the use index of this operand. This is independent of the instruction's; /// def operands.; ///; /// Note that uses are not determined by the operand's isUse property, which; /// is simply the inverse of isDef. Here we consider any readsReg operand to be; /// a ""use"". The machine model allows an operand to be both a Def and Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:146,Performance,latency,latency,146,"// Top-level API for clients that know the operand indices. This doesn't need to; // return std::optional<unsigned>, as it always returns a valid latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:12,Performance,latency,latency,12,"// Expected latency is the max of InstrLatency and DefaultDefLatency, if we; // didn't find an operand latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:103,Performance,latency,latency,103,"// Expected latency is the max of InstrLatency and DefaultDefLatency, if we; // didn't find an operand latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:33,Performance,latency,latency,33,// Lookup the definition's write latency in SubtargetInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:20,Performance,latency,latency,20,// Lookup the use's latency adjustment in SubtargetInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:12,Integrability,wrap,wrap,12,// unsigned wrap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:84,Performance,latency,latency,84,"// If DefIdx does not exist in the model (e.g. implicit defs), then return; // unit latency (defaultDefLatency may be too conservative).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:202,Performance,latency,latency,202,// FIXME: Automatically giving all implicit defs defaultDefLatency is; // undesirable. We should only do it for defs that are known to the MC; // desc like flags. Truly implicit defs should get 1 cycle latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:43,Integrability,depend,dependencies,43,"// Out-of-order processor can dispatch WAW dependencies in the same cycle.; // Treat predication as a data dependency for out-of-order cpus. In-order; // cpus do not need to treat predicated writes specially.; //; // TODO: The following hack exists because predication passes do not; // correctly append imp-use operands, and readsReg() strangely returns false; // for predicated defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:107,Integrability,depend,dependency,107,"// Out-of-order processor can dispatch WAW dependencies in the same cycle.; // Treat predication as a data dependency for out-of-order cpus. In-order; // cpus do not need to treat predicated writes specially.; //; // TODO: The following hack exists because predication passes do not; // correctly append imp-use operands, and readsReg() strangely returns false; // for predicated defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:28,Energy Efficiency,schedul,scheduling,28,"// If we have a per operand scheduling model, check if this def is writing; // an unbuffered resource. If so, it treated like an in-order cpu.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Testability,Test,Test,4,"/// Test if the given register value, which is used by the; /// given instruction, is killed by the given instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:249,Availability,avail,available,249,"// FIXME: Sometimes tryInstructionTransform() will add instructions and; // test whether they can be folded before keeping them. In this case it; // sets a kill before recursively calling tryInstructionTransform() again.; // If there is no interval available, we assume that this instruction is; // one of those. A kill flag is manually inserted on the operand so the; // check below will handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:76,Testability,test,test,76,"// FIXME: Sometimes tryInstructionTransform() will add instructions and; // test whether they can be folded before keeping them. In this case it; // sets a kill before recursively calling tryInstructionTransform() again.; // If there is no interval available, we assume that this instruction is; // one of those. A kill flag is manually inserted on the operand so the; // check below will handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Testability,Test,Test,4,/// Test if the register used by the given operand is killed by the operand's; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Testability,Test,Test,4,"/// Test if the given register value, which is used by the given; /// instruction, is killed by the given instruction. This looks through; /// coalescable copies to see if the original value is potentially not killed.; ///; /// For example, in this code:; ///; /// %reg1034 = copy %reg1024; /// %reg1035 = copy killed %reg1025; /// %reg1036 = add killed %reg1034, killed %reg1035; ///; /// %reg1034 is not considered to be killed, since it is copied from a; /// register which is not killed. Treating it as not killed lets the; /// normal heuristics commute the (two-address) add, which lets; /// coalescing eliminate the extra copy.; ///; /// If allowFalsePositives is true then likely kills are treated as kills even; /// if it can't be proven that they are kills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:45,Usability,simpl,simple,45,"// If there are multiple defs, we can't do a simple analysis, so just; // go with what the kill flag says.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:687,Availability,avail,available,687,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:614,Deployability,integrat,integrated,614,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:614,Integrability,integrat,integrated,614,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:307,Modifiability,extend,extend,307,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:318,Testability,log,logic,318,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:565,Testability,log,logic,565,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:42,Deployability,update,update,42,"/// Commute a two-address instruction and update the basic block, distance map,; /// and live variables if needed. Return true if it is successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:94,Modifiability,variab,variables,94,"/// Commute a two-address instruction and update the basic block, distance map,; /// and live variables if needed. Return true if it is successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update source register map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:183,Safety,avoid,avoid,183,"// Look for situations like this:; // %reg1024 = MOV r1; // %reg1025 = MOV r0; // %reg1026 = ADD %reg1024, %reg1025; // r2 = MOV %reg1026; // Turn ADD into a 3-address instruction to avoid a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:53,Deployability,update,update,53,"// If the old instruction is debug value tracked, an update is required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update source and destination register maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:44,Deployability,update,update,44,"/// Scan forward recursively for only uses, update maps if the use is a copy or; /// a two-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:266,Performance,optimiz,optimizations,266,"/// If the specified instruction is not yet processed, process it if it's a; /// copy. For a copy instruction, we find the physical registers the; /// source and destination registers might be mapped to. These are kept in; /// point-to maps used to determine future optimizations. e.g.; /// v1024 = mov r0; /// v1025 = mov r1; /// v1026 = add v1024, v1025; /// r1 = mov r1026; /// If 'add' is a two-address instruction, v1024, v1026 are both potentially; /// coalesced to r0 (from the input side). v1025 is mapped to r1. v1026 is; /// potentially joined with r1 on the output side. It's worthwhile to commute; /// 'add' to eliminate a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:47,Availability,avail,available,47,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:88,Energy Efficiency,efficient,efficiently,88,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:33,Performance,load,load,33,// Must be created from unfolded load. Don't waste time trying this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:35,Availability,down,down,35,// Move the copies connected to MI down as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:42,Integrability,depend,dependencies,42,// Check if the reschedule will not break dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:29,Energy Efficiency,reduce,reduce,29,// FIXME: Arbitrary limit to reduce compile time cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:46,Deployability,update,update,46,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:17,Modifiability,extend,extend,17,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:12,Energy Efficiency,schedul,schedule,12,// We can't schedule across a use of the register in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:15,Modifiability,variab,variables,15,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:26,Energy Efficiency,schedul,scheduling,26,/// Return true if the re-scheduling will put the given instruction too close; /// to the defs of its register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:111,Integrability,depend,dependencies,111,/// Return true if the re-scheduling will put the given instruction too close; /// to the defs of its register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:47,Availability,avail,available,47,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:88,Energy Efficiency,efficient,efficiently,88,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:33,Performance,load,load,33,// Must be created from unfolded load. Don't waste time trying this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:29,Energy Efficiency,reduce,reduce,29,// FIXME: Arbitrary limit to reduce compile time cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:46,Deployability,update,update,46,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:17,Modifiability,extend,extend,17,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:12,Energy Efficiency,schedul,schedule,12,// We can't schedule across a use of the register in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:15,Modifiability,variab,variables,15,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:208,Modifiability,variab,variables,208,"// The call of findCommutedOpIndices below only checks if BaseOpIdx; // and OtherOpIdx are commutable, it does not really search for; // other commutable operands and does not change the values of passed; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:53,Deployability,update,update,53,"// There might be more than two commutable operands, update BaseOp and; // continue scanning.; // FIXME: This assumes that the new instruction's operands are in the; // same positions and were simply swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:193,Usability,simpl,simply,193,"// There might be more than two commutable operands, update BaseOp and; // continue scanning.; // FIXME: This assumes that the new instruction's operands are in the; // same positions and were simply swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:55,Energy Efficiency,reduce,reduced,55,// Resamples OpsNum in case the number of operands was reduced. This; // happens with X86.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:129,Modifiability,variab,variable,129,"// If the instruction is convertible to 3 Addr, instead; // of returning try 3 Addr transformation aggressively and; // use this variable to check later. Because it might be better.; // For example, we can just use `leal (%rsi,%rdi), %eax` and `ret`; // instead of the following code.; // addl %esi, %edi; // movl %edi, %eax; // ret",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:75,Energy Efficiency,schedul,schedule,75,"// If there is one more use of regB later in the same MBB, consider; // re-schedule this MI below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:70,Safety,avoid,avoid,70,"// If we commuted, regB may have changed so we should re-sample it to avoid; // confusing the three address conversion below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:75,Energy Efficiency,schedul,schedule,75,"// If there is one more use of regB later in the same MBB, consider; // re-schedule it before this MI if it's legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:239,Energy Efficiency,schedul,schedule,239,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:36,Performance,load,load,36,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:79,Performance,load,load,79,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:250,Performance,load,load,250,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:90,Safety,avoid,avoid,90,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:18,Performance,load,load,18,// Determine if a load can be unfolded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:14,Performance,load,load,14,// Unfold the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:7,Performance,load,load,7,"// The load was previously folded, so this is the only use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:107,Testability,log,logic,107,"// Tentatively insert the instructions into the block so that they; // look ""normal"" to the transformation logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:58,Performance,load,load,58,"// Transform the instruction, now that it no longer has a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:60,Modifiability,Rewrite,Rewrite,60,"// Collect tied operands of MI that need to be handled.; // Rewrite trivial cases immediately.; // Return true if any tied operands where found, including the trivial ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:45,Modifiability,rewrite,rewrite,45,// Deal with undef uses immediately - simply rewrite the src operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:38,Usability,simpl,simply,38,// Deal with undef uses immediately - simply rewrite the src operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update DistanceMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:24,Testability,assert,asserts,24,"// The getMatchingSuper asserts guarantee that the register class projected; // by SubRegB is compatible with RegA with no subregister. So regardless of; // whether the dest oper writes a subreg, the source oper should not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update live variables for regB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:15,Modifiability,variab,variables,15,// Update live variables for regB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:258,Availability,failure,failures,258,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:165,Safety,Safe,SafepointIRVerifier,165,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:242,Safety,avoid,avoid,242,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:248,Testability,assert,assertion,248,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce two-address instructions to two operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:11,Performance,optimiz,optimizations,11,// Disable optimizations if requested. We cannot skip the whole pass as some; // fixups are necessary for correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:18,Modifiability,rewrite,rewrite,18,// This pass will rewrite the tied-def to meet the RegConstraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:61,Availability,down,down,61,// The tied operands have been eliminated or shifted further down; // the block to ease elimination. Continue processing with 'nmi'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite INSERT_SUBREG as COPY now that we no longer need SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Usability,Clear,Clear,3,// Clear TiedOperands here instead of at the top of the loop; // since most instructions do not have tied operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveVariables' kill info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:677,Integrability,wrap,wrapping,677,"//===----- TypePromotion.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is an opcode based type promotion pass for small types that would; /// otherwise be promoted during legalisation. This works around the limitations; /// of selection dag for cyclic regions. The search begins from icmp; /// instructions operands where a tree, consisting of non-wrapping or safe; /// wrapping instructions, is built, checked and promoted if possible.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:699,Integrability,wrap,wrapping,699,"//===----- TypePromotion.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is an opcode based type promotion pass for small types that would; /// otherwise be promoted during legalisation. This works around the limitations; /// of selection dag for cyclic regions. The search begins from icmp; /// instructions operands where a tree, consisting of non-wrapping or safe; /// wrapping instructions, is built, checked and promoted if possible.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:689,Safety,safe,safe,689,"//===----- TypePromotion.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is an opcode based type promotion pass for small types that would; /// otherwise be promoted during legalisation. This works around the limitations; /// of selection dag for cyclic regions. The search begins from icmp; /// instructions operands where a tree, consisting of non-wrapping or safe; /// wrapping instructions, is built, checked and promoted if possible.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:460,Availability,mask,masked,460,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:696,Availability,mask,masking,696,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:43,Energy Efficiency,efficient,efficient,43,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:1696,Performance,perform,perform,1696,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:645,Usability,ux,uxtb,645,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:756,Usability,UX,UXTB,756,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:64,Integrability,wrap,wrapping,64,"// Is I an add or a sub, which isn't marked as nuw, but where a wrapping; // result won't affect the computation?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:76,Integrability,wrap,wrapping,76,"// Is V an instruction thats result can trivially promoted, or has safe; // wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:67,Safety,safe,safe,67,"// Is V an instruction thats result can trivially promoted, or has safe; // wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:273,Performance,load,loads,273,"/// Return true if the given value is a source in the use-def chain, producing; /// a narrow 'TypeSize' value. These values will be zext to start the promotion; /// of the tree to i32. We guarantee that these won't populate the upper bits; /// of the register. ZExt on the loads will be free, and the same for call; /// return values because we only accept ones that guarantee a zeroext ret val.; /// Many arguments will have the zeroext attribute too, so those would be free; /// too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:47,Integrability,wrap,wrap,47,/// Return whether this instruction can safely wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:40,Safety,safe,safely,40,/// Return whether this instruction can safely wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:32,Integrability,wrap,wrapping,32,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:146,Integrability,wrap,wrapping,146,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:202,Integrability,wrap,wrapping,202,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:276,Integrability,wrap,wrapping,276,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:407,Integrability,wrap,wrap,407,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:473,Integrability,wrap,wrap,473,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:886,Integrability,wrap,wrap,886,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:629,Modifiability,extend,extending,629,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:104,Modifiability,extend,extending,104,/// Return whether we can safely mutate V's type to ExtTy without having to be; /// concerned with zero extending or truncation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:26,Safety,safe,safely,26,/// Return whether we can safely mutate V's type to ExtTy without having to be; /// concerned with zero extending or truncation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:15,Modifiability,extend,extending,15,"// Now, insert extending instructions between the sources and their users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:156,Modifiability,extend,extend,156,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:236,Modifiability,extend,extend,236,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:75,Safety,Safe,SafeWrap,75,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:92,Safety,Safe,SafeWrap,92,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:35,Availability,redundant,redundant,35,"// Some zexts will now have become redundant, along with their trunc; // operands, so remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:35,Safety,redund,redundant,35,"// Some zexts will now have become redundant, along with their trunc; // operands, so remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:3,Performance,Cache,Cache,3,// Cache original types of the values that will likely need truncating,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:53,Availability,mask,masks,53,"// Convert any truncs, that aren't sources, into AND masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:80,Usability,clear,clear,80,"// Finally, remove unecessary zexts and truncs, delete old instructions and; // clear the data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:7,Performance,optimiz,optimizations,7,"// DAG optimizations should be able to handle these cases better, especially; // for function arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:560,Performance,perform,performs,560,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:409,Usability,simpl,simple,409,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:431,Usability,Simpl,SimplifyCFG,431,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:571,Usability,simpl,simple,571,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:3,Testability,Test,Test,3,// Test for deadness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:3,Deployability,Update,Update,3,// Update dominator and loop info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:156,Usability,simpl,simply,156,// The input register to the PHI has a subregister or it can't be; // constrained to the proper register class or it is undef:; // insert a COPY instead of simply replacing the output; // with the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp:169,Safety,abort,abort,169,"/// getTypeForEVT - This method returns an LLVM type corresponding to the; /// specified EVT. For integer types, this returns an unsigned type. Note; /// that this will abort for types that cannot be represented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:482,Integrability,interface,interface,482,"//===- llvm/CodeGen/VirtRegMap.cpp - Virtual Register Map -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the VirtRegMap class.; //; // It also contains implementations of the Spiller interface, which, given a; // virtual register map and a machine function, eliminates all virtual; // references by replacing them with physical register references - adding spill; // code as necessary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:366,Deployability,update,updates,366,//===----------------------------------------------------------------------===//; // VirtRegRewriter; //===----------------------------------------------------------------------===//; //; // The VirtRegRewriter is the last of the register allocator passes.; // It rewrites virtual registers to physical registers as specified in the; // VirtRegMap analysis. It also updates live-in information on basic blocks; // according to LiveIntervals.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:264,Modifiability,rewrite,rewrites,264,//===----------------------------------------------------------------------===//; // VirtRegRewriter; //===----------------------------------------------------------------------===//; //; // The VirtRegRewriter is the last of the register allocator passes.; // It rewrites virtual registers to physical registers as specified in the; // VirtRegMap analysis. It also updates live-in information on basic blocks; // according to LiveIntervals.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:64,Usability,Clear,ClearVirtRegs,64,// Write out new DBG_VALUE instructions.; // We only do this if ClearVirtRegs is specified since this should be the; // final run of the pass and we don't want to emit them multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:123,Deployability,release,release,123,// All machine operands and other references to virtual registers have been; // replaced. Remove the virtual registers and release all the transient data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:93,Energy Efficiency,allocate,allocated,93,// There may be no physical register assigned if only some register; // classes were already allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:99,Safety,detect,detect,99,// This code is only meant to handle reading undefined subregisters which; // we couldn't properly detect before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:118,Deployability,update,update,118,"// We may have deferred allocation of the virtual register, and the rewrite; // regs code doesn't handle the liveness update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:68,Modifiability,rewrite,rewrite,68,"// We may have deferred allocation of the virtual register, and the rewrite; // regs code doesn't handle the liveness update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:213,Deployability,update,update,213,/// The liverange splitting logic sometimes produces bundles of copies when; /// subregisters are involved. Expand these into a sequence of copy instructions; /// after processing the last in the bundle. Does not update LiveIntervals; /// which we shouldn't need for this instruction anymore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:28,Testability,log,logic,28,/// The liverange splitting logic sometimes produces bundles of copies when; /// subregisters are involved. Expand these into a sequence of copy instructions; /// after processing the last in the bundle. Does not update LiveIntervals; /// which we shouldn't need for this instruction anymore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:109,Energy Efficiency,schedul,schedule,109,"// If any of the destination registers in the bundle of copies alias any of; // the source registers, try to schedule the instructions to avoid any; // clobbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:138,Safety,avoid,avoid,138,"// If any of the destination registers in the bundle of copies alias any of; // the source registers, try to schedule the instructions to avoid any; // clobbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:195,Usability,undo,undone,195,"// If instruction is in the middle of the bundle, move it before the; // bundle starts, otherwise, just unbundle it. When we get to the last; // instruction, the bundle will have been completely undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite. Note we could have used MachineOperand::substPhysReg(), but; // we need the inlining here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:88,Energy Efficiency,allocate,allocated,88,// Don't bother maintaining accurate LiveIntervals for registers which were; // already allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:47,Energy Efficiency,Schedul,Scheduling,47,"//===- VLIWMachineScheduler.cpp - VLIW-Focused Scheduling Pass ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:400,Energy Efficiency,schedul,schedules,400,"//===- VLIWMachineScheduler.cpp - VLIW-Focused Scheduling Pass ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:64,Availability,avail,available,64,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:16,Energy Efficiency,schedul,scheduler,16,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:109,Integrability,depend,dependence,109,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:101,Performance,latency,latency,101,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:162,Availability,avail,available,162,"// This value is used to determine if a register class is a high pressure set.; // We compute the maximum number of registers needed and divided by the total; // available. Then, we compare the result to this value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:30,Integrability,depend,dependence,30,/// Return true if there is a dependence between SUd and SUu.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:74,Integrability,depend,dependencies,74,"// Since we do not add pseudos to packets, might as well; // ignore order dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Energy Efficiency,schedul,scheduling,13,"/// Check if scheduling of this SU is possible; /// in the current packet.; /// It is _not_ precise (statefull), it is more like; /// another heuristic. Many corner cases are figured; /// empirically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Deployability,pipeline,pipeline,20,// First see if the pipeline could receive this instruction; // in the current cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:33,Integrability,depend,dependencies,33,// Now see if there are no other dependencies to instructions already; // in the packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:18,Availability,avail,available,18,/// Keep track of available resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:4,Energy Efficiency,schedul,schedule,4,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:105,Energy Efficiency,schedul,scheduling,105,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:206,Energy Efficiency,schedul,scheduling,206,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:59,Integrability,depend,dependencies,59,// Postprocess the DAG to add platform-specific artificial dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,// Notify the scheduling strategy after updating the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:18,Safety,Hazard,HazardRecognizers,18,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:108,Safety,Hazard,HazardRecs,108,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:83,Energy Efficiency,schedul,scheduler,83,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:157,Energy Efficiency,Schedul,ScheduleHazardRecognizer,157,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:475,Energy Efficiency,schedul,scheduler,475,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:24,Safety,hazard,hazard,24,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:115,Safety,hazard,hazard,115,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:209,Safety,hazard,hazard,209,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:428,Safety,hazard,hazards,428,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:357,Testability,log,logic,357,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:450,Usability,simpl,simple,450,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Safety,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Security,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:10,Safety,Hazard,HazardRec,10,// Bypass HazardRec virtual calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:46,Performance,latency,latency,46,// Bypass getHazardType calls in case of long latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:3,Deployability,Update,Update,3,// Update the reservation table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:98,Deployability,pipeline,pipeline,98,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Energy Efficiency,schedul,scheduled,13,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:76,Energy Efficiency,schedul,scheduling,76,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:88,Usability,clear,clear,88,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:3,Deployability,Update,Update,3,// Update DFA model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:42,Availability,avail,available,42,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:4,Deployability,Release,Release,4,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:52,Performance,queue,queue,52,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:10,Availability,avail,available,10,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Performance,queue,queue,20,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:42,Safety,safe,safe,42,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:98,Availability,avail,available,98,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:108,Performance,queue,queue,108,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:12,Performance,queue,queue,12,"/// If this queue only has one ready candidate, return it. As a side effect,; /// advance the cycle until at least one node is ready. If multiple instructions; /// are ready, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:17,Performance,queue,queue,17,"// Very detailed queue dump, to be used with higher verbosity levels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:15,Availability,avail,available,15,"// We found an available, but not scheduled, predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:34,Energy Efficiency,schedul,scheduled,34,"// We found an available, but not scheduled, predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:15,Availability,avail,available,15,"// We found an available, but not scheduled, successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:34,Energy Efficiency,schedul,scheduled,34,"// We found an available, but not scheduled, successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:155,Availability,down,down,155,"// The pressure differences are computed bottom-up, so the comparison for; // an increase is positive in the bottom direction, but negative in the; // top-down direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:36,Energy Efficiency,schedul,scheduling,36,/// Single point to compute overall scheduling cost.; /// TODO: More heuristics will be used soon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:47,Energy Efficiency,schedul,scheduled,47,// Do not waste time on a node that is already scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Availability,avail,available,20,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:65,Energy Efficiency,schedul,scheduling,65,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Availability,avail,available,20,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:65,Energy Efficiency,schedul,scheduling,65,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:35,Energy Efficiency,schedul,scheduling,35,// How many SUs does it block from scheduling?; // Look at all of the successors of this node.; // Count the number of nodes that; // this node is the sole unscheduled node for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:103,Availability,avail,available,103,"// If there are register pressure issues, then we remove the value added for; // the instruction being available. The rationale is that we really don't; // want to schedule an instruction that causes a spill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:164,Energy Efficiency,schedul,schedule,164,"// If there are register pressure issues, then we remove the value added for; // the instruction being available. The rationale is that we really don't; // want to schedule an instruction that causes a spill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:56,Integrability,depend,dependent,56,// Give preference to a zero latency instruction if the dependent; // instruction is in the current packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:29,Performance,latency,latency,29,// Give preference to a zero latency instruction if the dependent; // instruction is in the current packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:304,Availability,avail,available,304,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:242,Deployability,update,updates,242,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:125,Energy Efficiency,schedul,scheduled,125,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:194,Energy Efficiency,schedul,scheduled,194,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:232,Energy Efficiency,schedul,scheduler,232,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:45,Integrability,depend,dependence,45,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:169,Integrability,depend,dependent,169,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:37,Performance,latency,latency,37,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:180,Energy Efficiency,schedul,scheduling,180,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:269,Energy Efficiency,schedul,scheduled,269,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:41,Performance,queue,queue,41,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:106,Performance,cache,cached,106,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:39,Integrability,depend,depend,39,// Choose an instruction that does not depend on an artificial edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:29,Energy Efficiency,schedul,scheduling,29,"// Tie breaker.; // To avoid scheduling indeterminism, we need a tie breaker; // for the case when cost is identical for two nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:23,Safety,avoid,avoid,23,"// Tie breaker.; // To avoid scheduling indeterminism, we need a tie breaker; // for the case when cost is identical for two nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:63,Performance,queue,queue,63,/// Pick the best candidate node from either the top or bottom queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:79,Energy Efficiency,efficient,efficient,79,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:17,Energy Efficiency,schedul,scheduling,17,// Prefer bottom scheduling when heuristics are silent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:114,Energy Efficiency,schedul,schedule,114,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:199,Energy Efficiency,schedul,scheduled,199,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:258,Energy Efficiency,schedul,scheduling,258,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:347,Energy Efficiency,schedul,schedule,347,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:38,Energy Efficiency,schedul,schedule,38,/// Pick the best node to balance the schedule. Implements MachineSchedStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:4,Deployability,Update,Update,4,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:167,Deployability,update,update,167,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:15,Energy Efficiency,schedul,scheduler,15,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:39,Energy Efficiency,schedul,scheduling,39,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:1698,Integrability,wrap,wrapper,1698,"ock:; // (In C-style pseudocode); //; // - Before:; // catchpad ...; // exn = wasm.get.exception();; // selector = wasm.get.selector();; // ...; //; // - After:; // catchpad ...; // exn = wasm.catch(WebAssembly::CPP_EXCEPTION);; // // Only add below in case it's not a single catch (...); // wasm.landingpad.index(index);; // __wasm_lpad_context.lpad_index = index;; // __wasm_lpad_context.lsda = wasm.lsda();; // _Unwind_CallPersonality(exn);; // selector = __wasm_lpad_context.selector;; // ...; //; //; // * Background: Direct personality function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:2544,Integrability,wrap,wrapper,2544,"ty function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_obj =; // (struct _Unwind_Exception *)exception_ptr;; // _Unwind_Reason_Code ret = __gxx_personality_v0(; // 1, _UA_CLEANUP_PHASE, exception_obj->exception_class, exception_obj,; // (struct _Unwind_Context *)__wasm_lpad_context);; // return ret;; // }; //; // We pass a landing pad index, and the address of LSDA for the current function; // to the wrapper function _Unwind_CallPersonality in libunwind, and we retrieve; // the selector after it returns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:3061,Integrability,wrap,wrapper,3061,"ty function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_obj =; // (struct _Unwind_Exception *)exception_ptr;; // _Unwind_Reason_Code ret = __gxx_personality_v0(; // 1, _UA_CLEANUP_PHASE, exception_obj->exception_class, exception_obj,; // (struct _Unwind_Context *)__wasm_lpad_context);; // return ret;; // }; //; // We pass a landing pad index, and the address of LSDA for the current function; // to the wrapper function _Unwind_CallPersonality in libunwind, and we retrieve; // the selector after it returns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:1920,Performance,perform,perform,1920,"d ...; // exn = wasm.catch(WebAssembly::CPP_EXCEPTION);; // // Only add below in case it's not a single catch (...); // wasm.landingpad.index(index);; // __wasm_lpad_context.lpad_index = index;; // __wasm_lpad_context.lsda = wasm.lsda();; // _Unwind_CallPersonality(exn);; // selector = __wasm_lpad_context.selector;; // ...; //; //; // * Background: Direct personality function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_obj =; // (struct _Unwind_Exception *)exception_ptr;; // _Unwind_Reason_Code ret = __gxx_personality_v0(; // 1, _UA_CLEANUP_PHASE, exception_obj->exception_class, exception_",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:29,Integrability,wrap,wrapper,29,// _Unwind_CallPersonality() wrapper,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:170,Availability,down,downgrade,170,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:125,Integrability,depend,depend,125,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:30,Modifiability,variab,variable,30,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:49,Modifiability,variab,variable,49,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:32,Availability,down,down,32,// wasm.catch() will be lowered down to wasm 'catch' instruction in; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:29,Integrability,wrap,wrapper,29,"// _Unwind_CallPersonality() wrapper function, which calls the personality",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:202,Performance,optimiz,optimizing,202,"// TODO Sometimes storing the LSDA address every time is not necessary, in; // case it is already set in a dominating EH pad and there is no function call; // between from that EH pad to here. Consider optimizing those cases.; // Pseudocode: __wasm_lpad_context.lsda = wasm.lsda();",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:83,Performance,load,loaded,83,// Replace the return value from wasm.get.ehselector() with the selector value; // loaded from __wasm_lpad_context.selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:30,Integrability,rout,routine,30,"// The central theory of this routine is based on the following:; // A _try scope is always a SEME (Single Entry Multiple Exits) region; // as jumping into a _try is not allowed; // The single entry must start with a seh_try_begin() invoke with a; // correct State number that is the initial state of the SEME.; // Through control-flow, state number is propagated into all blocks.; // Side exits marked by seh_try_end() will unwind to parent state via; // existing SEHUnwindMap[].; // Side exits can ONLY jump into parent scopes (lower state number).; // Thus, when a block succeeds various states from its predecessors,; // the lowest State trumphs others.; // If some exits flow to unreachable, propagation on those paths terminate,; // not affecting remaining blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:36,Deployability,update,update,36,"// Now child Catches are processed, update CatchHigh",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:974,Availability,down,down,974,"// This numbering assigns one state number to each catchpad and cleanuppad.; // It also computes two tree-like relations over states:; // 1) Each state has a ""HandlerParentState"", which is the state of the next; // outer handler enclosing this state's handler (same as nearest ancestor; // per the ParentPad linkage on EH pads, but skipping over catchswitches).; // 2) Each state has a ""TryParentState"", which:; // a) for a catchpad that's not the last handler on its catchswitch, is; // the state of the next catchpad on that catchswitch; // b) for all other pads, is the state of the pad whose try region is the; // next outer try region enclosing this state's try region. The ""try; // regions are not present as such in the IR, but will be inferred; // based on the placement of invokes and pads which reach each other; // by exceptional exits; // Catchswitches do not get their own states, but each gets mapped to the; // state of its first catchpad.; // Step one: walk down from outermost to innermost funclets, assigning each; // catchpad and cleanuppad a state number. Add an entry to the; // ClrEHUnwindMap for each state, recording its HandlerParentState and; // handler attributes. Record the TryParentState as well for each catchpad; // that's not the last on its catchswitch, but initialize all other entries'; // TryParentStates to a sentinel -1 value that the next pass will update.; // Seed a worklist with pads that have no parent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:1389,Deployability,update,update,1389,"// This numbering assigns one state number to each catchpad and cleanuppad.; // It also computes two tree-like relations over states:; // 1) Each state has a ""HandlerParentState"", which is the state of the next; // outer handler enclosing this state's handler (same as nearest ancestor; // per the ParentPad linkage on EH pads, but skipping over catchswitches).; // 2) Each state has a ""TryParentState"", which:; // a) for a catchpad that's not the last handler on its catchswitch, is; // the state of the next catchpad on that catchswitch; // b) for all other pads, is the state of the pad whose try region is the; // next outer try region enclosing this state's try region. The ""try; // regions are not present as such in the IR, but will be inferred; // based on the placement of invokes and pads which reach each other; // by exceptional exits; // Catchswitches do not get their own states, but each gets mapped to the; // state of its first catchpad.; // Step one: walk down from outermost to innermost funclets, assigning each; // catchpad and cleanuppad a state number. Add an entry to the; // ClrEHUnwindMap for each state, recording its HandlerParentState and; // handler attributes. Record the TryParentState as well for each catchpad; // that's not the last on its catchswitch, but initialize all other entries'; // TryParentStates to a sentinel -1 value that the next pass will update.; // Seed a worklist with pads that have no parent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:94,Availability,fault,fault,94,// Create the entry for this cleanup with the appropriate handler; // properties. Finally and fault handlers are distinguished by arity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Performance,Queue,Queue,3,// Queue any child EH pads on the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Performance,Queue,Queue,3,// Queue any child EH pads on the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:172,Usability,Simpl,SimplifyUnreachable,172,"// Not having an unwind dest for this user might indicate that it; // doesn't unwind, so can't be taken as proof that the cleanup itself; // may unwind to caller (see e.g. SimplifyUnreachable and; // RemoveUnwindEdge).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:659,Availability,down,down,659,"// If UnwindDest is null at this point, either the pad in question can; // be exited by unwind to caller, or it cannot be exited by unwind. In; // either case, reporting such cases as unwinding to caller is correct.; // This can lead to EH tables that ""look strange"" -- if this pad's is in; // a parent funclet which has other children that do unwind to an enclosing; // pad, the try region for this pad will be missing the ""duplicate"" EH; // clause entries that you'd expect to see covering the whole parent. That; // should be benign, since the unwind never actually happens. If it were; // an issue, we could add a subsequent pass that pushes unwind dests down; // from parents that have them to children that appear to unwind to caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:43,Performance,perform,perform,43,// Record delta operations that we need to perform to our color mappings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Deployability,Update,Update,3,// Update our color mappings to reflect that one block has lost a color and; // another has gained a color.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:48,Deployability,update,updated,48,// Catchrets targeting cloned blocks need to be updated separately from; // the loop above because they are not in the current funclet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:97,Deployability,update,update,97,"// If there were values defined in BB that are used outside the funclet,; // then we now have to update all uses of the value to use either the; // original value, the cloned value, or some PHI derived value. This can; // require arbitrary PHI insertion, of which we are prepared to do, clean; // these up now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:134,Availability,alive,alive,134,// Remove unreachable blocks. It is not valuable to assign them a color and; // their existence can trick us into thinking values are alive when they are; // not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:15,Performance,load,loads,15,"// TODO: Share loads when one use dominates another, or when a catchpad exit; // dominates uses (needs dominators).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:57,Performance,load,load,57,"// If the EHPad isn't a terminator, then we can insert a load in this block; // that will dominate all uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:81,Performance,load,loads,81,"// Otherwise, we have a PHI on a terminator EHPad, and we give up and insert; // loads of the slot before every use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:57,Performance,load,loads,57,// Use is on an EH pad phi. Leave it alone; we'll insert loads and; // stores for it separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:13,Safety,safe,safely,13,// Undef can safely be skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:39,Performance,queue,queue,39,"// Pred is unsplittable, so we need to queue it on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:44,Performance,load,load,44,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:101,Performance,load,load,101,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:287,Performance,load,loads,287,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:378,Performance,load,load,378,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:494,Performance,load,loads,494,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:13,Performance,load,load,13,"// Putting a load above a catchret and use on the phi would still leave; // a cross-funclet def/use. We need to split the edge, change the; // catchret to target the new block, and put the load there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:189,Performance,load,load,189,"// Putting a load above a catchret and use on the phi would still leave; // a cross-funclet def/use. We need to split the edge, change the; // catchret to target the new block, and put the load there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Deployability,Update,Update,3,// Update the color mapping for the newly split edge.; // Grab a reference to the ColorVector to be inserted before getting the; // reference to the vector we are copying because inserting the new; // element in BlockColors might cause the map to be reallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:39,Performance,load,load,39,// Treat the new block as incoming for load insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:14,Performance,load,load,14,// Insert the load into the predecessor block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp:66,Deployability,patch,patchable,66,"// Replace the original RET instruction with the exit sled code (""patchable; // ret"" pseudo-instruction), so that at runtime XRay can replace the sled; // with a code jumping to XRay trampoline, which calls the tracing handler; // and, in the end, issues the RET instruction.; // This is the approach to go on CPUs which have a single RET instruction,; // like x86/x86_64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp:69,Deployability,patch,patchable,69,"// Prepend the original return instruction with the exit sled code (""patchable; // function exit"" pseudo-instruction), preserving the original return; // instruction just after the exit sled code.; // This is the approach to go on CPUs which have multiple options for the; // return instruction, like ARM. For such CPUs we can't just jump into the; // XRay trampoline and issue a single return instruction there. We rather; // have to call the trampoline and return from it to the original return; // instruction of the function being instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp:94,Integrability,depend,dependent,94,"// Check if we have a loop.; // FIXME: Maybe make this smarter, and see whether the loops are dependent; // on inputs or side-effects?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:34,Security,hash,hashes,34,// First get the number of unique hashes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:25,Security,hash,hash,25,// Create the individual hash data outputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:105,Security,hash,hashes,105,"// Figure out how many buckets we need, then compute the bucket contents and; // the final ordering. The hashes and offsets can be emitted by walking these; // data structures. We add temporary symbols to the data so they can be; // referenced when emitting the offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:39,Security,hash,hash,39,// Sort the contents of the buckets by hash value so that hash collisions end; // up together. Stable sort makes testing easier and doesn't cost much more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:58,Security,hash,hash,58,// Sort the contents of the buckets by hash value so that hash collisions end; // up together. Stable sort makes testing easier and doesn't cost much more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:113,Testability,test,testing,113,// Sort the contents of the buckets by hash value so that hash collisions end; // up together. Stable sort makes testing easier and doesn't cost much more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:59,Security,hash,hash,59,"///< Data to emit.; /// Controls whether to emit duplicate hash and offset table entries for names; /// with identical hashes. Apple tables don't emit duplicate entries, DWARF v5; /// tables do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:119,Security,hash,hashes,119,"///< Data to emit.; /// Controls whether to emit duplicate hash and offset table entries for names; /// with identical hashes. Apple tables don't emit duplicate entries, DWARF v5; /// tables do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:26,Safety,detect,detect,26,/// 'HASH' magic value to detect endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:5,Security,HASH,HASH,5,/// 'HASH' magic value to detect endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:112,Performance,perform,performs,112,"/// Class responsible for emitting a DWARF v5 Accelerator Table. The only; /// public function is emit(), which performs the actual emission.; ///; /// A callback abstracts the logic to provide a CU index for a given entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:177,Testability,log,logic,177,"/// Class responsible for emitting a DWARF v5 Accelerator Table. The only; /// public function is emit(), which performs the actual emission.; ///; /// A callback abstracts the logic to provide a CU index for a given entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:32,Security,hash,hashes,32,"// Buckets point in the list of hashes, not to the data. Do not increment; // the index multiple times in case of hash collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:114,Security,hash,hash,114,"// Buckets point in the list of hashes, not to the data. Do not increment; // the index multiple times in case of hash collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:47,Security,hash,hash,47,// Terminate the previous entry if there is no hash collision with the; // current one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:102,Availability,fault,faulty,102,// This is not crashing on bad input: we should only reach this if the; // internal compiler logic is faulty; see getFormForIdxParent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:93,Testability,log,logic,93,// This is not crashing on bad input: we should only reach this if the; // internal compiler logic is faulty; see getFormForIdxParent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:59,Security,access,accesses,59,/// Constructs a unique AbbrevTag that captures what a DIE accesses.; /// Using this tag we can emit a unique abbreviation for each DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:137,Safety,avoid,avoids,137,"// Emit the label for this Entry, so that IDX_parents may refer to it.; // Note: a DIE may have multiple accelerator Entries; this check avoids; // creating/emitting multiple labels for the same DIE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:359,Integrability,rout,routine,359,"// Generate EH Info Table.; // The EH Info Table, aka, 'compat unwind section' on AIX, have the following; // format: struct eh_info_t {; // unsigned version; /* EH info verion 0 */; // #if defined(__64BIT__); // char _pad[4]; /* padding */; // #endif; // unsigned long lsda; /* Pointer to LSDA */; // unsigned long personality; /* Pointer to the personality routine */; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:15,Integrability,rout,routine,15,// Personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:27,Security,access,access,27,"// There is no easy way to access register information in `AIXException`; // class. when ShouldEmitEHBlock is false and VRs are saved, A dumy eh info; // table are emitted in PPCAIXAsmPrinter::emitFunctionBodyEnd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:155,Performance,queue,queue,155,"// If the block got deleted, there is no need for the symbol. If the symbol; // was already emitted, we can just forget about it, otherwise we need to; // queue it up for later emission when the function is output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Usability,Clear,Clear,3,// Clear the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:57,Safety,detect,detectable,57,"// BasicBlock is destroyed already, so this access is UB detectable by msan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:44,Security,access,access,44,"// BasicBlock is destroyed already, so this access is UB detectable by msan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Deployability,Update,Update,3,// Update the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Deployability,Update,Update,3,"// Update the callback.; // Otherwise, we need to add the old symbols to the new block's set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:18,Performance,cache,cached,18,"// Do not use the cached DataLayout because some client use it without a Module; // (dsymutil, llvm-dwarfdump).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:24,Deployability,deploy,deployment,24,"// Emit the version-min deployment target directive if needed.; //; // FIXME: If we end up with a collection of these sorts of Darwin-specific; // or ELF-specific things, it may make sense to have a platform helper class; // that will work with the target helper class. For now keep it here, as the; // alternative is duplicated code in each of the target asm printers that; // use the directive, where it would need the same conditionalization; // anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:51,Modifiability,variab,variable,51,/// EmitGlobalVariable - Emit the specified global variable to the .s file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:18,Modifiability,variab,variable,18,// Never emit TLS variable xyz in emulated TLS model.; // The initialization value is in __emutls_t.xyz instead of xyz.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:29,Modifiability,variab,variable,29,"// When printing the control variable __emutls_v.*,; // we don't need to print the original TLS variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:96,Modifiability,variab,variable,96,"// When printing the control variable __emutls_v.*,; // we don't need to print the original TLS variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,Safety,avoid,avoid,30,"// .comm Foo, 0 is undefined, avoid it.; // .comm _foo, 42, 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:351,Deployability,integrat,integrated,351,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:351,Integrability,integrat,integrated,351,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,Safety,avoid,avoid,30,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:387,Usability,simpl,simply,387,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:304,Availability,down,down,304,"// Handle thread local data for mach-o which requires us to output an; // additional structure of data and mangle the original symbol so that we; // can reference it later.; //; // TODO: This should become an ""emit thread local global"" method on TLOF.; // All of this macho specific stuff should be sunk down into TLOFMachO and; // stuff like ""TLSExtraDataSection"" should no longer be part of the parent; // TLOF class. This will also make it more obvious that stuff like; // MCStreamer::EmitTBSSSymbol is macho specific and only called from macho; // specific code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:12,Modifiability,variab,variable,12,// Emit the variable struct for the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:37,Deployability,patch,patchable-function-prefix,37,// Emit KCFI type information before patchable-function-prefix nops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:57,Security,sanitiz,sanitizer,57,// Emit the function prologue data for the indirect call sanitizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:178,Energy Efficiency,Power,PowerPC,178,// Emit the function descriptor. This is a virtual function to allow targets; // to emit their specific function descriptor. Right now it is only used by; // the AIX target. The PowerPC 64-bit V1 ELF target also uses function; // descriptors and should be converted to use this hook as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:137,Availability,error,error,137,// The function label could have already been emitted if two symbols end up; // conflicting due to asm renaming. Detect this and emit an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,Safety,Detect,Detect,113,// The function label could have already been emitted if two symbols end up; // conflicting due to asm renaming. Detect this and emit an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:67,Usability,simpl,simplify,67,"// First convert this to a non-variadic expression if possible, to simplify; // the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:29,Usability,simpl,simplified,29,"// Then, output the possibly-simplified expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:110,Usability,simpl,simply,110,"// Expect the first operand to be a section name. After that, a tuple of; // constants may appear, which will simply be emitted into the current; // section (the user of MD_pcsections decides the format of encoded data).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:49,Safety,avoid,avoids,49,"// Emit relative relocation `addr - base`, which avoids a dynamic; // relocation in the final binary. User will get the address with; // `base + addr`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:270,Modifiability,variab,variable,270,"// For AsynchEH, insert a Nop if followed by a trap inst; // Or the exception won't be caught.; // (see MCConstantExpr::create(1,..) in WinException.cpp); // Ignore SDiv/UDiv because a DIV with Const-0 divisor; // must have being turned into an UndefValue.; // Div with variable opnds won't be the first instruction in; // an EH region as it must be led by at least a Load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:368,Performance,Load,Load,368,"// For AsynchEH, insert a Nop if followed by a trap inst; // Or the exception won't be caught.; // (see MCConstantExpr::create(1,..) in WinException.cpp); // Ignore SDiv/UDiv because a DIV with Const-0 divisor; // must have being turned into an UndefValue.; // Div with variable opnds won't be the first instruction in; // an EH region as it must be led by at least a Load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:120,Safety,safe,safely,120,"// This instruction reference will have been resolved to a machine; // location, and a nearby DBG_VALUE created. We can safely ignore; // the instruction reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:406,Performance,load,load,406,"// If the function is empty and the object file uses .subsections_via_symbols,; // then we need to emit *something* to the function body to prevent the; // labels from collapsing together. Just emit a noop.; // Similarly, don't emit empty functions on Windows either. It can lead to; // duplicate entries (two functions with the same RVA) in the Guard CF Table; // after linking, causing the kernel not to load the binary:; // https://developercommunity.visualstudio.com/content/problem/45366/vc-linker-creates-invalid-dll-with-clang-cl.html; // FIXME: Hide this behind some API in e.g. MCAsmInfo or MCTargetStreamer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:33,Modifiability,Variab,Variables,33,/// Compute the number of Global Variables that uses a Constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:120,Modifiability,variab,variables,120,"/// Only consider global GOT equivalents if at least one user is a; /// cstexpr inside an initializer of another global variables. Also, don't; /// handle cstexpr inside instructions. During global variable emission,; /// candidates are skipped and are emitted later in case at least one cstexpr; /// isn't replaced by a PC relative GOT entry access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:198,Modifiability,variab,variable,198,"/// Only consider global GOT equivalents if at least one user is a; /// cstexpr inside an initializer of another global variables. Also, don't; /// handle cstexpr inside instructions. During global variable emission,; /// candidates are skipped and are emitted later in case at least one cstexpr; /// isn't replaced by a PC relative GOT entry access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:343,Security,access,access,343,"/// Only consider global GOT equivalents if at least one user is a; /// cstexpr inside an initializer of another global variables. Also, don't; /// handle cstexpr inside instructions. During global variable emission,; /// candidates are skipped and are emitted later in case at least one cstexpr; /// isn't replaced by a PC relative GOT entry access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,Modifiability,variab,variable,113,"// To be a got equivalent, at least one of its users need to be a constant; // expression used by another global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:28,Modifiability,variab,variables,28,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:89,Modifiability,variab,variable,89,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:360,Modifiability,variab,variables,360,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:186,Performance,Optimiz,Optimize,186,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:373,Safety,avoid,avoid,373,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:210,Security,access,accesses,210,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:465,Security,access,access,465,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:42,Usability,usab,usable,42,"// AIX's assembly directive `.set` is not usable for aliasing purpose,; // so AIX has to use the extra-label-at-definition strategy. At this; // point, all the extra label is emitted, we just have to emit linkage for; // those labels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:31,Modifiability,variab,variable,31,// Linkage for alias of global variable has been emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:73,Security,access,accesses,73,// Set the MachineFunction to nullptr so that we can catch attempted; // accesses to MF specific features at the module level and so that; // we can conditionalize accesses based on whether or not it is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:164,Security,access,accesses,164,// Set the MachineFunction to nullptr so that we can catch attempted; // accesses to MF specific features at the module level and so that; // we can conditionalize accesses based on whether or not it is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:130,Safety,avoid,avoid,130,"// Gather all GOT equivalent globals in the module. We really need two; // passes over the globals: one to compute and another to avoid its emission; // in EmitGlobalVariable, otherwise we would not be able to handle cases; // where the got equivalent shows up before its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:15,Modifiability,variab,variables,15,// Emit global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,Modifiability,Variab,Variable,30,// Handle the XCOFF case.; // Variable `Name` is the function descriptor symbol (see above). Get the; // function entry point symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:72,Safety,safe,safest,72,// Emit the remarks section contents.; // FIXME: Figure out when is the safest time to emit this section. It should; // not come after debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:47,Modifiability,variab,variables,47,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:10,Testability,stub,stubs,10,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:47,Modifiability,variab,variables,47,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:10,Testability,stub,stubs,10,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:243,Modifiability,plugin,plugins,243,"// Emit Stack maps before any debug info. Mach-O requires that no data or; // text sections come after debug info has been emitted. This matters for; // stack maps as they are arbitrary data, and may even have a custom format; // through user plugins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:144,Energy Efficiency,Power,PowerPC,144,"// Print aliases in topological order, that is, for each alias a = b,; // b must be printed before a.; // This is because on some targets (e.g. PowerPC) linker expects aliases in; // such an order to generate correct TOC information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:112,Availability,alive,alive,112,"// This deletes all the ephemeral handlers that AsmPrinter added, while; // keeping all the user-added handlers alive until the AsmPrinter is; // destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:112,Energy Efficiency,reduce,reduce,112,// Calculate sections for constant pool entries. We collect entries to go into; // the same section together to reduce amount of section switch statements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:53,Safety,avoid,avoids,53,"// For the EK_LabelDifference32 entry, if using .set avoids a relocation,; /// emit a .set directive for each unique entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:137,Usability,Simpl,Simplify,137,"// FIXME: This doesn't have to have any specific name, just any randomly; // named and numbered local label started with 'l' would work. Simplify; // GetJTISymbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:211,Safety,avoid,avoids,211,"// Each entry is the address of the block minus the address of the jump; // table. This is used for PIC jump tables where gprel32 is not supported.; // e.g.:; // .word LBB123 - LJTI1_2; // If the .set directive avoids relocations, this is emitted as:; // .set L4_5_set_123, LBB123 - LJTI1_2; // .word L4_5_set_123",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:152,Availability,redundant,redundant,152,"// FIXME: For non-dllimport functions, MSVC emits the same entry; // twice, for reasons I don't understand. I have to assume the linker; // ignores the redundant entry; there aren't any reasonable semantics; // to attach to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:152,Safety,redund,redundant,152,"// FIXME: For non-dllimport functions, MSVC emits the same entry; // twice, for reasons I don't understand. I have to assume the linker; // ignores the redundant entry; there aren't any reasonable semantics; // to attach to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:21,Modifiability,variab,variable,21,"// If the associated variable is not defined in this module; // (it might be available_externally, or have been an; // available_externally definition that was dropped by the; // EliminateAvailableExternally pass), some other TU; // will provide its dynamic initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:102,Integrability,rout,routines,102,//===--------------------------------------------------------------------===//; // Emission and print routines; //; /// Emit a byte directive and value.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:172,Safety,avoid,avoids,172,"/// Emit something like "".long Hi-Lo"" where the size in bytes of the directive; /// is specified by Size and Hi/Lo specify the labels. This implicitly uses; /// .set if it avoids relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:205,Availability,avail,available,205,"/// EmitLabelPlusOffset - Emit something like "".long Label+Offset""; /// where the size in bytes of the directive is specified by Size and Label; /// specifies the label. This implicitly uses .set if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:146,Energy Efficiency,power,power,146,"//===----------------------------------------------------------------------===//; // EmitAlignment - Emit an alignment directive to the specified power of; // two boundary. If a global value is specified, and if that global has; // an explicit alignment requested, it will override the alignment request; // if required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:25,Integrability,depend,depend,25,"// We emit the value and depend on the assembler to truncate the generated; // expression properly. This is important for differences between; // blockaddress labels. Since the two labels are in the same function, it; // is reasonable to treat their delta as a 32-bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:128,Usability,simpl,simplifies,128,// Handle casts to pointers by changing them into casts to the appropriate; // integer type. This promotes constant folding and simplifies this code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:206,Integrability,depend,depend,206,"// We can emit the pointer value into this slot if the slot is an; // integer slot equal to the size of the pointer.; //; // If the pointer is larger than the resultant integer, then; // as with Trunc just depend on the assembler to truncate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:21,Performance,optimiz,optimized,21,"// If the code isn't optimized, there may be outstanding folding; // opportunities. Attempt to fold the expression using DataLayout as a; // last resort before giving up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Modifiability,Extend,Extend,3,// Extend the element to take zero padding into account.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:129,Security,access,access,129,"/// Transform a not absolute MCExpr containing a reference to a GOT; /// equivalent global, by a target specific GOT pc relative access to the; /// final symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:39,Performance,cache,cached,39,// Check that GOT equivalent symbol is cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Deployability,Update,Update,3,// Update GOT equivalent usage information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:91,Safety,detect,detect,91,"// Since lowerConstant already folded and got rid of all IR pointer and; // integer casts, detect GOT equivalent accesses by looking into the MCExpr; // directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,Security,access,accesses,113,"// Since lowerConstant already folded and got rid of all IR pointer and; // integer casts, detect GOT equivalent accesses by looking into the MCExpr; // directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:101,Integrability,Rout,Routines,101,//===----------------------------------------------------------------------===//; // Symbol Lowering Routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:40,Deployability,update,updated,40,// Check if CFI information needs to be updated for this MBB with basic block; // sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:18,Usability,simpl,simple,18,"// If it is not a simple branch, we are in a table somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:132,Deployability,patch,patches,132,"// In the binary's ""xray_instr_map"" section, an array of these function entries; // describes each instrumentation point. When XRay patches your code, the index; // into this table will be given to your handler as a patch point identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:216,Deployability,patch,patch,216,"// In the binary's ""xray_instr_map"" section, an array of these function entries; // describes each instrumentation point. When XRay patches your code, the index; // into this table will be given to your handler as a patch point identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:222,Availability,down,down,222,"// We then emit a single entry in the index per function. We use the symbols; // that bound the instrumentation map as the range for a specific function.; // Each entry here will be 2 * word size aligned, as we're writing down two; // pointers. This should work for both 32-bit and 64-bit platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp:107,Integrability,Rout,Routines,107,//===----------------------------------------------------------------------===//; // Dwarf Emission Helper Routines; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp:100,Integrability,Rout,Routines,100,//===----------------------------------------------------------------------===//; // Dwarf Lowering Routines; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:61,Safety,avoid,avoid,61,// Remember if the buffer is nul terminated or not so we can avoid a copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:65,Deployability,integrat,integrated,65,"// If the output streamer does not have mature MC support or the integrated; // assembler has been disabled or not required, just emit the blob textually.; // Otherwise parse the asm and emit it via MC support.; // This is useful in case the asm parser doesn't handle something but the; // system assembler does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:65,Integrability,integrat,integrated,65,"// If the output streamer does not have mature MC support or the integrated; // assembler has been disabled or not required, just emit the blob textually.; // Otherwise parse the asm and emit it via MC support.; // This is useful in case the asm parser doesn't handle something but the; // system assembler does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:259,Integrability,depend,dependent,259,// We create a new MCInstrInfo here since we might be at the module level; // and not have a MachineFunction to initialize the TargetInstrInfo from and; // we only need MCInstrInfo for asm parsing. We create one unconditionally; // because it's not subtarget dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:5,Modifiability,variab,variable,5,// ${variable},MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:164,Availability,error,error,164,"// We may have a location metadata attached to the end of the; // instruction, and at no point should see metadata at any; // other point while processing. It's an error if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:189,Modifiability,portab,portably,189,"/// PrintSpecial - Print information related to the specified machine instr; /// that is independent of the operand, and may be independent of the instr; /// itself. This can be useful for portably encoding the comment character; /// or other bits of target-specific knowledge into the asmstrings. The; /// syntax used is ${:comment}. Targets can override this to add support; /// for their own strange codes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:82,Energy Efficiency,allocate,allocated,82,"// Comparing the address of MI isn't sufficient, because machineinstrs may; // be allocated to the same address across functions.; // If this is a new LastFn instruction, bump the counter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h:68,Security,hash,hashing,68,// For now we're just handling the calls we need for dwarf emission/hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:87,Security,access,access,87,"// Canonicalize the path. We have to do it textually because we may no longer; // have access the file in the filesystem.; // First, replace all slashes with backslashes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:53,Safety,abort,abort,53,"// Something's wrong if the path starts with ""\..\"", abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:22,Safety,abort,abort,22,"// Something's wrong, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:222,Availability,error,error,222,"// No scope means global scope and that uses the zero index.; //; // We also use zero index when the scope is a DISubprogram; // to suppress the emission of LF_STRING_ID for the function,; // which can trigger a link-time error with the linker in; // VS2019 version 16.11.2 or newer.; // Note, however, skipping the debug info emission for the DISubprogram; // is a temporary fix. The root issue here is that we need to figure out; // the proper way to encode a function nested in another function; // (as introduced by the Fortran 'contains' keyword) in CodeView.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:132,Security,access,access,132,"// If the scope is a DICompositeType, then this must be a method. Member; // function types take some special handling, and require access to the; // subprogram.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Modifiability,variab,variable,8,// This variable was inlined. Associate it with the InlineSite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Modifiability,variab,variable,8,// This variable goes into the corresponding lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:82,Availability,avail,available,82,"// If module doesn't have named metadata anchors or COFF debug section; // is not available, skip any debug info related stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:39,Security,hash,hashes,39,// Check if we should emit type record hashes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,Modifiability,variab,variable,15,// Emit global variable debug information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,variab,variables,49,// Emit UDT records for any types used by global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:29,Security,hash,hashes,29,"// Emit type information and hashes last, so that any types we translate while; // emitting function info are included.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Energy Efficiency,adapt,adapter,49,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Integrability,adapter,adapter,49,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,adapt,adapter,49,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:51,Security,hash,hash,51,"// Start the .debug$H section with the version and hash algorithm, currently; // hardcoded to version 0, SHA1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:55,Security,hash,hash,55,"// Emit an EOL-comment describing which TypeIndex this hash corresponds; // to, as well as the stringified SHA1 hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:112,Security,hash,hash,112,"// Emit an EOL-comment describing which TypeIndex this hash corresponds; // to, as well as the stringified SHA1 hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:384,Usability,clear,clear,384,"// First, make LF_BUILDINFO. It's a sequence of strings with various bits of; // build info. The known prefix is:; // - Absolute path of current directory; // - Compiler path; // - Main source file path, relative to CWD or absolute; // - Type server PDB file; // - Canonical compiler command line; // If frontend and backend compilation are separated (think llc or LTO), it's; // not clear if the compiler path should refer to the executable for the; // frontend or the backend. Leave it blank for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:118,Performance,load,loading,118,"// We emit the checksum info for files. This is used by debuggers to; // determine if a pdb matches the source before loading it. Visual Studio,; // for instance, will display a warning that the breakpoints are not valid if; // the pdb does not match the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,Security,checksum,checksum,15,"// We emit the checksum info for files. This is used by debuggers to; // determine if a pdb matches the source before loading it. Visual Studio,; // for instance, will display a warning that the breakpoints are not valid if; // the pdb does not match the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:51,Integrability,rout,routine,51,// Emit an S_THUNK32/S_END symbol pair for a thunk routine.; // The only supported thunk ordinal is currently the standard type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:27,Integrability,rout,routines,27,// Local variables/inlined routines are purposely omitted here. The point of; // marking this as a thunk is so Visual Studio will NOT stop in this routine.; // Emit S_PROC_ID_END,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:147,Integrability,rout,routine,147,// Local variables/inlined routines are purposely omitted here. The point of; // marking this as a thunk is so Visual Studio will NOT stop in this routine.; // Emit S_PROC_ID_END,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:9,Modifiability,variab,variables,9,// Local variables/inlined routines are purposely omitted here. The point of; // marking this as a thunk is so Visual Studio will NOT stop in this routine.; // Emit S_PROC_ID_END,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:10,Modifiability,variab,variable,10,"// If the variable has an attached offset expression, extract it.; // FIXME: Try to handle DW_OP_deref as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:43,Modifiability,variab,variables,43,"// FIXME: Find a way to represent constant variables, since they are; // relatively common.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:29,Modifiability,variab,variables,29,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:55,Modifiability,variab,variables,55,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:130,Modifiability,variab,variables,130,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:390,Modifiability,variab,variable,390,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:280,Performance,load,load,280,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:315,Performance,load,load,315,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:482,Performance,load,load,482,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:59,Performance,load,load,59,// We're using a reference type. Drop the last zero offset load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:48,Performance,load,load,48,// We can only handle a register or an offseted load of a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:44,Modifiability,extend,extend,44,"// If the last range end is our begin, just extend the last range.; // Otherwise make a new range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:12,Modifiability,variab,variable,12,// Grab the variable info that was squirreled away in the MMI side-table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:46,Security,access,accessible,46,"// Instruction ranges, specifying where IV is accessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:14,Safety,safe,safebuffers,14,// __declspec(safebuffers) disables stack guards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:163,Usability,simpl,simpler,163,"// Find the end of the function prolog. First known non-DBG_VALUE and; // non-frame setup location marks the beginning of the function body.; // FIXME: is there a simpler a way to do this? Can we just search; // for the first instruction of the function, not the last of the prolog?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:230,Performance,perform,perform,230,"// TODO: What if the ClosestSubprogram is neither null or the current; // subprogram? Currently, the UDT just gets dropped on the floor.; //; // The current behavior is not desirable. To get maximal fidelity, we would; // need to perform all type translation before beginning emission of .debug$S; // and then make LocalUDTs a member of FunctionInfo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:30,Integrability,depend,depends,30,"// IndexType is size_t, which depends on the bitness of the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:211,Usability,clear,clear,211,"// Forward declarations of arrays without a size and VLAs use a count of -1.; // Emit a count of zero in these cases to match what MSVC does for arrays; // without a size. MSVC doesn't support VLAs, so it's not clear what we; // should do for them even if we could distinguish them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Deployability,Update,Update,3,// Update the element size and element type index for subsequent subranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:30,Integrability,depend,depends,30,"// IndexType is size_t, which depends on the bitness of the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,Usability,simpl,simple,15,"// Pointers to simple types without any options can use SimpleTypeMode, rather; // than having a dedicated pointer type record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:56,Usability,Simpl,SimpleTypeMode,56,"// Pointers to simple types without any options can use SimpleTypeMode, rather; // than having a dedicated pointer type record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:114,Integrability,wrap,wrappers,114,"// Return the base type index if there aren't any modifiers. For example, the; // metadata could contain restrict wrappers around non-pointer types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:28,Security,access,access,28,"// If there was no explicit access control, provide the default for the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:135,Integrability,wrap,wrapped,135,"// An unnamed member may represent a nested struct or union. Attempt to; // interpret the unnamed member as a DICompositeType possibly wrapped in; // qualifier types. Add all the indirect fields to the current record if that; // succeeds, and drop the member if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Integrability,rout,routine,8,// This routine is used by lowerTypeClass and lowerTypeUnion to determine; // if a complete type should be emitted instead of a forward reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:194,Availability,error,error,194,// If this unnamed complete type is already in the process of being defined; // then the description of the type is malformed and cannot be emitted; // into CodeView correctly so report a fatal error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:120,Availability,avail,available,120,"// First, construct the forward decl. Don't look into Ty to compute the; // forward decl options, since it might not be available in all TUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:22,Security,access,accessor,22,"// FIXME: Despite the accessor name, the offset is really in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:50,Security,hash,hash,50,// The null DIType is the void type. Don't try to hash it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:167,Deployability,update,update,167,// Check if we've already translated this type. Don't try to do a; // get-or-create style insertion that caches the hash lookup across the; // lowerType call. It will update the TypeIndices map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:105,Performance,cache,caches,105,// Check if we've already translated this type. Don't try to do a; // get-or-create style insertion that caches the hash lookup across the; // lowerType call. It will update the TypeIndices map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:116,Security,hash,hash,116,// Check if we've already translated this type. Don't try to do a; // get-or-create style insertion that caches the hash lookup across the; // lowerType call. It will update the TypeIndices map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:50,Security,hash,hash,50,// The null DIType is the void type. Don't try to hash it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Deployability,Update,Update,3,// Update the type index associated with this CompositeType. This cannot; // use the 'InsertResult' iterator above because it is potentially; // invalidated by map insertions which can occur while lowering the class; // type above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Modifiability,variab,variables,8,// Emit variables local to this lexical block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:16,Integrability,rout,routine,16,/// Convenience routine for collecting lexical block information for a list; /// of lexical scopes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:42,Modifiability,variab,variable,42,/// Populate the lexical blocks and local variable lists of the parent with; /// information about the specified lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:62,Modifiability,variab,variables,62,"// Gather information about the lexical scope including local variables,; // global variables, and address ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:84,Modifiability,variab,variables,84,"// Gather information about the lexical scope including local variables,; // global variables, and address ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:46,Modifiability,variab,variables,46,// Ignore lexical scopes which do not contain variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:546,Integrability,rout,routine,546,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:609,Integrability,rout,routine,609,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:374,Modifiability,variab,variables,374,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:673,Modifiability,variab,variables,673,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:60,Energy Efficiency,reduce,reduce,60,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:129,Modifiability,variab,variable,129,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:21,Safety,safe,safely,21,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:41,Modifiability,variab,variables,41,// Create a lexical block containing the variables and collect the; // lexical block information for the children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:54,Integrability,rout,routine,54,// Build the lexical block structure to emit for this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:124,Integrability,rout,routine,124,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:183,Integrability,rout,routine,183,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:23,Modifiability,variab,variable,23,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Usability,Clear,Clear,3,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:229,Integrability,depend,depending,229,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:99,Performance,optimiz,optimized,99,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Usability,Usab,Usable,3,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:72,Safety,avoid,avoid,72,"// MSVC does not pad out symbol records to four bytes, but LLVM does to avoid; // an extra copy of every symbol record in LLD. This increases object file; // size by less than 1% in the clang build, and is compatible with the Visual; // C++ linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:38,Modifiability,variab,variable,38,// Record the constant offset for the variable.; //; // A Fortran common block uses this idiom to encode the offset; // of a variable from the common block's starting address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:125,Modifiability,variab,variable,125,// Record the constant offset for the variable.; //; // A Fortran common block uses this idiom to encode the offset; // of a variable from the common block's starting address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:24,Modifiability,variab,variables,24,// Emit constant global variables in a global symbol section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:19,Modifiability,variab,variable,19,"// Locate a global variable list for this scope, creating one if; // necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variable,20,// Emit this global variable into a COMDAT section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variable,20,// Emit this global variable in a single global symbol section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variable,20,// Emit each global variable in the specified array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variables,20,"// For static local variables and Fortran, the scoping portion is elided; // in its name so that we can reference the variable in the command line; // of the VS debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:118,Modifiability,variab,variable,118,"// For static local variables and Fortran, the scoping portion is elided; // in its name so that we can reference the variable in the command line; // of the VS debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:19,Modifiability,variab,variable,19,/// Indicates that variable data is stored in memory relative to the; /// specified register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:14,Modifiability,variab,variable,14,/// Offset of variable data in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:32,Security,hash,hashes,32,/// Whether to emit type record hashes into .debug$H.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:35,Modifiability,variab,variables,35,// Lexical blocks containing local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:20,Energy Efficiency,allocate,allocated,20,/// Number of bytes allocated in the prologue for all local stack objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:100,Modifiability,variab,variables,100,/// Two-bit value indicating which register is the designated frame pointer; /// register for local variables. Included in S_FRAMEPROC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:24,Modifiability,variab,variables,24,// Map used to seperate variables according to the lexical scope they belong; // in. This is populated by recordLocalVariable() before; // collectLexicalBlocks() separates the variables between the FunctionInfo; // and LexicalBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:176,Modifiability,variab,variables,176,// Map used to seperate variables according to the lexical scope they belong; // in. This is populated by recordLocalVariable() before; // collectLexicalBlocks() separates the variables between the FunctionInfo; // and LexicalBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:26,Modifiability,variab,variables,26,// Map to separate global variables according to the lexical scope they; // belong in. A null local scope represents the global scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:19,Modifiability,variab,variables,19,// Array of global variables which need to be emitted into a COMDAT section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:30,Modifiability,variab,variables,30,// Array of non-COMDAT global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:13,Availability,avail,available,13,/// The next available function index for use with our .cv_* directives. Not; /// to be confused with type indices for LF_FUNC_ID records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:116,Usability,simpl,simpler,116,"/// Emits an S_END, S_INLINESITE_END, or S_PROC_ID_END record. These records; /// are empty, so we emit them with a simpler assembly sequence that doesn't; /// involve labels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:42,Integrability,rout,routine,42,"// Construct the lexical block tree for a routine, pruning emptpy lexical; // scopes, and populate it with local variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:113,Modifiability,variab,variables,113,"// Construct the lexical block tree for a routine, pruning emptpy lexical; // scopes, and populate it with local variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:38,Modifiability,variab,variable,38,"/// Records information about a local variable in the appropriate scope. In; /// particular, locals from inlined code live inside the inlining site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:16,Modifiability,variab,variables,16,/// Emits local variables in the appropriate order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:116,Safety,avoid,avoid,116,"/// Symbol records should point to complete types, but type records should; /// always point to incomplete types to avoid cycles in the type graph. Only; /// use this entry point when generating symbol records. The complete and; /// incomplete type indices only differ for record types. All other types use; /// the same index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:152,Modifiability,variab,variable,152,"// We give meta instructions the same ordinal as the preceding instruction; // because this class is written for the task of comparing positions of; // variable location ranges against scope ranges. To reflect what we'll see; // in the binary, when we look at location ranges we must consider all; // DBG_VALUEs between two real instructions at the same position. And a; // scope range which ends on a meta instruction should be considered to end; // at the last seen real instruction. E.g.; //; // 1 instruction p Both the variable location for x and for y start; // 1 DBG_VALUE for ""x"" after instruction p so we give them all the same; // 1 DBG_VALUE for ""y"" number. If a scope range ends at DBG_VALUE for ""y"",; // 2 instruction q we should treat it as ending after instruction p; // because it will be the last real instruction in the; // range. DBG_VALUEs at or after this position for; // variables declared in the scope will have no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:524,Modifiability,variab,variable,524,"// We give meta instructions the same ordinal as the preceding instruction; // because this class is written for the task of comparing positions of; // variable location ranges against scope ranges. To reflect what we'll see; // in the binary, when we look at location ranges we must consider all; // DBG_VALUEs between two real instructions at the same position. And a; // scope range which ends on a meta instruction should be considered to end; // at the last seen real instruction. E.g.; //; // 1 instruction p Both the variable location for x and for y start; // 1 DBG_VALUE for ""x"" after instruction p so we give them all the same; // 1 DBG_VALUE for ""y"" number. If a scope range ends at DBG_VALUE for ""y"",; // 2 instruction q we should treat it as ending after instruction p; // because it will be the last real instruction in the; // range. DBG_VALUEs at or after this position for; // variables declared in the scope will have no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:894,Modifiability,variab,variables,894,"// We give meta instructions the same ordinal as the preceding instruction; // because this class is written for the task of comparing positions of; // variable location ranges against scope ranges. To reflect what we'll see; // in the binary, when we look at location ranges we must consider all; // DBG_VALUEs between two real instructions at the same position. And a; // scope range which ends on a meta instruction should be considered to end; // at the last seen real instruction. E.g.; //; // 1 instruction p Both the variable location for x and for y start; // 1 DBG_VALUE for ""x"" after instruction p so we give them all the same; // 1 DBG_VALUE for ""y"" number. If a scope range ends at DBG_VALUE for ""y"",; // 2 instruction q we should treat it as ending after instruction p; // because it will be the last real instruction in the; // range. DBG_VALUEs at or after this position for; // variables declared in the scope will have no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:75,Modifiability,variab,variable,75,// Instruction range should start with a DBG_VALUE instruction for the; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:58,Modifiability,variab,variable,58,"// If an instruction clobbers multiple registers that the variable is; // described by, then we may have already created a clobbering instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:61,Modifiability,variab,variable,61,// The indices of the entries we're going to remove for each variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:34,Modifiability,variab,variable,34,// Entry reference count for each variable. Clobbers left with no references; // will be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:10,Modifiability,variab,variables,10,"// Ignore variables for non-inlined function level scopes. The scope; // ranges (from scope->getRanges()) will not include any instructions; // before the first one with a debug-location, which could cause us to; // incorrectly drop a location. We could introduce special casing for; // these variables, but it doesn't seem worth it because no out-of-scope; // locations have been observed for variables declared in function level; // scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:293,Modifiability,variab,variables,293,"// Ignore variables for non-inlined function level scopes. The scope; // ranges (from scope->getRanges()) will not include any instructions; // before the first one with a debug-location, which could cause us to; // incorrectly drop a location. We could introduce special casing for; // these variables, but it doesn't seem worth it because no out-of-scope; // locations have been observed for variables declared in function level; // scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:394,Modifiability,variab,variables,394,"// Ignore variables for non-inlined function level scopes. The scope; // ranges (from scope->getRanges()) will not include any instructions; // before the first one with a debug-location, which could cause us to; // incorrectly drop a location. We could introduce special casing for; // these variables, but it doesn't seem worth it because no out-of-scope; // locations have been observed for variables declared in function level; // scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:32,Modifiability,variab,variable,32,// If there is no scope for the variable then something has probably gone; // wrong.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:92,Modifiability,variab,variable,92,"// Check if the location range [StartMI, EndMI] intersects with any scope; // range for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:51,Deployability,update,update,51,"// Because we'll be removing this entry we need to update the reference; // count of the closing entry, if one exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:51,Modifiability,variab,variable,51,// If there is nothing to remove then jump to next variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:33,Deployability,update,update,33,// Build an offset map so we can update the EndIndex of the remaining; // entries.; // Zero the offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:3,Deployability,Update,Update,3,// Update the EndIndex of the entries to account for those which will be; // removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:34,Modifiability,variab,variable,34,// A DBG_VALUE $noreg is an empty variable location,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:31,Modifiability,variab,variables,31,// Maps physreg numbers to the variables they describe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:220,Modifiability,variab,variable,220,"// If a given register appears in a live DBG_VALUE_LIST for Var alongside the; // clobbered register, and never appears in a live DBG_VALUE* for Var without; // the clobbered register, then it is no longer linked to the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:36,Modifiability,variab,variables,36,// Terminate the location range for variables described by register at; // @I by inserting @ClobberingInstr to their history.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:20,Modifiability,variab,variables,20,"// Iterate over all variables described by this register and add this; // instruction to their history, clobbering it. All registers that also; // describe the clobbered variables (i.e. in variadic debug values) will have; // those Variables removed from their DescribedVars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:170,Modifiability,variab,variables,170,"// Iterate over all variables described by this register and add this; // instruction to their history, clobbering it. All registers that also; // describe the clobbered variables (i.e. in variadic debug values) will have; // those Variables removed from their DescribedVars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:232,Modifiability,Variab,Variables,232,"// Iterate over all variables described by this register and add this; // instruction to their history, clobbering it. All registers that also; // describe the clobbered variables (i.e. in variadic debug values) will have; // those Variables removed from their DescribedVars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:36,Modifiability,variab,variables,36,// Terminate the location range for variables described by register; // @RegNo by inserting @ClobberingInstr to their history.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:16,Modifiability,variab,variable,16,// Use the base variable (without any DW_OP_piece expressions); // as index into History. The full variables including the; // piece expressions are attached to the MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:99,Modifiability,variab,variables,99,// Use the base variable (without any DW_OP_piece expressions); // as index into History. The full variables including the; // piece expressions are attached to the MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:83,Safety,safe,safely,83,// Meta Instructions have no output and do not change any values and so; // can be safely ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:81,Modifiability,variab,variables,81,// Not a DBG_VALUE instruction. It may clobber registers which describe; // some variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:25,Availability,mask,mask,25,"// If this is a register mask operand, clobber all debug values in; // non-CSRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:49,Availability,mask,masks,49,// Don't consider SP to be clobbered by register masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:51,Modifiability,variab,variables,51,"// End instr loop.; // Make sure locations for all variables are valid only until the end of; // the basic block (unless it's the last basic block, in which case let; // their liveness run off to the end of the function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:20,Modifiability,variab,variables,20,// Iterate over all variables that have open debug values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:21,Modifiability,variab,variable,21,"/// If true, we drop variable location ranges which exist entirely outside the; /// variable's lexical scope instruction ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:84,Modifiability,variab,variable,84,"/// If true, we drop variable location ranges which exist entirely outside the; /// variable's lexical scope instruction ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:3,Modifiability,Variab,Variables,3,// Variables calculated from multiple locations can't be represented here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:153,Integrability,inject,inject,153,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:370,Safety,avoid,avoid,370,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:153,Security,inject,inject,153,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:31,Modifiability,variab,variables,31,// Calculate history for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:170,Energy Efficiency,reduce,reduces,170,"// We need a label after this instruction. With basic block sections, just; // use the end symbol of the section if this is the last instruction of the; // section. This reduces the need for an additional label and also helps; // merging ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:43,Modifiability,variab,variable,43,"/// A single location or constant within a variable location description, with; /// either a single entry (with an optional DIExpression) used for a DBG_VALUE,; /// or a list of entries used for a DBG_VALUE_LIST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:29,Modifiability,variab,variable,29,"/// The location of a single variable, composed of an expression and 0 or more; /// DbgValueLocEntries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:134,Modifiability,variab,variable,134,"/// Create a location list entry for the range [\p Begin, \p End).; ///; /// \param Vals One or more values describing (parts of) the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:44,Modifiability,variab,variable,44,"// If this and Next are describing the same variable, merge them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h:126,Modifiability,variab,variable,126,"/// Byte stream of .debug_loc entries.; ///; /// Stores a unified stream of .debug_loc entries. There's \a List for each; /// variable/inlined-at pair, and an \a Entry for each \a DebugLocEntry.; ///; /// FIXME: Do we need all these temp symbols?; /// FIXME: Why not output directly to the output stream?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp:102,Availability,down,down,102,"// Could be an assertion, but this way we can see the failing form code; // easily, which helps track down where it came from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp:15,Testability,assert,assertion,15,"// Could be an assertion, but this way we can see the failing form code; // easily, which helps track down where it came from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,Security,Hash,Hashing,41,"//===-- llvm/CodeGen/DIEHash.cpp - Dwarf Hashing Framework ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:421,Security,hash,hashing,421,"//===-- llvm/CodeGen/DIEHash.cpp - Dwarf Hashing Framework ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:37,Security,hash,hash,37,/// Adds the string in \p Str to the hash. This also hashes; /// a trailing NULL with the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:53,Security,hash,hashes,53,/// Adds the string in \p Str to the hash. This also hashes; /// a trailing NULL with the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:21,Integrability,rout,routines,21,// FIXME: The LEB128 routines are copied and only slightly modified out of; // LEB128.h.; /// Adds the unsigned in \p Value to the hash encoded as a ULEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:131,Security,hash,hash,131,// FIXME: The LEB128 routines are copied and only slightly modified out of; // LEB128.h.; /// Adds the unsigned in \p Value to the hash encoded as a ULEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:58,Security,hash,hash,58,/// Including \p Parent adds the context of Parent to the hash..,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,Security,hash,hashed,41,"// a) If T is in the list of [previously hashed types], use the letter; // 'R' as the marker",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:109,Security,hash,hash,109,"// and the referenced type (via the [below attributes]); // FIXME: This seems overly restrictive, and causes hash mismatches; // there's a decl/def difference in the containing type of a; // ptr_to_member_type, but it's what DWARF says, for some reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,Performance,perform,performing,41,"// ... process the type T recursively by performing Steps 2 through 7, and; // use the result as the attribute value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash all of the values in a block like set of values. This assumes that; // all of the data is going to be added as integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash the contents of a loclistptr class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash an individual attribute \param Attr based on the type of attribute and; // the form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:115,Security,hash,hash,115,"// We could add the block length, but that would take; // a bit of work and not add a lot of uniqueness; // to the hash in some way we could test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:141,Testability,test,test,141,"// We could add the block length, but that would take; // a bit of work and not add a lot of uniqueness; // to the hash in some way we could test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:88,Security,hash,hash,88,// Go through the attributes from \param Attrs in the order specified in 7.27.4; // and hash them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:18,Modifiability,extend,extended,18,// FIXME: Add the extended attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:51,Security,hash,hash,51,// Add all of the attributes for \param Die to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:15,Security,hash,hash,15,// Compute the hash of a DIE. This is based on the type signature computation; // given in section 7.27 of the DWARF4 standard. It is the md5 hash of a; // flattened description of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:142,Security,hash,hash,142,// Compute the hash of a DIE. This is based on the type signature computation; // given in section 7.27 of the DWARF4 standard. It is the md5 hash of a; // flattened description of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:8,Security,hash,hash,8,// Then hash each of the children of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:116,Security,hash,hash,116,/// This is based on the type signature computation given in section 7.27 of the; /// DWARF4 standard. It is an md5 hash of the flattened description of the DIE; /// with the inclusion of the full CU and all top level CU entities.; // TODO: Initialize the type chain at 0 instead of 1 for CU signatures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:116,Security,hash,hash,116,/// This is based on the type signature computation given in section 7.27 of the; /// DWARF4 standard. It is an md5 hash of the flattened description of the DIE; /// with the inclusion of additional forms not specifically called out in the; /// standard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:39,Security,Hash,Hashing,39,"//===-- llvm/CodeGen/DIEHash.h - Dwarf Hashing Framework -------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:421,Security,hash,hashing,421,"//===-- llvm/CodeGen/DIEHash.h - Dwarf Hashing Framework -------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:43,Security,hash,hashing,43,/// An object containing the capability of hashing and adding hash; /// attributes onto a DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:62,Security,hash,hash,62,/// An object containing the capability of hashing and adding hash; /// attributes onto a DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:40,Security,hash,hashing,40,// Collection of all attributes used in hashing a particular DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:10,Integrability,rout,routines,10,// Helper routines to process parts of a DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:52,Security,hash,hash,52,/// Adds the parent context of \param Parent to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:45,Security,hash,hash,45,/// Adds the attributes of \param Die to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:34,Security,hash,hash,34,/// Computes the full DWARF4 7.27 hash of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:3,Integrability,Rout,Routines,3,// Routines that add DIEValues to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:38,Security,hash,hash,38,// Routines that add DIEValues to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:29,Security,hash,hash,29,/// Adds \param Value to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:41,Security,hash,hash,41,/// Encodes and adds \param Value to the hash as a ULEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:41,Security,hash,hash,41,/// Encodes and adds \param Value to the hash as a SLEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:27,Security,hash,hash,27,/// Adds \param Str to the hash and includes a NULL byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes the attributes in \param Attrs in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,"/// Hashes the data in a block like DIEValue, e.g. DW_FORM_block or; /// DW_FORM_exprloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes the contents pointed to in the .debug_loc section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes an individual attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes an attribute that refers to another DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes a reference to a named type in such a way that is; /// independent of whether that type is described by a declaration or a; /// definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes a reference to a previously referenced type DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp:24,Integrability,rout,routine,24,"// Indicate personality routine, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:12,Modifiability,extend,extended,12,// Could be extended to work with DWARFv4 Split DWARF if that's important for; // someone. In that case DW_FORM_data would be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:223,Modifiability,extend,extend,223,"// If we print assembly, we can't separate .file entries according to; // compile units. Thus all files will belong to the default compile unit.; // FIXME: add a better feature test than hasRawTextSupport. Even better,; // extend .file to support this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:177,Testability,test,test,177,"// If we print assembly, we can't separate .file entries according to; // compile units. Thus all files will belong to the default compile unit.; // FIXME: add a better feature test than hasRawTextSupport. Even better,; // extend .file to support this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:17,Modifiability,variab,variable,17,"// If the global variable's type is different from the one in the class; // member type, assume that it's more specific and also emit it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:50,Modifiability,variab,variables,50,// We cannot describe the location of dllimport'd variables: the; // computation of their address requires loads from the IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:107,Performance,load,loads,107,// We cannot describe the location of dllimport'd variables: the; // computation of their address requires loads from the IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:73,Testability,assert,assert,73,"// 16-bit platforms like MSP430 and AVR take this path, so sink this; // assert to platforms that use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:160,Modifiability,variab,variables,160,"// FIXME This is not guaranteed, but in practice, in static linking,; // if present, __tls_base's index is 1. This doesn't hold for dynamic; // linking, so TLS variables used in dynamic linking won't have; // correct debug info for now. See; // https://github.com/llvm/llvm-project/blob/19afbfe33156d211fa959dadeea46cd17b9c723c/lld/wasm/Driver.cpp#L786-L823",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:51,Modifiability,variab,variable,51,// 2) containing the (relocated) offset of the TLS variable; // within the module's TLS block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:10,Modifiability,variab,variables,10,"// Global variables attached to symbols are memory locations.; // It would be better if this were unconditional, but malformed input that; // mixes non-fragments and fragments for the same variable is too expensive; // to detect in the verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:189,Modifiability,variab,variable,189,"// Global variables attached to symbols are memory locations.; // It would be better if this were unconditional, but malformed input that; // mixes non-fragments and fragments for the same variable is too expensive; // to detect in the verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:222,Safety,detect,detect,222,"// Global variables attached to symbols are memory locations.; // It would be better if this were unconditional, but malformed input that; // mixes non-fragments and fragments for the same variable is too expensive; // to detect in the verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:239,Modifiability,extend,extend,239,"// If we have no current ranges just add the range and return, otherwise,; // check the current section and CU against the previous section and CU we; // emitted into and the subprogram was contained within. If these are the; // same then extend our current range, otherwise add this as a new range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:77,Integrability,depend,depend,77,// FIXME: duplicated from Target/WebAssembly/WebAssembly.h; // don't want to depend on target specific headers in this code?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:39,Safety,avoid,avoid,39,"// FIXME: when writing dwo, we need to avoid relocations. Probably; // the ""right"" solution is to treat globals the way func and data; // symbols are (with entries in .debug_addr).; // For now we hardcode the indices in the callsites. Global indices are not; // fixed, but in practice a few are fixed; for example, __stack_pointer is; // always index 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:127,Modifiability,variab,variables,127,// Find DIE for the given subprogram and attach appropriate DW_AT_low_pc; // and DW_AT_high_pc attributes. If there are global variables in this; // scope then create and insert DIEs for these variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:193,Modifiability,variab,variables,193,// Find DIE for the given subprogram and attach appropriate DW_AT_low_pc; // and DW_AT_high_pc attributes. If there are global variables in this; // scope then create and insert DIEs for these variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:292,Integrability,depend,depends,292,"// Basic block sections allows basic block subsets to be placed in unique; // sections. For each section, the begin and end label must be added to the; // list. If there is more than one range, debug ranges must be used.; // Otherwise, low/high PC can be used.; // FIXME: Debug Info Emission depends on block order and this assumes that; // the order of blocks will be frozen beyond this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:12,Modifiability,variab,variables,12,"// Abstract variables don't get common attributes later, so apply them now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:15,Modifiability,variab,variables,15,/// Sort local variables so that variables appearing inside of helper; /// expressions come first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:33,Modifiability,variab,variables,33,/// Sort local variables so that variables appearing inside of helper; /// expressions come first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:13,Safety,detect,detection,13,// For cycle detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:3,Performance,Perform,Perform,3,// Perform a stable topological sort by doing a DFS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:24,Integrability,depend,dependencies,24,// Add to Result if all dependencies are visited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:3,Safety,Detect,Detect,3,// Detect cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:8,Integrability,depend,dependencies,8,"// Push dependencies and this node onto the worklist, so that this node is; // visited again after all of its dependencies are handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:110,Integrability,depend,dependencies,110,"// Push dependencies and this node onto the worklist, so that this node is; // visited again after all of its dependencies are handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:13,Integrability,depend,dependency,13,// Don't add dependency if it is in a different lexical scope or a global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:97,Modifiability,variab,variable,97,// Collect lexical scope children first.; // ObjectPointer might be a local (non-argument) local variable if it's a; // block's synthetic this pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:14,Modifiability,variab,variables,14,// Emit local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:251,Modifiability,refactor,refactored,251,"// Some of this is duplicated from DwarfUnit::getOrCreateSubprogramDIE, with; // the important distinction that the debug node is not associated with the; // DIE (since the debug node will be associated with the concrete DIE, if; // any). It could be refactored to some common utility function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:299,Testability,log,logic,299,"// Attach the return PC to allow the debugger to disambiguate call paths; // from one function to another.; //; // The return PC is only really needed when the call /isn't/ a tail call, but; // GDB expects it in DWARF4 mode, even for tail calls (see the comment above; // the DW_AT_call_pc emission logic for an explanation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:62,Modifiability,variab,variables,62,// This is for imported module with renamed entities (such as variables and; // subprograms).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:128,Modifiability,variab,variable,128,"/// Start with the address based on the location provided, and generate the; /// DWARF information necessary to find the actual variable given the extra; /// address information encoded in the DbgVariable, starting from the starting; /// location. Add the DWARF information to the die.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:140,Modifiability,Variab,VariableDie,140,"/// \anchor applyConcreteDbgVariableAttribute; /// \name applyConcreteDbgVariableAttribute; /// Overload set which applies attributes to \c VariableDie based on; /// the active variant of \c DV, which is passed as the first argument.; ///@{; /// See \ref applyConcreteDbgVariableAttribute",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:25,Modifiability,variab,variable,25,/// Get or create global variable DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:134,Modifiability,variab,variables,134,/// Find DIE for the given subprogram and attach appropriate; /// DW_AT_low_pc and DW_AT_high_pc attributes. If there are global; /// variables in this scope then create and insert DIEs for these; /// variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:201,Modifiability,variab,variables,201,/// Find DIE for the given subprogram and attach appropriate; /// DW_AT_low_pc and DW_AT_high_pc attributes. If there are global; /// variables in this scope then create and insert DIEs for these; /// variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:136,Availability,error,error,136,"/// Get a DIE for the given DILexicalBlock.; /// Note that this function assumes that the DIE has been already created; /// and it's an error, if it hasn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:66,Modifiability,variab,variable,66,/// Convenience overload which writes the DIE pointer into an out variable; /// ObjectPointer in addition to returning it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:18,Modifiability,variab,variable,18,/// Find abstract variable associated with Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:128,Modifiability,variab,variable,128,"/// Start with the address based on the location provided, and generate the; /// DWARF information necessary to find the actual variable (navigating the; /// extra location information encoded in the type) based on the starting; /// location. Add the DWARF information to the die.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:116,Integrability,depend,dependant,116,"/// Add attributes to \p Var which reflect the common attributes of \p; /// VariableDie, namely those which are not dependant on the active variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:76,Modifiability,Variab,VariableDie,76,"/// Add attributes to \p Var which reflect the common attributes of \p; /// VariableDie, namely those which are not dependant on the active variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:27,Availability,avail,available,27,// This information is not available while emitting .debug_loc entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Safety,Avoid,Avoid,3,// Avoid building the original CU if it won't be used,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiple DW_OP_stack_values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:21,Performance,load,loaded,21,/// Interpret values loaded into registers by \p CurMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:524,Integrability,depend,dependent,524,"// If an instruction defines more than one item in the worklist, we may run; // into situations where a worklist register's value is (potentially); // described by the previous value of another register that is also defined; // by that instruction.; //; // This can for example occur in cases like this:; //; // $r1 = mov 123; // $r0, $r1 = mvrr $r1, 456; // call @foo, $r0, $r1; //; // When describing $r1's value for the mvrr instruction, we need to make sure; // that we don't finalize an entry value for $r0, as that is dependent on the; // previous value of $r1 (123 rather than 456).; //; // In order to not have to distinguish between those cases when finalizing; // entry values, we simply postpone adding new parameter registers to the; // worklist, by first keeping them in this temporary container until the; // instruction has been handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:691,Usability,simpl,simply,691,"// If an instruction defines more than one item in the worklist, we may run; // into situations where a worklist register's value is (potentially); // described by the previous value of another register that is also defined; // by that instruction.; //; // This can for example occur in cases like this:; //; // $r1 = mov 123; // $r0, $r1 = mvrr $r1, 456; // call @foo, $r0, $r1; //; // When describing $r1's value for the mvrr instruction, we need to make sure; // that we don't finalize an entry value for $r0, as that is dependent on the; // previous value of $r1 (123 rather than 456).; //; // In order to not have to distinguish between those cases when finalizing; // entry values, we simply postpone adding new parameter registers to the; // worklist, by first keeping them in this temporary container until the; // instruction has been handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:129,Testability,Test,Test,129,"// It's possible that we find a copy from a non-volatile register to the param; // register, which is clobbered in the meantime. Test for clobbered reg unit; // overlaps before completing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:132,Integrability,depend,dependent,132,"// ParamFwdReg was described by the non-callee saved register; // RegLoc. Mark that the call site values for the parameters are; // dependent on that register instead of ParamFwdReg. Since RegLoc; // may be a register that will be handled in this iteration, we; // postpone adding the items to the worklist, and instead keep them; // in a temporary container.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Safety,Avoid,Avoid,3,// Avoid NOP description.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:28,Performance,load,loaded,28,/// Try to interpret values loaded into registers that forward parameters; /// for \p CallMI. Store parameters with interpreted value into \p Params.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:112,Performance,load,loaded,112,"// We erase, from the ForwardedRegWorklist, those forwarding registers for; // which we successfully describe a loaded value (by using; // the describeLoadedValue()). For those remaining arguments in the working; // list, for which we do not describe a loaded value by; // the describeLoadedValue(), we try to generate an entry value expression; // for their call site value description, if the call is within the entry MBB.; // TODO: Handle situations when call site parameter value can be described; // as the entry value within basic blocks other than the first one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:253,Performance,load,loaded,253,"// We erase, from the ForwardedRegWorklist, those forwarding registers for; // which we successfully describe a loaded value (by using; // the describeLoadedValue()). For those remaining arguments in the working; // list, for which we do not describe a loaded value by; // the describeLoadedValue(), we try to generate an entry value expression; // for their call site value description, if the call is within the entry MBB.; // TODO: Handle situations when call site parameter value can be described; // as the entry value within basic blocks other than the first one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:16,Performance,load,loading,16,// Search for a loading value in forwarding registers inside call delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:26,Performance,load,loaded,26,// Try to interpret value loaded by instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:16,Performance,load,loading,16,// Search for a loading value in forwarding registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:27,Performance,load,loaded,27,// Try to interpret values loaded by instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:224,Performance,optimiz,optimized-out,224,// Use DW_AT_call_all_calls to express that call site entries are present; // for both tail and non-tail calls. Don't use DW_AT_call_all_source_calls; // because one of its requirements is not met: call site entries for; // optimized-out calls are elided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:52,Testability,test,test,52,// Bundles with call in them will pass the isCall() test below but do not; // have callee operand information so skip them here. Iterator will; // eventually reach the call MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:84,Safety,avoid,avoid,84,"// LTO with assembly output shares a single line table amongst multiple CUs.; // To avoid the compilation directory being ambiguous, let the line table; // explicitly describe the directory of all files, never relying on the; // compilation directory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:10,Modifiability,Variab,Variables,10,// Global Variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:101,Modifiability,variab,variable,101,// Don't bother adding DIGlobalVariableExpressions listed in the CU if we; // already know about the variable and it isn't adding a constant; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:171,Usability,simpl,simple,171,"// FIXME: Consider the time-space tradeoff of just storing the unit pointer; // in the ConcreteEntities list, rather than looking it up again here.; // DIE::getUnit isn't simple - it walks parent pointers, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:36,Security,hash,hash,36,// Include the DWO file name in the hash if there's more than one CU.; // This handles ThinLTO's situation where imported CUs may very easily be; // duplicate with the same CU partially imported into another ThinLTO unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:42,Usability,clear,clear,42,// clean up.; // FIXME: AbstractVariables.clear();,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:11,Modifiability,variab,variable,11,// Collect variable information from side table maintained by MF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:48,Modifiability,variab,variable,48,"// If we have already seen information for this variable, add to what we; // already know.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:52,Performance,optimiz,optimized,52,"// Locations differ, this should (rarely) happen in optimized async; // coroutines.; // Prefer whichever location has an EntryValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Testability,Test,Test,3,// Test if the location terminates before the end of the scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:661,Integrability,depend,depending,661,"/// Build the location list for all DBG_VALUEs in the function that; /// describe the same variable. The resulting DebugLocEntries will have; /// strict monotonically increasing begin addresses and will never; /// overlap. If the resulting list has only one entry that is valid; /// throughout variable's scope return true.; //; // See the definition of DbgValueHistoryMap::Entry for an explanation of the; // different kinds of history map entries. One thing to be aware of is that if; // a debug value is ended by another entry (rather than being valid until the; // end of the function), that entry's instruction may or may not be included in; // the range, depending on if the entry is a clobbering entry (it has an; // instruction that clobbers one or more preceding locations), or if it is an; // (overlapping) debug value entry. This distinction can be seen in the example; // below. The first debug value is ended by the clobbering entry 2, and the; // second and third debug values are ended by the overlapping debug value entry; // 4.; //; // Input:; //; // History map entries [type, end index, mi]; //; // 0 | [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]; // 1 | | [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]; // 2 | | [Clobber, $reg0 = [...], -, -]; // 3 | | [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]; // 4 [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]; //; // Output [start, end) [Value...]:; //; // [0-1) [(reg0, fragment 0, 32)]; // [1-3) [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]; // [3-4) [(reg1, fragment 32, 32), (123, fragment 64, 32)]; // [4-) [(@g, fragment 0, 96)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:91,Modifiability,variab,variable,91,"/// Build the location list for all DBG_VALUEs in the function that; /// describe the same variable. The resulting DebugLocEntries will have; /// strict monotonically increasing begin addresses and will never; /// overlap. If the resulting list has only one entry that is valid; /// throughout variable's scope return true.; //; // See the definition of DbgValueHistoryMap::Entry for an explanation of the; // different kinds of history map entries. One thing to be aware of is that if; // a debug value is ended by another entry (rather than being valid until the; // end of the function), that entry's instruction may or may not be included in; // the range, depending on if the entry is a clobbering entry (it has an; // instruction that clobbers one or more preceding locations), or if it is an; // (overlapping) debug value entry. This distinction can be seen in the example; // below. The first debug value is ended by the clobbering entry 2, and the; // second and third debug values are ended by the overlapping debug value entry; // 4.; //; // Input:; //; // History map entries [type, end index, mi]; //; // 0 | [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]; // 1 | | [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]; // 2 | | [Clobber, $reg0 = [...], -, -]; // 3 | | [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]; // 4 [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]; //; // Output [start, end) [Value...]:; //; // [0-1) [(reg0, fragment 0, 32)]; // [1-3) [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]; // [3-4) [(reg1, fragment 32, 32), (123, fragment 64, 32)]; // [4-) [(@g, fragment 0, 96)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:294,Modifiability,variab,variable,294,"/// Build the location list for all DBG_VALUEs in the function that; /// describe the same variable. The resulting DebugLocEntries will have; /// strict monotonically increasing begin addresses and will never; /// overlap. If the resulting list has only one entry that is valid; /// throughout variable's scope return true.; //; // See the definition of DbgValueHistoryMap::Entry for an explanation of the; // different kinds of history map entries. One thing to be aware of is that if; // a debug value is ended by another entry (rather than being valid until the; // end of the function), that entry's instruction may or may not be included in; // the range, depending on if the entry is a clobbering entry (it has an; // instruction that clobbers one or more preceding locations), or if it is an; // (overlapping) debug value entry. This distinction can be seen in the example; // below. The first debug value is ended by the clobbering entry 2, and the; // second and third debug values are ended by the overlapping debug value entry; // 4.; //; // Input:; //; // History map entries [type, end index, mi]; //; // 0 | [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]; // 1 | | [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]; // 2 | | [Clobber, $reg0 = [...], -, -]; // 3 | | [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]; // 4 [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]; //; // Output [start, end) [Value...]:; //; // [0-1) [(reg0, fragment 0, 32)]; // [1-3) [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]; // [3-4) [(reg1, fragment 32, 32), (123, fragment 64, 32)]; // [4-) [(@g, fragment 0, 96)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Availability,redundant,redundant,46,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:366,Availability,redundant,redundant,366,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Safety,redund,redundant,46,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:366,Safety,redund,redundant,366,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:62,Availability,redundant,redundant,62,"// Location list entries with empty location descriptions are redundant; // information in DWARF, so do not emit those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:62,Safety,redund,redundant,62,"// Location list entries with empty location descriptions are redundant; // information in DWARF, so do not emit those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:8,Modifiability,variab,variables,8,// Find variables for each lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:12,Modifiability,variab,variable,12,// Grab the variable info that was squirreled away in the MMI side-table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Security,access,accessible,46,"// Instruction ranges, specifying where IV is accessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:29,Modifiability,variab,variable,29,// Try to find any non-empty variable location. Do not create a concrete; // entity if there are no locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:57,Modifiability,variab,variable,57,// Handle multiple DBG_VALUE instructions describing one variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:36,Modifiability,variab,variable,36,// Build the location list for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:106,Modifiability,variab,variable,106,"// Check whether buildLocationList managed to merge all locations to one; // that is valid throughout the variable's scope. If so, produce single; // value location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:10,Modifiability,variab,variable,10,"// If the variable has a DIBasicType, extract it. Basic types cannot have; // unique identifiers, so don't bother resolving the type with the; // identifier map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:42,Deployability,update,update,42,"// When we emit a line-0 record, we don't update PrevInstLoc; so look at; // the last line number actually emitted, to see if it was line 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:347,Modifiability,inherit,inherit,347,"// See if we have a reason to emit a line-0 record now.; // Reasons to emit a line-0 record include:; // - User asked for it (UnknownLocations).; // - Instruction has a label, so it's referenced from somewhere else,; // possibly debug information; we want it to have a source location.; // - Instruction is at the top of a block; we don't want to inherit the; // location from the physically previous (maybe unrelated) block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:108,Deployability,update,update,108,"// Preserve the file and column numbers, if we can, to save space in; // the encoded line table.; // Do not update PrevInstLoc, it remembers the last non-0 line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:133,Testability,test,testing,133,"// We'd like to list the prologue as ""not statements"" but GDB behaves; // poorly if we do that. Revisit this with caution/GDB (7.5+) testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:20,Modifiability,variab,variables,20,// Collect info for variables/labels that were optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:47,Performance,optimiz,optimized,47,// Collect info for variables/labels that were optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Usability,Clear,Clear,3,// Clear debug info; // Ownership of DbgVariables is a bit subtle - ScopeVariables owns all the; // DbgVariables except those that are also in AbstractVariables (since they; // can be used cross-function),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:29,Security,hash,hashed,29,// Emit visible names into a hashed accelerator table section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:50,Security,hash,hashed,50,// Emit objective C classes and categories into a hashed accelerator table; // section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:30,Security,hash,hashed,30,// Emit namespace dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:25,Security,hash,hashed,25,// Emit type dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Modifiability,variab,variable,46,// Emit all fragments that belong to the same variable and range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:178,Integrability,depend,dependent,178,"// Fast path if we're building some type units and one has already used the; // address pool we know we're going to throw away all this work anyway, so; // don't bother building dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:116,Integrability,depend,dependent,116,// Remove all the types built while building this type.; // This is pessimistic as some of these types might not be dependent on; // the type that used an address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:83,Integrability,depend,dependent,83,"// Construct this type in the CU directly.; // This is inefficient because all the dependent types will be rebuilt; // from scratch, including building them in type units, discovering that; // they depend on addresses, throwing them out and rebuilding them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:198,Integrability,depend,depend,198,"// Construct this type in the CU directly.; // This is inefficient because all the dependent types will be rebuilt; // from scratch, including building them in type units, discovering that; // they depend on addresses, throwing them out and rebuilding them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:22,Integrability,depend,dependent,22,"// If the type wasn't dependent on fission addresses, finish adding the type; // and all its dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:93,Integrability,depend,dependent,93,"// If the type wasn't dependent on fission addresses, finish adding the type; // and all its dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:22,Security,checksum,checksum,22,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:82,Security,validat,validates,82,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:96,Security,checksum,checksum,96,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:140,Security,checksum,checksum,140,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:190,Modifiability,polymorphi,polymorphism,190,//===----------------------------------------------------------------------===//; /// This class is defined as the common parent of DbgVariable and DbgLabel; /// such that it could levarage polymorphism to extract common code for; /// DbgVariable and DbgLabel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:69,Modifiability,variab,variable,69,"// Add the pair Reg, Expr to the list of entry values describing the variable.; // If multiple expressions are added, it is the callers responsibility to; // ensure they are all non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:138,Modifiability,variab,variable,138,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:170,Modifiability,Variab,Variables,170,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:370,Modifiability,Variab,Variables,370,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:471,Modifiability,variab,variables,471,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:584,Modifiability,Variab,Variables,584,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:706,Modifiability,variab,variables,706,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:852,Modifiability,Variab,Variables,852,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:195,Performance,optimiz,optimized,195,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:149,Security,expose,expose,149,"/// To workaround P2162R0 https://github.com/cplusplus/papers/issues/873 the; /// base class subobject needs to be passed directly to std::visit, so expose; /// it directly here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Testability,Assert,Asserting,4,"/// Asserting, noexcept member alternative to std::get",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Testability,Assert,Asserting,4,"/// Asserting, noexcept member alternative to std::get",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:49,Modifiability,variab,variable,49,/// Construct a DbgVariable.; ///; /// Creates a variable without any DW_AT_location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:22,Energy Efficiency,allocate,allocated,22,/// All DIEValues are allocated through this allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:27,Modifiability,variab,variables,27,/// Collection of abstract variables/labels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:10,Performance,optimiz,optimization,10,"/// As an optimization, there is no need to emit an entry in the directory; /// table for the same directory as DW_AT_comp_dir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:84,Security,expose,exposed,84,/// Holders for the various debug information flags that we might need to; /// have exposed. See accessor functions below for description.; /// Map from MDNodes for user-defined types to their type signatures. Also; /// used to keep track of which types we have emitted type units for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:97,Security,access,accessor,97,/// Holders for the various debug information flags that we might need to; /// have exposed. See accessor functions below for description.; /// Map from MDNodes for user-defined types to their type signatures. Also; /// used to keep track of which types we have emitted type units for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Safety,Avoid,Avoid,4,/// Avoid using DW_OP_convert due to consumer incompatibilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:102,Testability,test,testing,102,/// Enable production of call site parameters needed to print the debug entry; /// values. Useful for testing purposes when a debugger does not support the; /// feature yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:20,Modifiability,Variab,Variables,20,"/// Separated Dwarf Variables; /// In general these will all be for bits that are left in the; /// original object file, rather than things that are meant; /// to be in the .dwo sections.; /// Holder for the skeleton information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:30,Security,hash,hashed,30,/// Emit visible names into a hashed accelerator table section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:51,Security,hash,hashed,51,/// Emit objective C classes and categories into a hashed; /// accelerator table section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:31,Security,hash,hashed,31,/// Emit namespace dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:26,Security,hash,hashed,26,/// Emit type dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:9,Modifiability,variab,variable,9,/// Emit variable locations into a debug loc section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:9,Modifiability,variab,variable,9,/// Emit variable locations into a debug loc dwo section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:39,Modifiability,variab,variables,39,/// Populate LexicalScope entries with variables' info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:91,Modifiability,variab,variable,91,/// Build the location list for all DBG_VALUEs in the; /// function that describe the same variable. If the resulting; /// list has only one entry that is valid for entire variable's; /// scope return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:172,Modifiability,variab,variable,172,/// Build the location list for all DBG_VALUEs in the; /// function that describe the same variable. If the resulting; /// list has only one entry that is valid for entire variable's; /// scope return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:12,Modifiability,variab,variable,12,/// Collect variable information from the side table maintained by MF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Performance,Perform,Perform,4,/// Perform an MD5 checksum of \p Identifier and return the lower 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:19,Security,checksum,checksum,19,/// Perform an MD5 checksum of \p Identifier and return the lower 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:78,Energy Efficiency,reduce,reduce,78,// Returns whether novel exprloc addrx+offset encodings should be used to; // reduce debug_addr size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:70,Energy Efficiency,reduce,reduce,70,// Returns whether addrx+offset LLVM extension form should be used to reduce; // debug_addr size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:43,Deployability,update,updated,43,/// Returns the previous CU that was being updated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:43,Performance,tune,tune,43,"/// \defgroup DebuggerTuning Predicates to tune DWARF for a given debugger.; ///; /// Returns whether we are ""tuning"" for a given debugger.; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:71,Energy Efficiency,allocate,allocated,71,"/// If the \p File has an MD5 checksum, return it as an MD5Result; /// allocated in the MCContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:30,Security,checksum,checksum,30,"/// If the \p File has an MD5 checksum, return it as an MD5Result; /// allocated in the MCContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:91,Availability,redundant,redundant,91,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:76,Safety,avoid,avoid,76,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:91,Safety,redund,redundant,91,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:94,Performance,perform,perform,94,"// The loop below is emitting the value starting at least significant byte,; // so we need to perform a byte-swap to get the byte order correct in case; // of a big-endian target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:110,Safety,safe,safely,110,"// If the register can only be described by a complex expression (i.e.,; // multiple subregisters) it doesn't safely compose with another complex; // expression. For example, it is not possible to apply a DW_OP_deref; // operation to multiple DW_OP_pieces, since composite location descriptions; // do not push anything on the DWARF stack.; //; // DW_OP_entry_value operations can only hold a DWARF expression or a; // register location description, so we can't emit a single entry value; // covering a composite location description. In the future we may want to; // emit entry value operations for each register location in the composite; // location, but until that is supported do not emit anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:10,Usability,simpl,simple,10,"// Handle simple register locations. If we are supposed to emit; // a call site parameter expression and if that expression is just a register; // location, emit it with addBReg and offset 0, because we should emit a DWARF; // expression representing a value, rather than a location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:17,Availability,mask,mask,17,"// If we need to mask out a subregister, do it now, unless the next; // operation would emit an OpPiece anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:45,Energy Efficiency,efficient,efficient,45,"// Pattern-match combinations for which more efficient representations exist.; // [Reg, DW_OP_plus_uconst, Offset] --> [DW_OP_breg, Offset].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:177,Availability,mask,mask,177,"// [Reg, DW_OP_constu, Offset, DW_OP_plus] --> [DW_OP_breg, Offset]; // [Reg, DW_OP_constu, Offset, DW_OP_minus] --> [DW_OP_breg,-Offset]; // If Reg is a subregister we need to mask it out before subtracting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:17,Availability,mask,mask,17,"// If we need to mask out a subregister, do it now, unless the next; // operation would emit an OpPiece anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:58,Testability,assert,assert,58,"// The temporary buffer can't be emptied, so for now just assert that nothing; // has been emitted to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:33,Usability,simpl,simply,33,"// If targeting a location-list; simply emit the index into the raw; // byte stream as ULEB128, DwarfDebug::emitDebugLocEntry has been; // fitted with means to extract it later.; // If targeting a inlined DW_AT_location; insert a DIEBaseTypeRef; // (containing the index and a resolve mechanism during emit) into the; // DIE value list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:8,Availability,mask,masking,8,/// add masking operations to stencil out a subregister.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:50,Availability,mask,mask,50,// Emit any outstanding DW_OP_piece operations to mask out subregisters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:32,Energy Efficiency,efficient,efficient,32,// Heuristic to decide the most efficient encoding.; // A ULEB can encode 7 1-bits per byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:30,Testability,log,logic,30,"/// Base class containing the logic for constructing DWARF expressions; /// independently of whether they are emitted into a DIE or into a .debug_loc; /// entry.; ///; /// Some DWARF operations, e.g. DW_OP_entry_value, need to calculate the size; /// of a succeeding DWARF block before the latter is emitted to the output.; /// To handle such cases, data can conditionally be emitted to a temporary; /// buffer, which can later on be committed to the main output. The size of the; /// temporary buffer is queryable, allowing for the size of the data to be; /// emitted before the data is committed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:8,Availability,mask,masking,8,/// Add masking operations to stencil out a subregister.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:58,Modifiability,variab,variable,58,/// Emit a DW_OP_piece or DW_OP_bit_piece operation for a variable fragment.; /// \param OffsetInBits This is an optional offset into the location that; /// is at the top of the DWARF stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:188,Availability,avail,available,188,"/// Emit a DW_OP_stack_value, if supported.; ///; /// The proper way to describe a constant value is DW_OP_constu <const>,; /// DW_OP_stack_value. Unfortunately, DW_OP_stack_value was not available; /// until DWARF 4, so we will continue to generate DW_OP_constu <const> for; /// DWARF 2 and DWARF 3. Technically, this is incorrect since DW_OP_const; /// <const> actually describes a value at a constant address, not a constant; /// value. However, in the past there was no better way to describe a; /// constant value, so the producers and consumers started to rely on; /// heuristics to disambiguate the value vs. location status of the; /// expression. See PR21176 for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,Availability,down,down,14,/// Lock this down to become a memory location description.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,Availability,down,down,14,/// Lock this down to become an entry value location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,Availability,down,down,14,/// Lock this down to become a call site parameter location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:126,Energy Efficiency,efficient,efficient,126,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:384,Modifiability,variab,variable,384,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:44,Performance,optimiz,optimization,44,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h:8,Modifiability,variab,variables,8,/// The variables of a lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:218,Safety,redund,redundancy,218,"// When the MDNode can be part of the type system, the DIE can be shared; // across CUs.; // Combining type units and cross-CU DIE sharing is lower value (since; // cross-CU DIE sharing is used in LTO and removes type redundancy at that; // level already) but may be implementable for some value in projects; // building multiple independent libraries with LTO and then linking those; // together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:13,Availability,down,down,13,// Pass this down to addConstantValue as an unsigned bag of bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:87,Modifiability,extend,extended,87,// FIXME: This is a bit conservative/simple - it emits negative values always; // sign extended to 64 bits rather than minimizing the number of bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:37,Usability,simpl,simple,37,// FIXME: This is a bit conservative/simple - it emits negative values always; // sign extended to 64 bits rather than minimizing the number of bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:113,Availability,down,down,113,"// This is to describe the memory location of the; // length of a Fortran deferred length string, so; // lock it down as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:73,Availability,down,down,73,"// This is to describe the memory location of the; // string, so lock it down as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:27,Availability,avail,available,27,// Add source line info if available and TyDesc is not a forward declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:33,Integrability,wrap,wrap,33,"// When emitting a variant part, wrap each member in; // DW_TAG_variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:29,Availability,avail,available,29,// Add accessibility info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:7,Security,access,accessibility,7,// Add accessibility info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:27,Availability,avail,available,27,// Add source line info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:21,Availability,avail,available,21,// Add align info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:106,Performance,load,loads,106,// We cannot describe the location of dllimport'd entities: the; // computation of their address requires loads from the IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:37,Integrability,depend,depending,37,"// Stop here and fill this in later, depending on whether or not this; // subprogram turns out to have inlined instances or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:108,Modifiability,variab,variables,108,// Add arguments. Do not add arguments for subprogram definition. They will; // be handled while processing variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:79,Availability,down,down,79,// Get an anonymous type for index type.; // FIXME: This type should be passed down from the front end; // as different languages may have different sizes for indexes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:21,Energy Efficiency,allocate,allocated,21,// All DIEValues are allocated through this allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:55,Modifiability,variab,variables,55,/// Tracks the mapping of unit level debug information variables to debug; /// information entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:51,Availability,avail,available,51,"// For strict DWARF mode, only generate attributes available to current; // DWARF version.; // Attribute 0 is used when emitting form-encoded values in blocks, which; // don't have attributes (only forms) so we cannot detect their DWARF; // version compatibility here and assume they are compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:218,Safety,detect,detect,218,"// For strict DWARF mode, only generate attributes available to current; // DWARF version.; // Attribute 0 is used when emitting form-encoded values in blocks, which; // don't have attributes (only forms) so we cannot detect their DWARF; // version compatibility here and assume they are compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:53,Modifiability,variab,variable,53,"/// Returns the DIE map slot for the specified debug variable.; ///; /// We delegate the request to DwarfDebug when the MDNode can be part of the; /// type system, since DIEs for the type system can be shared across CUs and; /// the mappings are kept in DwarfDebug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:26,Energy Efficiency,allocate,allocated,26,/// Returns a fresh newly allocated DIELoc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:156,Safety,predict,predictable,156,/// Add a string attribute data and value.; ///; /// We always emit a reference to the string pool instead of immediate; /// strings so that DIEs have more predictable sizes. In the case of split; /// dwarf we emit an index into another table which gets us the static offset; /// into the string table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:32,Modifiability,variab,variable,32,/// Add constant value entry in variable DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:32,Modifiability,variab,variable,32,/// Add constant value entry in variable DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:12,Security,access,accessibility,12,/// Add the accessibility attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:883,Modifiability,variab,variable,883,"// The action table follows the call-site table in the LSDA. The individual; // records are of two types:; //; // * Catch clause; // * Exception specification; //; // The two record kinds have the same format, with only small differences.; // They are distinguished by the ""switch value"" field: Catch clauses; // (TypeInfos) have strictly positive switch values, and exception; // specifications (FilterIds) have strictly negative switch values. Value 0; // indicates a catch-all clause.; //; // Negative type IDs index into FilterIds. Positive type IDs index into; // TypeInfos. The value written for a positive type ID is just the type ID; // itself. For a negative type ID, however, the value written is the; // (negative) byte offset of the corresponding FilterIds entry. The byte; // offset is usually equal to the type ID (because the FilterIds entries are; // written using a variable width encoding, which outputs one byte per entry; // as long as the value written is not too large) but can differ. This kind; // of complication does not occur for positive type IDs because type infos are; // output using a fixed width encoding. FilterOffsets[i] holds the byte; // offset corresponding to FilterIds[i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:3,Modifiability,Extend,Extend,3,// Extend the range of the previous entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:1037,Deployability,update,updated,1037,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:945,Testability,stub,stub,945,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:973,Testability,stub,stub,973,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:1187,Testability,stub,stub,1187,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:1265,Testability,stub,stubs,1265,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:20,Integrability,depend,dependency,20,// N.B.: There is a dependency loop between the size of the TTBase uleb128; // here and the amount of padding before the aligned type table. The; // assembler must sometimes pad this uleb128 or insert extra padding; // before the type table. See PR35809 or GNU as bug 4029.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:104,Usability,simpl,simply,104,"// For more than one call-site ranges, LPStart must be explicitly; // specified.; // For non-PIC we can simply use the absolute value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:417,Modifiability,plugin,plugin,417,"//===- ErlangGCPrinter.cpp - Erlang/OTP frametable emitter ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the compiler plugin that is used in order to emit; // garbage collection information in a convenient layout for parsing and; // loading in the Erlang/OTP runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:532,Performance,load,loading,532,"//===- ErlangGCPrinter.cpp - Erlang/OTP frametable emitter ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the compiler plugin that is used in order to emit; // garbage collection information in a convenient layout for parsing and; // loading in the Erlang/OTP runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:98,Safety,Safe,SafePointAddress,98,/** A compact GC layout. Emit this data structure:; *; * struct {; * int16_t PointCount;; * void *SafePointAddress[PointCount];; * int16_t StackFrameSize; (in words); * int16_t StackArity;; * int16_t LiveCount;; * int16_t LiveOffsets[LiveCount];; * } __gcmap_<FUNCTIONNAME>;; **/; // Align to address width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:12,Safety,safe,safe,12,// And each safe point...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:27,Safety,safe,safe,27,// Emit the address of the safe point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:37,Safety,safe,safe,37,// Stack information never change in safe points! Only print info from the; // first call-site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp:544,Safety,abort,abort,544,"/// emitAssembly - Print the frametable. The ocaml frametable format is thus:; ///; /// extern ""C"" struct align(sizeof(intptr_t)) {; /// uint16_t NumDescriptors;; /// struct align(sizeof(intptr_t)) {; /// void *ReturnAddress;; /// uint16_t FrameSize;; /// uint16_t NumLiveOffsets;; /// uint16_t LiveOffsets[NumLiveOffsets];; /// } Descriptors[NumDescriptors];; /// } caml${module}__frametable;; ///; /// Note that this precludes programs from stack frames larger than 64K; /// (FrameSize and LiveOffsets would overflow). FrameTablePrinter will abort if; /// either condition is detected in a function which uses the GC.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp:578,Safety,detect,detected,578,"/// emitAssembly - Print the frametable. The ocaml frametable format is thus:; ///; /// extern ""C"" struct align(sizeof(intptr_t)) {; /// uint16_t NumDescriptors;; /// struct align(sizeof(intptr_t)) {; /// void *ReturnAddress;; /// uint16_t FrameSize;; /// uint16_t NumLiveOffsets;; /// uint16_t LiveOffsets[NumLiveOffsets];; /// } Descriptors[NumDescriptors];; /// } caml${module}__frametable;; ///; /// Note that this precludes programs from stack frames larger than 64K; /// (FrameSize and LiveOffsets would overflow). FrameTablePrinter will abort if; /// either condition is detected in a function which uses the GC.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:242,Usability,Guid,Guid,242,"// Gather all the inlined-at nodes.; // When it's done ReversedInlineStack looks like ([66, B], [88, A]); // which means, Function A inlines function B at calliste with a probe id 88,; // and B inlines C at probe 66 where C is represented by Guid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:24,Availability,redundant,redundant,24,// Use caching to avoid redundant md5 computation for build speed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:18,Safety,avoid,avoid,18,// Use caching to avoid redundant md5 computation for build speed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:24,Safety,redund,redundant,24,// Use caching to avoid redundant md5 computation for build speed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h:11,Usability,GUID,GUID,11,"// Name to GUID map, used as caching/memoization for speed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp:472,Performance,load,loaded,472,"// These are symbols used to throw/catch C++ exceptions and C longjmps. These; // symbols have to be emitted somewhere once in the module. Check if each of; // the symbols has already been created, i.e., we have at least one 'throw' or; // 'catch' instruction with the symbol in the module, and emit the symbol only; // if so.; //; // But in dynamic linking, it is in general not possible to come up with a; // module instantiating order in which tag-defining modules are loaded before; // the importing modules. So we make them undefined symbols here, define tags; // in the JS side, and feed them to each importing module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp:110,Integrability,rout,routines,110,"// Compute the call-site table for wasm EH. Even though we use the same function; // name to share the common routines, a call site entry in the table corresponds; // to not a call site for possibly-throwing functions but a landing pad. In wasm; // EH the VM is responsible for stack unwinding. After an exception occurs and; // the stack is unwound, the control flow is transferred to wasm 'catch'; // instruction by the VM, after which the personality function is called from; // the compiler-generated code. Refer to WasmEHPrepare pass for more; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp:325,Safety,risk,risks,325,"// Add the function's symbol to the .gfids section.; // Note: For dllimport functions, MSVC sometimes does not add this symbol; // to the .gfids section, but only adds the corresponding ""__imp_"" symbol; // to the .giats section. Here we always add the symbol to the .gfids; // section, since this does not introduce security risks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp:316,Security,secur,security,316,"// Add the function's symbol to the .gfids section.; // Note: For dllimport functions, MSVC sometimes does not add this symbol; // to the .gfids section, but only adds the corresponding ""__imp_"" symbol; // to the .giats section. Here we always add the symbol to the .gfids; // section, since this does not introduce security risks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:31,Integrability,rout,routine,31,// Determine which personality routine we are using for this funclet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:26,Usability,simpl,simplify,26,// Reject empty ranges to simplify bookkeeping by ensuring that we can get; // the end of the last block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:172,Availability,fault,faults,172,"/// Emit the language-specific data that __C_specific_handler expects. This; /// handler lives in the x64 Microsoft C runtime and allows catching or cleaning; /// up after faults with __try, __except, and __finally. The typeinfo values; /// are not really RTTI data, but pointers to filter functions that return an; /// integer (1, 0, or -1) indicating how to handle the exception. For __finally; /// blocks and other cleanups, the landing pad label is zero, and the filter; /// function is actually a cleanup handler with the same prototype. A catch-all; /// entry is modeled with a null filter function field and a non-zero landing; /// pad label.; ///; /// Possible filter function return values:; /// EXCEPTION_EXECUTE_HANDLER (1):; /// Jump to the landing pad label after cleanups.; /// EXCEPTION_CONTINUE_SEARCH (0):; /// Continue searching this table or continue unwinding.; /// EXCEPTION_CONTINUE_EXECUTION (-1):; /// Resume execution at the trapping PC.; ///; /// Inferred table structure:; /// struct Table {; /// int NumEntries;; /// struct Entry {; /// imagerel32 LabelStart; // Inclusive; /// imagerel32 LabelEnd; // Exclusive; /// imagerel32 FilterOrFinally; // One means catch-all.; /// imagerel32 LabelLPad; // Zero means __finally.; /// } Entries[NumEntries];; /// };",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:926,Usability,Resume,Resume,926,"/// Emit the language-specific data that __C_specific_handler expects. This; /// handler lives in the x64 Microsoft C runtime and allows catching or cleaning; /// up after faults with __try, __except, and __finally. The typeinfo values; /// are not really RTTI data, but pointers to filter functions that return an; /// integer (1, 0, or -1) indicating how to handle the exception. For __finally; /// blocks and other cleanups, the landing pad label is zero, and the filter; /// function is actually a cleanup handler with the same prototype. A catch-all; /// entry is modeled with a null filter function field and a non-zero landing; /// pad label.; ///; /// Possible filter function return values:; /// EXCEPTION_EXECUTE_HANDLER (1):; /// Jump to the landing pad label after cleanups.; /// EXCEPTION_CONTINUE_SEARCH (0):; /// Continue searching this table or continue unwinding.; /// EXCEPTION_CONTINUE_EXECUTION (-1):; /// Resume execution at the trapping PC.; ///; /// Inferred table structure:; /// struct Table {; /// int NumEntries;; /// struct Entry {; /// imagerel32 LabelStart; // Inclusive; /// imagerel32 LabelEnd; // Exclusive; /// imagerel32 FilterOrFinally; // One means catch-all.; /// imagerel32 LabelLPad; // Zero means __finally.; /// } Entries[NumEntries];; /// };",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:86,Availability,recover,recoverfp,86,// Emit a label assignment with the SEH frame offset so we can use it for; // llvm.eh.recoverfp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:86,Safety,recover,recoverfp,86,// Emit a label assignment with the SEH frame offset so we can use it for; // llvm.eh.recoverfp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:171,Testability,test,test,171,"// TODO: The check for UnwindHelpFrameIdx against max() below (and the; // second check further below) can be removed if MS C++ unwinding is; // implemented for ARM, when test/CodeGen/ARM/Windows/wineh-basic.ll; // passes without the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:10,Testability,assert,assert,10,// FIXME: assert that NewState is between CatchLow and CatchHigh.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:108,Availability,recover,recover,108,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:390,Performance,optimiz,optimization,390,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:108,Safety,recover,recover,108,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:95,Testability,assert,assertion,95,// Retrieve the EH Guard slot.; // TODO(etienneb): Get rid of this value and change it for and assertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:35,Deployability,update,update,35,"// For each clause we're starting, update the MinClauseMap so we can; // know which is the topmost funclet containing a clause targeting; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:58,Deployability,update,update,58,// Save the previous current start/label on the stack and update to; // the newly-current start/state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:625,Availability,fault,fault,625,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:897,Availability,fault,fault,897,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:1628,Availability,fault,faulting,1628,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:1903,Availability,fault,fault,1903,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:1515,Testability,log,logic,1515,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:20,Usability,clear,clear,20,// Leaving bits 0-2 clear indicates catch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h:38,Availability,recover,recoverfp,38,"/// Emits the label used with llvm.eh.recoverfp, which is used by; /// outlined funclets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h:38,Safety,recover,recoverfp,38,"/// Emits the label used with llvm.eh.recoverfp, which is used by; /// outlined funclets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:422,Usability,simpl,simple,422,"//===-- lib/CodeGen/GlobalISel/CallLowering.cpp - Call lowering -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements some simple delegations needed for call lowering.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:26,Deployability,update,updates,26,/// Helper function which updates \p Flags when \p AttrFn returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:18,Safety,avoid,avoided,18,"// We should have avoided introducing a new virtual register, and just; // directly assigned here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:26,Modifiability,extend,extending,26,// A vector PartLLT needs extending to LLTy's element size.; // E.g. <2 x s64> = G_SEXT <2 x s32>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:38,Modifiability,extend,extended,38,// Sometimes pointers are passed zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:201,Modifiability,Extend,Extend,201,"// If PartLLT is a mismatched vector in both number of elements and element; // size, e.g. PartLLT == v2s64 and LLTy is v3s32, then first coerce it to; // have the same elt type, i.e. v4s32.; // TODO: Extend this coersion to element multiples other than just 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:86,Safety,avoid,avoid,86,// Pointer information was discarded. We'll need to coerce some register types; // to avoid violating type constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:146,Modifiability,Extend,ExtendOp,146,/// Create a sequence of instructions to expand the value in \p SrcReg (of type; /// \p SrcTy) to the types in \p DstRegs (of type \p PartTy). \p ExtendOp should; /// contain the type of scalar value extension if necessary.; ///; /// This is used for outgoing values (vregs to physregs),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:43,Modifiability,extend,extended,43,"// Vector was scalarized, and the elements extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:53,Usability,simpl,simple,53,"// If this already evenly divisible, we can create a simple unmerge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:48,Usability,simpl,simple,48,"// For scalars, it's common to be able to use a simple extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:64,Modifiability,extend,extend,64,// Widen to the common type.; // FIXME: This should respect the extend type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:29,Modifiability,extend,extend,29,"// The x32 ABI wants to zero extend 32-bit pointers to 64-bit registers, so; // we have to cast to do the extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:421,Energy Efficiency,schedul,schedule,421,"// end namespace llvm; /// This class acts as the glue the joins the CombinerHelper to the overall; /// Combine algorithm. The CombinerHelper is intended to report the; /// modifications it makes to the MIR to the GISelChangeObserver and the; /// observer subclass will act on these events. In this case, instruction; /// erasure will cancel any future visits to the erased instruction and; /// instruction creation will schedule that instruction for a future visit.; /// Other Combiner implementations may require more complex behaviour from; /// their GISelChangeObserver subclass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running this pass.; // FIXME: Should this be here or in individual combiner passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:157,Availability,down,down,157,"// Collect all instructions. Do a post order traversal for basic blocks and; // insert with list bottom up, so while we pop_back_val, we'll traverse top; // down RPOT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:19,Testability,test,testing,19,// Option to allow testing of the combiner while no targets know about indexed; // addressing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:60,Performance,load,load,60,"/// Given a map from byte offsets in memory to indices in a load/store,; /// determine if that map corresponds to a little or big endian byte pattern.; ///; /// \param MemOffset2Idx maps memory offsets to address offsets.; /// \param LowestIdx is the lowest index in \p MemOffset2Idx.; ///; /// \returns true if the map corresponds to a big endian byte pattern, false if; /// it corresponds to a little endian byte pattern, and std::nullopt otherwise.; ///; /// E.g. given a 32-bit type x, and x[AddrOffset], the in-memory byte patterns; /// are as follows:; ///; /// AddrOffset Little endian Big endian; /// 0 0 3; /// 1 1 2; /// 2 2 1; /// 3 3 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Availability,redundant,redundant,28,"// Note: IsUndef is sort of redundant. We could have determine it by; // checking that at all Ops are undef. Alternatively, we could have; // generate a build_vector of undefs and rely on another combine to; // clean that up. For now, given we already gather this information; // in tryCombineConcatVectors, just save compile time and issue the; // right thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Safety,redund,redundant,28,"// Note: IsUndef is sort of redundant. We could have determine it by; // checking that at all Ops are undef. Alternatively, we could have; // generate a build_vector of undefs and rely on another combine to; // clean that up. For now, given we already gather this information; // in tryCombineConcatVectors, just save compile time and issue the; // right thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:287,Usability,clear,clear,287,"// If the resulting vector is smaller than the size of the source; // vectors being concatenated, we won't be able to replace the; // shuffle vector into a concat_vectors.; //; // Note: We may still be able to produce a concat_vectors fed by; // extract_vector_elt and so on. It is less clear that would; // be better though, so don't bother for now.; //; // If the destination is a scalar, the size of the sources doesn't; // matter. we will lower the shuffle to a plain copy. This will; // work only if the source and destination have the same size. But; // that's covered by the next condition.; //; // TODO: If the size between the source and destination don't match; // we could still emit an extract vector element in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Availability,mask,mask,26,// Check that the shuffle mask can be broken evenly between the; // different sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Availability,Mask,Mask,3,// Mask length is a multiple of the source vector length.; // Check if the shuffle is some kind of concatenation of the input; // vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:344,Energy Efficiency,reduce,reduce,344,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:17,Modifiability,extend,extend,17,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:102,Modifiability,extend,extending,102,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:167,Modifiability,extend,extend,167,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:235,Modifiability,extend,extend,235,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:112,Performance,load,loads,112,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:158,Performance,load,load,158,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:252,Performance,load,load,252,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:139,Modifiability,extend,extend,139,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:179,Modifiability,rewrite,rewrite,179,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:194,Modifiability,extend,extend,194,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:218,Modifiability,extend,extend,218,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Performance,load,load,116,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:146,Performance,load,load,146,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:201,Performance,load,load,201,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:169,Energy Efficiency,reduce,reduced,169,// This is potentially target specific. We've chosen the largest type; // because G_TRUNC is usually free. One potential catch with this is that; // some targets have a reduced number of larger registers than smaller; // registers and this choice potentially increases the live-range for the; // larger value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:49,Modifiability,extend,extend,49,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:84,Modifiability,extend,extends,84,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:279,Modifiability,extend,extend,279,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:16,Performance,load,loads,16,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:121,Performance,load,load,121,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:147,Performance,load,load,147,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:350,Performance,load,load,350,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:393,Performance,perform,performance,393,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:244,Safety,safe,safe,244,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,Performance,load,loads,48,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:81,Performance,load,load,81,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:174,Performance,perform,perform,174,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:256,Performance,load,load,256,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:125,Security,access,accesses,125,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:11,Energy Efficiency,power,power-of-,11,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:128,Modifiability,extend,extending,128,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:82,Performance,load,loads,82,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:138,Performance,load,loads,138,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:46,Modifiability,extend,extends,46,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Modifiability,extend,extending,93,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:122,Modifiability,extend,extending,122,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:181,Modifiability,extend,extend,181,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:282,Modifiability,extend,extend,282,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:313,Modifiability,extend,extend,313,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:132,Performance,load,load,132,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:17,Modifiability,extend,extends,17,// There were no extends,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:39,Modifiability,extend,extend,39,// It should be impossible to chose an extend without selecting a different; // type since by definition the result of an extend is larger.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:122,Modifiability,extend,extend,122,// It should be impossible to chose an extend without selecting a different; // type since by definition the result of an extend is larger.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:34,Modifiability,extend,extending,34,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Performance,load,load,15,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Performance,load,load,44,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all the uses to fix up the types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Modifiability,extend,extend,10,// If the extend is compatible with the preferred extend then we should fix; // up the type and extend so that it uses the preferred use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:50,Modifiability,extend,extend,50,// If the extend is compatible with the preferred extend then we should fix; // up the type and extend so that it uses the preferred use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:96,Modifiability,extend,extend,96,// If the extend is compatible with the preferred extend then we should fix; // up the type and extend so that it uses the preferred use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Modifiability,extend,extend,93,"// If the use has the same type as the preferred use, then merge; // the vregs and erase the extend. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s32) = G_ANYEXT %1(s8); // ... = ... %3(s32); // rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // ... = ... %2(s32)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:228,Modifiability,rewrite,rewrites,228,"// If the use has the same type as the preferred use, then merge; // the vregs and erase the extend. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s32) = G_ANYEXT %1(s8); // ... = ... %3(s32); // rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // ... = ... %2(s32)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:51,Modifiability,extend,extend,51,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:62,Modifiability,extend,extend,62,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:96,Modifiability,extend,extending,96,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:240,Modifiability,rewrite,rewrites,240,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:106,Performance,load,load,106,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:189,Modifiability,rewrite,rewrites,189,"// If the preferred size is large, then insert a truncate. For; // example:; // %1:_(s8) = G_LOAD ...; // %2:_(s64) = G_SEXT %1(s8); // %3:_(s32) = G_ZEXT %1(s8); // ... = ... %3(s32); /// rewrites to:; // %2:_(s64) = G_SEXTLOAD ...; // %4:_(s8) = G_TRUNC %2:_(s32); // %3:_(s64) = G_ZEXT %2:_(s8); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:90,Deployability,update,update,90,// The use is (one of) the uses of the preferred use we chose earlier.; // We're going to update the load to def this value later so just erase; // the old extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:156,Modifiability,extend,extend,156,// The use is (one of) the uses of the preferred use we chose earlier.; // We're going to update the load to def this value later so just erase; // the old extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:101,Performance,load,load,101,// The use is (one of) the uses of the preferred use we chose earlier.; // We're going to update the load to def this value later so just erase; // the old extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:20,Modifiability,extend,extend,20,// The use isn't an extend. Truncate back to the type we originally loaded.; // This is free on many targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:68,Performance,load,loaded,68,// The use isn't an extend. Truncate back to the type we originally loaded.; // This is free on many targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:39,Availability,mask,mask,39,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:118,Availability,mask,mask,118,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:85,Performance,load,load,85,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:179,Performance,load,load,179,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Availability,mask,mask,7,"// The mask may not be larger than the in-memory type, as it might cover sign; // extended bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:82,Modifiability,extend,extended,82,"// The mask may not be larger than the in-memory type, as it might cover sign; // extended bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Availability,mask,mask,10,"// If the mask covers the whole destination register, there's nothing to; // extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:77,Modifiability,extend,extend,77,"// If the mask covers the whole destination register, there's nothing to; // extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:33,Performance,load,loads,33,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:96,Performance,load,loads,96,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:123,Performance,load,loads,123,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:103,Safety,Avoid,Avoid,103,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:27,Security,access,access,27,"// Don't modify the memory access size if this is atomic/volatile, but we can; // still adjust the opcode to indicate the high bit behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Energy Efficiency,reduce,reduced,44,// TODO: Could check if it's legal with the reduced or original memory size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:85,Modifiability,extend,extend,85,"// If the source is a G_SEXTLOAD from the same bit width, then we don't; // need any extend at all, just a truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:40,Modifiability,extend,extended,40,"// If truncating more than the original extended value, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:56,Safety,abort,abort,56,"// If truncating more than the original extended value, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Modifiability,extend,extend,15,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Modifiability,extend,extends,22,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:61,Performance,load,load,61,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:102,Performance,load,load,102,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:169,Performance,load,load,169,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:150,Safety,Avoid,Avoid,150,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:31,Energy Efficiency,power,power-,31,"// Don't bother creating a non-power-2 sextload, it will likely be broken up; // anyway for most targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:27,Security,access,access,27,"// Don't modify the memory access size if this is atomic/volatile, but we can; // still adjust the opcode to indicate the high bit behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Energy Efficiency,reduce,reduced,44,// TODO: Could check if it's legal with the reduced or original memory size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:53,Performance,load,load,53,"// If we have the following:; // %ld = G_LOAD %ptr, (load 2); // %ext = G_SEXT_INREG %ld, 8; // ==>; // %ld = G_SEXTLOAD %ptr (load 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:127,Performance,load,load,127,"// If we have the following:; // %ld = G_LOAD %ptr, (load 2); // %ext = G_SEXT_INREG %ld, 8; // ==>; // %ld = G_SEXTLOAD %ptr (load 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,Performance,load,load,29,/// Return true if 'MI' is a load or a store that may be fold it's address; /// operand into the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:97,Performance,load,load,97,/// Return true if 'MI' is a load or a store that may be fold it's address; /// operand into the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:55,Performance,load,load,55,"// We're looking for the following pattern, for either load or store:; // %baseptr:_(p0) = ...; // G_STORE %val(s64), %baseptr(p0); // %offset:_(s64) = G_CONSTANT i64 -256; // %new_addr:_(p0) = G_PTR_ADD %baseptr, %offset(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Safety,avoid,avoid,10,// Try to avoid exploding compile time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Performance,load,load,26,"// If the user is a later load/store that can be post-indexed, then don't; // combine this one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,Performance,load,load,36,// All use must be dominated by the load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing cross-block register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,Performance,load,load,36,"// All use must be dominated by the load/store.; // If Ptr may be folded in addressing mode of other use, then it's; // not profitable to do this transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:23,Performance,load,load,23,// Check if there is a load that defines the vector being extracted from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:30,Energy Efficiency,reduce,reduce,30,// Checking whether we should reduce the load width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:41,Performance,load,load,41,// Checking whether we should reduce the load width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:25,Performance,load,load,25,// Check if the defining load is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:33,Usability,simpl,simple,33,// Check if the defining load is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Performance,load,load,116,// If the vector element type is not a multiple of a byte then we are unable; // to correctly compute an address to load only the extracted element as a; // scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:20,Performance,load,load,20,// Check if the new load that we are going to create is legal; // if we are in the post-legalization phase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:133,Performance,load,load,133,// Finding the appropriate PtrInfo if offset is a known constant.; // This is required to create the memory operand for the narrowed load.; // This machine memory operand object helps us infer about legality; // before we proceed to combine the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:136,Modifiability,variab,variable,136,// Discard the pointer info except the address space because the memory; // operand can't represent this new access since the offset is variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:109,Security,access,access,109,// Discard the pointer info except the address space because the memory; // operand can't represent this new access since the offset is variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,Load,Load,3,// Load must be allowed and fast on the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:56,Performance,load,load,56,"// If the offset constant didn't happen to dominate the load/store, we can; // just clone it as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:201,Safety,avoid,avoiding,201,"// Check which instruction is first in the block so we don't break def-use; // deps by ""moving"" the instruction incorrectly. Also keep track of which; // instruction is first so we pick it's operands, avoiding use-before-def; // bugs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:394,Safety,predict,predictors,394,"// Try to match the following:; // bb1:; // G_BRCOND %c1, %bb2; // G_BR %bb3; // bb2:; // ...; // bb3:; // The above pattern does not have a fall through to the successor bb2, always; // resulting in a branch no matter which path is taken. Here we try to find; // and replace that pattern with conditional branch to bb3 and otherwise; // fallthrough to bb2. This is generally better for branch predictors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:46,Integrability,depend,depending,46,"// Convert `APFloat` to appropriate IEEE type depending on `DstTy`. Otherwise,; // `buildFConstant` will assert on size mismatch. Only `G_FSQRT`, and; // `G_FLOG2` reach here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:105,Testability,assert,assert,105,"// Convert `APFloat` to appropriate IEEE type depending on `DstTy`. Otherwise,; // `buildFConstant` will assert on size mismatch. Only `G_FSQRT`, and; // `G_FLOG2` reach here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:170,Performance,load,load,170,"// Check if the new combined immediate forms an illegal addressing mode.; // Do not combine if it was legal before but would get illegal.; // To do so, we need to find a load/store user of the pointer to get; // the access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:216,Security,access,access,216,"// Check if the new combined immediate forms an illegal addressing mode.; // Do not combine if it was legal before but would get illegal.; // To do so, we need to find a load/store user of the pointer to get; // the access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Usability,simpl,simple,15,// There is no simple replacement for a saturating unsigned left shift that; // exceeds the scalar size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Testability,log,logical,7,// Any logical shift that exceeds scalar size will produce zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:170,Testability,log,logic,170,"// We're trying to match the following pattern with any of; // G_SHL/G_ASHR/G_LSHR/G_USHLSAT/G_SSHLSAT shift instructions in combination; // with any of G_AND/G_OR/G_XOR logic instructions.; // %t1 = SHIFT %X, G_CONSTANT C0; // %t2 = LOGIC %t1, %Y; // %root = SHIFT %t2, G_CONSTANT C1; // -->; // %t3 = SHIFT %X, G_CONSTANT (C0+C1); // %t4 = SHIFT %Y, G_CONSTANT C1; // %root = LOGIC %t3, %t4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:234,Testability,LOG,LOGIC,234,"// We're trying to match the following pattern with any of; // G_SHL/G_ASHR/G_LSHR/G_USHLSAT/G_SSHLSAT shift instructions in combination; // with any of G_AND/G_OR/G_XOR logic instructions.; // %t1 = SHIFT %X, G_CONSTANT C0; // %t2 = LOGIC %t1, %Y; // %root = SHIFT %t2, G_CONSTANT C1; // -->; // %t3 = SHIFT %X, G_CONSTANT (C0+C1); // %t4 = SHIFT %Y, G_CONSTANT C1; // %root = LOGIC %t3, %t4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:378,Testability,LOG,LOGIC,378,"// We're trying to match the following pattern with any of; // G_SHL/G_ASHR/G_LSHR/G_USHLSAT/G_SSHLSAT shift instructions in combination; // with any of G_AND/G_OR/G_XOR logic instructions.; // %t1 = SHIFT %X, G_CONSTANT C0; // %t2 = LOGIC %t1, %Y; // %root = SHIFT %t2, G_CONSTANT C1; // -->; // %t3 = SHIFT %X, G_CONSTANT (C0+C1); // %t4 = SHIFT %Y, G_CONSTANT C1; // %root = LOGIC %t3, %t4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:27,Testability,log,logic,27,// Match a one-use bitwise logic op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Testability,Log,Logic,3,"// Logic ops are commutative, so check each operand for a match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:311,Safety,avoid,avoid,311,"// If LogicNonShiftReg is the same to Shift1Base, and shift1 const is the same; // to MatchInfo.Shift2 const, CSEMIRBuilder will reuse the old shift1 when; // build shift2. So, if we erase MatchInfo.Shift2 at the end, actually we; // remove old shift1. And it will cause crash later. So erase it earlier to; // avoid the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:6,Testability,Log,LogicNonShiftReg,6,"// If LogicNonShiftReg is the same to Shift1Base, and shift1 const is the same; // to MatchInfo.Shift2 const, CSEMIRBuilder will reuse the old shift1 when; // build shift2. So, if we erase MatchInfo.Shift2 at the end, actually we; // remove old shift1. And it will cause crash later. So erase it earlier to; // avoid the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Safety,safe,safe,28,// This was one use so it's safe to remove it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:9,Availability,down,down,9,// Break down the big constant in smaller ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Usability,simpl,simplify,116,"// G_ZEXT on vector applies to each lane, so it will; // affect all destinations. Therefore we won't be able; // to simplify the unmerge to just the first definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:23,Energy Efficiency,reduce,reduce,23,"// TODO: We could also reduce to 16 bits, but that's more target-dependent.; // Some targets like it, some don't, some only like it under certain; // conditions/processor versions, etc.; // A TL hook might be needed for this.; // Don't combine",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:65,Integrability,depend,dependent,65,"// TODO: We could also reduce to 16 bits, but that's more target-dependent.; // Some targets like it, some don't, some only like it under certain; // conditions/processor versions, etc.; // A TL hook might be needed for this.; // Don't combine",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:35,Performance,load,loads,35,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:158,Performance,load,load,158,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:236,Performance,load,load,236,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:376,Performance,load,loading,376,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:429,Performance,load,loads,429,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:396,Safety,safe,safe,396,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Performance,load,loads,28,"// If both instructions are loads or stores, they are equal only if both; // are dereferenceable invariant loads with the same number of bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:107,Performance,load,loads,107,"// If both instructions are loads or stores, they are equal only if both; // are dereferenceable invariant loads with the same number of bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:61,Safety,avoid,avoid,61,// Check for physical registers on the instructions first to avoid cases; // like this:; //; // %a = COPY $physreg; // ...; // SOMETHING implicit-def $physreg; // ...; // %b = COPY $physreg; //; // These copies are not equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Modifiability,Variab,Variable,3,// Variable index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Testability,log,logic,12,"// Matches: logic (hand x, ...), (hand y, ...) -> hand (logic x, y), ...; //; // Creates the new hand + logic instruction (but does not insert them.); //; // On success, MatchInfo is populated with the new instructions. These are; // inserted in applyHoistLogicOpWithSameOpcodeHands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:56,Testability,log,logic,56,"// Matches: logic (hand x, ...), (hand y, ...) -> hand (logic x, y), ...; //; // Creates the new hand + logic instruction (but does not insert them.); //; // On success, MatchInfo is populated with the new instructions. These are; // inserted in applyHoistLogicOpWithSameOpcodeHands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:104,Testability,log,logic,104,"// Matches: logic (hand x, ...), (hand y, ...) -> hand (logic x, y), ...; //; // Creates the new hand + logic instruction (but does not insert them.); //; // On success, MatchInfo is populated with the new instructions. These are; // inserted in applyHoistLogicOpWithSameOpcodeHands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Testability,log,logic,10,"// Match: logic (ext X), (ext Y) --> ext (logic X, Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:42,Testability,log,logic,42,"// Match: logic (ext X), (ext Y) --> ext (logic X, Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Testability,log,logic,10,"// Match: logic (binop x, z), (binop y, z) -> binop (logic x, y), z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:53,Testability,log,logic,53,"// Match: logic (binop x, z), (binop y, z) -> binop (logic x, y), z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:75,Testability,log,logic,75,"// Record the steps to build the new instructions.; //; // Steps to build (logic x, y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:24,Testability,log,logic,24,"// Steps to build hand (logic x, y), ...z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:18,Availability,Mask,Mask,18,"// Check that x & Mask == x.; // x & 1 == x, always; // x & 0 == x, only if x is also 0; // Meaning Mask has no effect if every bit is either one in Mask or zero in x.; //; // Check if we can replace AndDst with the LHS of the G_AND",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Availability,Mask,Mask,100,"// Check that x & Mask == x.; // x & 1 == x, always; // x & 0 == x, only if x is also 0; // Meaning Mask has no effect if every bit is either one in Mask or zero in x.; //; // Check if we can replace AndDst with the LHS of the G_AND",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:149,Availability,Mask,Mask,149,"// Check that x & Mask == x.; // x & 1 == x, always; // x & 0 == x, only if x is also 0; // Meaning Mask has no effect if every bit is either one in Mask or zero in x.; //; // Check if we can replace AndDst with the LHS of the G_AND",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:18,Availability,Mask,Mask,18,"// Check that x | Mask == x.; // x | 0 == x, always; // x | 1 == x, only if x is also 1; // Meaning Mask has no effect if every bit is either zero in Mask or one in x.; //; // Check if we can replace OrDst with the LHS of the G_OR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Availability,Mask,Mask,100,"// Check that x | Mask == x.; // x | 0 == x, always; // x | 1 == x, only if x is also 1; // Meaning Mask has no effect if every bit is either zero in Mask or one in x.; //; // Check if we can replace OrDst with the LHS of the G_OR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:150,Availability,Mask,Mask,150,"// Check that x | Mask == x.; // x | 0 == x, always; // x | 1 == x, only if x is also 1; // Meaning Mask has no effect if every bit is either zero in Mask or one in x.; //; // Check if we can replace OrDst with the LHS of the G_OR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:32,Modifiability,extend,extended,32,"// If the input is already sign extended, just drop the extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:47,Energy Efficiency,power,power,47,/// The second source operand is known to be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:161,Modifiability,variab,variable,161,"// We know that one of the operands is a select of constants. Now verify that; // the other binary operator operand is either a constant, or we can handle a; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:79,Performance,load,loads,79,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:112,Performance,load,load,112,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:385,Performance,load,load,385,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:14,Safety,detect,detect,14,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:45,Performance,load,load,45,"// In the ""worst"" case, we're dealing with a load for each byte. So, there; // are at most #bytes - 1 ORs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Performance,load,load,100,"// If it's a G_OR, save it and continue to walk. If it's not, then it's; // something that may be a load + arithmetic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:59,Energy Efficiency,power,power-of-,59,"// We're going to try and merge each register into a wider power-of-2 type,; // so we ought to have an even number of registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Performance,load,loading,100,"/// Helper function for findLoadOffsetsForLoadOrCombine.; ///; /// Check if \p Reg is the result of loading a \p MemSizeInBits wide value,; /// and then moving that value into a specific byte offset.; ///; /// e.g. x[i] << 24; ///; /// \returns The load instruction and the byte offset it is moved into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:249,Performance,load,load,249,"/// Helper function for findLoadOffsetsForLoadOrCombine.; ///; /// Check if \p Reg is the result of loading a \p MemSizeInBits wide value,; /// and then moving that value into a specific byte offset.; ///; /// e.g. x[i] << 24; ///; /// \returns The load instruction and the byte offset it is moved into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:31,Performance,load,loads,31,// TODO: Handle other types of loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:8,Performance,load,load,8,// Each load found for the pattern. There should be one for each RegsToVisit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:32,Performance,load,load,32,"// The lowest index used in any load. (The lowest ""i"" for each x[i].)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Performance,load,load,7,// The load which uses the lowest index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Performance,load,load,22,// Keeps track of the load indices we see. We shouldn't see any indices twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Performance,load,load,15,// Ensure each load is in the same MBB.; // TODO: Support multiple MachineBasicBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:30,Performance,load,load,30,// Earliest instruction-order load in the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Performance,load,load,28,// Latest instruction-order load in the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Performance,load,load,28,// Base pointer which every load should share.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:21,Performance,load,load,21,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:50,Performance,load,load,50,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:167,Performance,load,load,167,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:275,Performance,load,load,275,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Performance,load,load,12,"// Find the load, and find the position that it will end up in (e.g. a; // shifted) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:133,Performance,load,loads,133,// TODO: Handle multiple MachineBasicBlocks. Currently not handled because; // it is difficult to check for stores/calls/etc between loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:55,Performance,load,load,55,// Make sure that the MachineMemOperands of every seen load are compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:52,Performance,load,load,52,// Find out what the base pointer and index for the load is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:52,Performance,load,load,52,"// Don't combine things like a[i], a[i] -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:9,Performance,load,load,9,"// Every load must share the same base pointer; don't combine things like:; //; // a[i], b[i + 1] -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:110,Performance,load,load,110,"// Every load must share the same base pointer; don't combine things like:; //; // a[i], b[i + 1] -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:43,Performance,load,load,43,"// Keep track of the byte offset that this load ends up at. If we have seen; // the byte offset, then stop here. We do not want to combine:; //; // a[i] << 16, a[i + k] << 16 -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:187,Performance,load,load,187,"// Keep track of the byte offset that this load ends up at. If we have seen; // the byte offset, then stop here. We do not want to combine:; //; // a[i] << 16, a[i + k] << 16 -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:53,Performance,load,loads,53,// Keep track of the position of the earliest/latest loads in the pattern.; // We will check that there are no load fold barriers between them later; // on.; //; // FIXME: Is there a better way to check for load fold barriers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:111,Performance,load,load,111,// Keep track of the position of the earliest/latest loads in the pattern.; // We will check that there are no load fold barriers between them later; // on.; //; // FIXME: Is there a better way to check for load fold barriers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:207,Performance,load,load,207,// Keep track of the position of the earliest/latest loads in the pattern.; // We will check that there are no load fold barriers between them later; // on.; //; // FIXME: Is there a better way to check for load fold barriers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:14,Performance,load,load,14,// We found a load for each register. Let's check if each load satisfies the; // pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:58,Performance,load,load,58,// We found a load for each register. Let's check if each load satisfies the; // pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:65,Performance,load,loads,65,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:111,Performance,perform,perform,111,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:332,Performance,load,load,332,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:104,Safety,safe,safely,104,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:252,Testability,test,test,252,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:35,Performance,load,loads,35,"// We need to combine at least two loads into this type. Since the smallest; // possible load is into a byte, we need at least a 16-bit wide type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:89,Performance,load,load,89,"// We need to combine at least two loads into this type. Since the smallest; // possible load is into a byte, we need at least a 16-bit wide type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:90,Performance,load,loads,90,// We have a collection of non-OR instructions. Figure out how wide each of; // the small loads should be based off of the number of potential loads we; // found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:143,Performance,load,loads,143,// We have a collection of non-OR instructions. Figure out how wide each of; // the small loads should be based off of the number of potential loads we; // found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:52,Performance,load,load,52,"// Check if each register feeding into each OR is a load from the same; // base pointer + some arithmetic.; //; // e.g. a[0], a[1] << 8, a[2] << 16, etc.; //; // Also verify that each of these ends up putting a[i] into the same memory; // offset as a load into a wide type would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:251,Performance,load,load,251,"// Check if each register feeding into each OR is a load from the same; // base pointer + some arithmetic.; //; // e.g. a[0], a[1] << 8, a[2] << 16, etc.; //; // Also verify that each of these ends up putting a[i] into the same memory; // offset as a load into a wide type would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Performance,load,loads,22,"// We have a bunch of loads being OR'd together. Using the addresses + offsets; // we found before, check if this corresponds to a big or little endian byte; // pattern. If it does, then we can represent it using a load + possibly a; // BSWAP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:215,Performance,load,load,215,"// We have a bunch of loads being OR'd together. Using the addresses + offsets; // we found before, check if this corresponds to a big or little endian byte; // pattern. If it does, then we can represent it using a load + possibly a; // BSWAP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Performance,load,load,22,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:163,Performance,load,load,163,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:187,Performance,load,load,187,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:233,Performance,load,load,233,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:37,Performance,load,load,37,// We wil reuse the pointer from the load which ends up at byte offset 0. It; // may not use index 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,Load,Load,3,// Load must be allowed and fast on the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:9,Modifiability,Extend,Extending,9,"// TODO: Extending a vector may be expensive, don't do this until heuristics; // are better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Modifiability,extend,extend,44,"// Try to match a phi, whose only use is an extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:40,Modifiability,extend,extend,40,"// If the target is likely to fold this extend away, don't propagate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:34,Modifiability,extend,extends,34,// We don't want to propagate the extends unless there's a good chance that; // they'll be optimized in some way.; // Collect the unique incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:91,Performance,optimiz,optimized,91,// We don't want to propagate the extends unless there's a good chance that; // they'll be optimized in some way.; // Collect the unique incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:73,Modifiability,extend,extends,73,"// Don't try to propagate if there are too many places to create new; // extends, chances are it'll increase code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Modifiability,extend,extend,12,// Build an extend after each src inst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,Modifiability,extend,extended,29,// Create a new phi with the extended inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:164,Availability,mask,masked,164,"// This combine tries to find build_vector's which have every source element; // extracted using G_EXTRACT_VECTOR_ELT. This can happen when transforms like; // the masked load scalarization is run late in the pipeline. There's already; // a combine for a similar pattern starting from the extract, but that; // doesn't attempt to do it if there are multiple uses of the build_vector,; // which in this case is true. Starting the combine from the build_vector; // feels more natural than trying to find sibling nodes of extracts.; // E.g.; // %vec(<4 x s32>) = G_BUILD_VECTOR %s1(s32), %s2, %s3, %s4; // %ext1 = G_EXTRACT_VECTOR_ELT %vec, 0; // %ext2 = G_EXTRACT_VECTOR_ELT %vec, 1; // %ext3 = G_EXTRACT_VECTOR_ELT %vec, 2; // %ext4 = G_EXTRACT_VECTOR_ELT %vec, 3; // ==>; // replace ext{1,2,3,4} with %s{1,2,3,4}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:209,Deployability,pipeline,pipeline,209,"// This combine tries to find build_vector's which have every source element; // extracted using G_EXTRACT_VECTOR_ELT. This can happen when transforms like; // the masked load scalarization is run late in the pipeline. There's already; // a combine for a similar pattern starting from the extract, but that; // doesn't attempt to do it if there are multiple uses of the build_vector,; // which in this case is true. Starting the combine from the build_vector; // feels more natural than trying to find sibling nodes of extracts.; // E.g.; // %vec(<4 x s32>) = G_BUILD_VECTOR %s1(s32), %s2, %s3, %s4; // %ext1 = G_EXTRACT_VECTOR_ELT %vec, 0; // %ext2 = G_EXTRACT_VECTOR_ELT %vec, 1; // %ext3 = G_EXTRACT_VECTOR_ELT %vec, 2; // %ext4 = G_EXTRACT_VECTOR_ELT %vec, 3; // ==>; // replace ext{1,2,3,4} with %s{1,2,3,4}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:171,Performance,load,load,171,"// This combine tries to find build_vector's which have every source element; // extracted using G_EXTRACT_VECTOR_ELT. This can happen when transforms like; // the masked load scalarization is run late in the pipeline. There's already; // a combine for a similar pattern starting from the extract, but that; // doesn't attempt to do it if there are multiple uses of the build_vector,; // which in this case is true. Starting the combine from the build_vector; // feels more natural than trying to find sibling nodes of extracts.; // E.g.; // %vec(<4 x s32>) = G_BUILD_VECTOR %s1(s32), %s2, %s3, %s4; // %ext1 = G_EXTRACT_VECTOR_ELT %vec, 0; // %ext2 = G_EXTRACT_VECTOR_ELT %vec, 1; // %ext3 = G_EXTRACT_VECTOR_ELT %vec, 2; // %ext4 = G_EXTRACT_VECTOR_ELT %vec, 3; // ==>; // replace ext{1,2,3,4} with %s{1,2,3,4}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Usability,simpl,simplify,26,// Ignore vector types to simplify matching the two constants.; // TODO: do this for vectors and scalars via a demanded bits analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,Availability,mask,mask,36,"/// Form a G_UBFX from ""(a srl b) & mask"", where b and mask are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:55,Availability,mask,mask,55,"/// Form a G_UBFX from ""(a srl b) & mask"", where b and mask are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Availability,mask,mask,7,// The mask is a mask of the low bits iff imm & (imm+1) == 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:17,Availability,mask,mask,17,// The mask is a mask of the low bits iff imm & (imm+1) == 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,Availability,mask,mask,29,"// If the shift subsumes the mask, emit the 0 directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:63,Availability,mask,mask,63,"// Check that ubfx can do the extraction, with no holes in the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Availability,redundant,redundant,93,"// This combine may end up running before ptrtoint/inttoptr combines; // manage to eliminate redundant conversions, so try to look through them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Safety,redund,redundant,93,"// This combine may end up running before ptrtoint/inttoptr combines; // manage to eliminate redundant conversions, so try to look through them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:181,Performance,load,load,181,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Testability,test,test,116,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:54,Modifiability,extend,extend,54,// set VReg will cause type mismatch if it comes from extend/trunc,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:47,Availability,mask,mask,47,"// Look for a binop feeding into an AND with a mask:; //; // %add = G_ADD %lhs, %rhs; // %and = G_AND %add, 000...11111111; //; // Check if it's possible to perform the binop at a narrower width and zext; // back to the original width like so:; //; // %narrow_lhs = G_TRUNC %lhs; // %narrow_rhs = G_TRUNC %rhs; // %narrow_add = G_ADD %narrow_lhs, %narrow_rhs; // %new_add = G_ZEXT %narrow_add; // %and = G_AND %new_add, 000...11111111; //; // This can allow later combines to eliminate the G_AND if it turns out; // that the mask is irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:525,Availability,mask,mask,525,"// Look for a binop feeding into an AND with a mask:; //; // %add = G_ADD %lhs, %rhs; // %and = G_AND %add, 000...11111111; //; // Check if it's possible to perform the binop at a narrower width and zext; // back to the original width like so:; //; // %narrow_lhs = G_TRUNC %lhs; // %narrow_rhs = G_TRUNC %rhs; // %narrow_add = G_ADD %narrow_lhs, %narrow_rhs; // %new_add = G_ZEXT %narrow_add; // %and = G_AND %new_add, 000...11111111; //; // This can allow later combines to eliminate the G_AND if it turns out; // that the mask is irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:157,Performance,perform,perform,157,"// Look for a binop feeding into an AND with a mask:; //; // %add = G_ADD %lhs, %rhs; // %and = G_AND %add, 000...11111111; //; // Check if it's possible to perform the binop at a narrower width and zext; // back to the original width like so:; //; // %narrow_lhs = G_TRUNC %lhs; // %narrow_rhs = G_TRUNC %rhs; // %narrow_add = G_ADD %narrow_lhs, %narrow_rhs; // %new_add = G_ZEXT %narrow_add; // %and = G_AND %new_add, 000...11111111; //; // This can allow later combines to eliminate the G_AND if it turns out; // that the mask is irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:80,Availability,mask,masking,80,"// Check if the LHS feeding the AND is impacted by the high bits that we're; // masking out.; //; // e.g. for 64-bit x, y:; //; // add_64(x, y) & 65535 == zext(add_16(trunc(x), trunc(y))) & 65535",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Availability,mask,mask,12,// Find the mask on the RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,Usability,simpl,simpler,48,// If the sdiv has an 'exact' flag we can use a simpler lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:94,Modifiability,extend,extend,94,"// Calculate the multiplicative inverse modulo BW.; // 2^W requires W + 1 bits, so we have to extend and then truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,Integrability,contract,contractable,48,/// Checks if \p MI is TargetOpcode::G_FMUL and contractable either; /// due to global flags or MachineInstr flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Integrability,contract,contractable,26,"// If the addition is not contractable, do not combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:14,Safety,unsafe,unsafe,14,// Completely unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,scalab,scalable,3,// scalable vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,scalab,scalable,3,// scalable vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:54,Performance,scalab,scalable,54,// Ignores COPYs during conformance checks.; // FIXME scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:43,Performance,scalab,scalable,43,// Ignores COPYs during lookups.; // FIXME scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:28,Testability,assert,assert,28,// Should we check here and assert that the instruction has been fully; // constructed?; // FIXME: Any other checks required to be done here? Remove this method if; // none.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:47,Safety,avoid,avoid,47,/// We'll reuse the same UniqueMachineInstr to avoid the new; /// allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:31,Energy Efficiency,Allocate,Allocate,31,/// This is a new instruction. Allocate a new UniqueMachineInstr and; /// Insert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:12,Performance,perform,perform,12,"// For now, perform erase, followed by insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:33,Performance,cache,cache,33,"// For now, we only maintain the cache during one request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:3,Testability,Test,Test,3,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:42,Usability,simpl,simpler,42,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:53,Availability,Mask,Mask,53,"// Bitfield extract is computed as (Src >> Offset) & Mask, where Mask is; // created using Width. Use this function when the inputs are KnownBits; // objects. TODO: Move this KnownBits.h if this is usable in more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:65,Availability,Mask,Mask,65,"// Bitfield extract is computed as (Src >> Offset) & Mask, where Mask is; // created using Width. Use this function when the inputs are KnownBits; // objects. TODO: Move this KnownBits.h if this is usable in more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:198,Usability,usab,usable,198,"// Bitfield extract is computed as (Src >> Offset) & Mask, where Mask is; // created using Width. Use this function when the inputs are KnownBits; // objects. TODO: Move this KnownBits.h if this is usable in more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:440,Availability,down,down,440,"// Don't know anything; // Depth may get bigger than max depth if it gets passed to a different; // GISelKnownBits object.; // This may happen when say a generic part uses a GISelKnownBits object; // with some max depth, but then we hit TL.computeKnownBitsForTargetInstr; // which creates a new GISelKnownBits object with a different and smaller; // depth. If we just check for equality, we would never exit if the depth; // that is passed down to the target specific GISelKnownBits object is; // already bigger than its max depth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:79,Deployability,pipeline,pipeline,79,"// Destination registers should not have subregisters at this; // point of the pipeline, otherwise the main live-range will be; // defined more than once, which is against SSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:70,Deployability,update,updated,70,"// Record in the cache that we know nothing for MI.; // This will get updated later and in the meantime, if we reach that; // phi again, because of a loop, we will cut the search thanks to this; // cache entry.; // We could actually build up more information on the phi by not cutting; // the search, but that additional information is more a side effect; // than an intended choice.; // Therefore, for now, save on compile time until we derive a proper way; // to derive known bits for PHIs within loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:17,Performance,cache,cache,17,"// Record in the cache that we know nothing for MI.; // This will get updated later and in the meantime, if we reach that; // phi again, because of a loop, we will cut the search thanks to this; // cache entry.; // We could actually build up more information on the phi by not cutting; // the search, but that additional information is more a side effect; // than an intended choice.; // Therefore, for now, save on compile time until we derive a proper way; // to derive known bits for PHIs within loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:198,Performance,cache,cache,198,"// Record in the cache that we know nothing for MI.; // This will get updated later and in the meantime, if we reach that; // phi again, because of a loop, we will cut the search thanks to this; // cache entry.; // We could actually build up more information on the phi by not cutting; // the search, but that additional information is more a side effect; // than an intended choice.; // Therefore, for now, save on compile time until we derive a proper way; // to derive known bits for PHIs within loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:62,Modifiability,extend,extend,62,"// If the sign bit is known to be zero or one, then sext will extend; // it to the top bits, else it will just zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:128,Usability,clear,clearing,128,"// TODO: Should use maximum with source; // If a node is guaranteed to be aligned, set low zero bits accordingly as; // well as clearing one bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:8,Modifiability,extend,extend,8,// Sign extend the extracted value using shift left and arithmetic shift; // right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:3,Deployability,Update,Update,3,// Update the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:14,Performance,cache,cache,14,// Update the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:3,Testability,Test,Test,3,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:42,Usability,simpl,simpler,42,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:34,Modifiability,extend,extends,34,// Max of the input and what this extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:39,Availability,down,down,39,// Check if the sign bits of source go down as far as the truncated value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:139,Availability,avail,available,139,"// If compares returns 0/-1, all bits are sign bits.; // We know that we have an integer-based boolean since these operations; // are only available for integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:38,Availability,Mask,Mask,38,"// Okay, we know that the sign bit in Mask is set. Use CLO to determine; // the number of identical bits in the top of the input value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GlobalISel.cpp:437,Integrability,rout,routines,437,"//===-- llvm/CodeGen/GlobalISel/GlobalIsel.cpp --- GlobalISel ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; // This file implements the common initialization routines for the; // GlobalISel library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GlobalISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GlobalISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:23,Availability,failure,failure,23,// RC is unset only on failure. Return immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate a matching input constraint since the constraint it's; // matching to has already been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:110,Energy Efficiency,allocate,allocated,110,// No need to allocate a matching input constraint since the constraint it's; // matching to has already been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:142,Energy Efficiency,allocate,allocate,142,"// If this is a constraint for a specific physical register, but the type of; // the operand requires more than one register to be passed, we allocate the; // required amount of physical registers, starting from the selected physical; // register.; // For this, first retrieve a register iterator for the given register class",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:71,Security,access,accessed,71,"// If this is an indirect operand, the operand is a pointer to the; // accessed type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:38,Security,expose,expose,38,// The selected constraint type might expose new sideeffects,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:3,Usability,Simpl,Simple,3,// Simple Integer or Relocatable Constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:36,Modifiability,extend,extended,36,"// Boolean constants should be zero-extended, others are sign-extended",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:62,Modifiability,extend,extended,62,"// Boolean constants should be zero-extended, others are sign-extended",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:57,Testability,test,testing,57,"// In order not to crash when calling getAnalysis during testing with -run-pass; // we use the default opt level here instead of None, so that the addRequired(); // calls are made in getAnalysisUsage().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:50,Availability,failure,failures,50,// An optimization remark emitter. Used to report failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:6,Performance,optimiz,optimization,6,// An optimization remark emitter. Used to report failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:131,Testability,assert,assert,131,"// FIXME: We could introduce new blocks and will need to fix the outer loop.; // Until then, keep track of the number of blocks to assert that we don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:15,Availability,redundant,redundant,15,// Try to find redundant copies b/w vregs of the same register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:15,Safety,redund,redundant,15,// Try to find redundant copies b/w vregs of the same register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:149,Availability,error,error,149,// Print the function name explicitly if we don't have a debug location (which; // makes the diagnostic less useful) or if we're going to emit a raw error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:24,Integrability,message,message,24,// Only print the check message if we're actually checking it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:10,Energy Efficiency,allocate,allocate,10,// Always allocate at least one byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:90,Performance,load,loadimm,90,// Get or create a virtual register for each value.; // Unless the value is a Constant => loadimm cst?; // or inline constant each time?; // Creation of a virtual register needs to have a size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:359,Performance,perform,performance,359,"// If this is a series of conditions that are or'd or and'd together, emit; // this as a sequence of branches instead of setcc's with and/or operations.; // As long as jumps are not expensive (exceptions for multi-use logic ops,; // unpredictable branches, and vector extracts because those jumps are likely; // expensive for any target), this should improve performance.; // For example, instead of something like:; // cmp A, B; // C = seteq; // cmp D, E; // F = setle; // or C, F; // jnz foo; // Emit:; // cmp A, B; // je foo; // cmp D, E; // jle foo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:218,Testability,log,logic,218,"// If this is a series of conditions that are or'd or and'd together, emit; // this as a sequence of branches instead of setcc's with and/or operations.; // As long as jumps are not expensive (exceptions for multi-use logic ops,; // unpredictable branches, and vector extracts because those jumps are likely; // expensive for any target), this should improve performance.; // For example, instead of something like:; // cmp A, B; // C = seteq; // cmp D, E; // F = setle; // or C, F; // jnz foo; // Emit:; // cmp A, B; // je foo; // cmp D, E; // jle foo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:66,Usability,clear,clear,66,"// Okay, we decided not to do this, remove any inserted MBB's and clear; // SwitchCases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:17,Availability,avail,available,17,"// If BPI is not available, set the default probability as 1 / N, where N is; // the number of successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:75,Performance,optimiz,optimization,75,// Cluster adjacent cases with the same destination. We do this at all; // optimization levels because it's cheap to do and will make codegen faster; // if there are many clusters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:7,Performance,optimiz,optimized,7,"// For optimized builds, lower large range as a balanced binary tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting unnecessary branches to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Update,Update,3,// Update successor info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:10,Performance,Optimiz,Optimize,10,// FIXME: Optimize away range check based on pivot comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:142,Deployability,update,update,142,"// If the default statement is a target of the jump table, we evenly; // distribute the default probability to successors of CurMBB. Also; // update the probability on the edge from JumpMBB to Fallthrough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:37,Availability,mask,mask,37,// Ensure that the type will fit the mask value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:54,Availability,mask,masks,54,"// Switch table case range are encoded into series of masks.; // Just use pointer type, it's guaranteed to fit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting unnecessary branches to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Testability,Test,Testing,3,// Testing for a single bit; just compare the shift count with what it; // would need to be to shift a 1 bit in that position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:44,Testability,test,test,44,"// There is only one zero bit in the range, test for it directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:12,Testability,test,tests,12,// Emit bit tests and jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:63,Testability,test,test,63,// Record the fact that the IR edge from the header to the bit test target; // will go through our new block. Neeeded for PHIs to have nodes added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting unnecessary branches to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:10,Performance,Optimiz,Optimize,10,// FIXME: Optimize away range check based on pivot comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:11,Testability,test,test,11,// The bit test blocks haven't been inserted yet; insert them here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:23,Testability,test,test,23,"// If the cases in bit test don't form a contiguous range, we evenly; // distribute the probability on the edge to Fallthrough to two; // successors of CurMBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:45,Testability,test,test,45,"// If we're in the right place, emit the bit test header right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:34,Safety,Avoid,Avoid,34,// N = N + Idx * ElementSize;; // Avoid doing it for ElementSize of 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:13,Usability,simpl,simple,13,// Is this a simple intrinsic?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:16,Usability,simpl,simple,16,"// If this is a simple intrinsic (that is, we just need to add a def of; // a vreg, and uses for each arg operand, then translate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:81,Usability,Simpl,Simplest,81,// No target I know of cares about va_end. Certainly no in-tree target; // does. Simplest intrinsic ever!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:62,Energy Efficiency,reduce,reduce,62,"// We split the operation into a separate G_FADD/G_FMUL + the reduce,; // since the associativity doesn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:81,Performance,optimiz,optimize,81,"// We don't set HasCalls on MFI here yet because call lowering may decide to; // optimize into tail calls. Instead, we defer that to selection where a final; // scan is done to check if any instructions are calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:27,Deployability,patch,patchpoint,27,// FIXME: support invoking patchpoint and statepoint intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Update,Update,3,// Update successor info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:101,Safety,detect,detected,101,// Add a label to mark the beginning of the landing pad. Deletion of the; // landing pad can thus be detected via the MachineModuleInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:51,Modifiability,variab,variable,51,"// A dbg.declare describes the address of a source variable, so lower it; // into an indirect DBG_VALUE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:302,Performance,perform,perform,302,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:114,Testability,test,test,114,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:173,Testability,test,test,173,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:323,Testability,test,test,323,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:397,Testability,test,test,397,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:449,Testability,test,test,449,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:479,Testability,test,test,479,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:22,Testability,test,test,22,// Second-to-last bit-test with contiguous range: fall through to the; // target of the final bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:98,Testability,test,test,98,// Second-to-last bit-test with contiguous range: fall through to the; // target of the final bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:20,Testability,test,test,20,"// For the last bit test, fall through to Default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:43,Testability,test,test,43,"// Otherwise, fall through to the next bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:46,Testability,test,test,46,"// Since we're not going to use the final bit test, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:11,Availability,Failure,Failure,11,// CodeGen Failure MBB if we have not codegened it yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Usability,Clear,Clear,3,// Clear the Per-BB State.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:20,Performance,load,loads,20,// First create the loads to the guard/stack slot for the comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:20,Performance,load,load,20,// Generate code to load the content of the guard slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:238,Modifiability,variab,variable,238,"// This path is currently untestable on GlobalISel, since the only platform; // that needs this seems to be Windows, and we fall back on that currently.; // The code still lives here in case that changes.; // Silence warning about unused variable until the code below that uses; // 'GuardCheckFn' is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:49,Security,validat,validate,49,// The target provides a guard check function to validate the guard value.; // Generate a call to that function with the content of the guard slot as; // argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:100,Performance,load,load,100,"// If useLoadStackGuardNode returns true, generate LOAD_STACK_GUARD.; // Otherwise, emit a volatile load to retrieve the stack guard value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:9,Testability,test,test,9,// TODO: test using android subtarget when we support @llvm.thread.pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Performance,Perform,Perform,3,// Perform the comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:50,Availability,failure,failure,50,"// If the guard/stackslot do not equal, branch to failure MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Release,Release,3,// Release the memory used by the different maps we; // needed during the translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:83,Safety,avoid,avoid,83,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing freed memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:146,Safety,avoid,avoid,146,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing freed memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:89,Security,access,accessing,89,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing freed memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:67,Usability,Clear,Clear,67,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing freed memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Release,Release,3,"// Release the per-function state when we return, whether we succeeded or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Update,Update,3,// Update the live-in information for the new entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:396,Integrability,interface,interface,396,"//===- lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp - Legalizer ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implement an interface to specify and query how an illegal operation on a; // given type should be expanded.; //; // Issues to be resolved:; // + Make it fast.; // + Support weird types like i3, <7 x i3>, ...; // + Operations with more than one type (ICMP, CMPXCHG, intrinsics, ...); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:102,Performance,load,load,102,// Set defaults.; // FIXME: these two (G_ANYEXT and G_TRUNC?) can be legalized to the; // fundamental load/store Jakob proposed. Once loads & stores are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:134,Performance,load,loads,134,// Set defaults.; // FIXME: these two (G_ANYEXT and G_TRUNC?) can be legalized to the; // fundamental load/store Jakob proposed. Once loads & stores are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:52,Energy Efficiency,adapt,adapt,52,"// For vector types, we assume that the best way to adapt the number; // of elements is to the next larger number of elements type for which; // the vector type is legal, unless there is no such type. In that case,; // legalize towards a vector type with a smaller number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:52,Modifiability,adapt,adapt,52,"// For vector types, we assume that the best way to adapt the number; // of elements is to the next larger number of elements type for which; // the vector type is legal, unless there is no such type. In that case,; // legalize towards a vector type with a smaller number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:361,Testability,assert,asserts,361,"// The following needs to be a loop, as for now, we do allow needing to; // go over ""Unsupported"" bit sizes before finding a legalizable bit size.; // e.g. (s8, WidenScalar), (s9, Unsupported), (s32, Legal). if Size==8,; // we need to iterate over s9, and then to s32 to return (s32, Legal).; // If we want to get rid of the below loop, we should have stronger asserts; // when building the SizeAndActionsVecs, probably not allowing; // ""Unsupported"" unless at the ends of the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:56,Performance,cache,cache,56,"// FIXME: speed up this search, e.g. by using a results cache for repeated; // queries?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp:543,Performance,optimiz,optimizations,543,"//===- lib/CodeGen/GlobalISel/LegalizerPredicates.cpp - Predicates --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A library of predicate factories to use for LegalityPredicate.; //; //===----------------------------------------------------------------------===//; // Enable optimizations to work around MSVC debug mode bug in 32-bit:; // https://developercommunity.visualstudio.com/content/problem/1179643/msvc-copies-overaligned-non-trivially-copyable-par.html; // FIXME: Remove this when the issue is closed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp:56,Performance,optimiz,optimizations,56,// We have to disable runtime checks in order to enable optimizations. This is; // done for the entire file because the problem is actually observed in STL; // template functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:499,Integrability,wrap,wrapper,499,"//===-- llvm/CodeGen/GlobalISel/Legalizer.cpp -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the LegalizerHelper class to legalize individual; /// instructions and the LegalizePass wrapper pass for the primary; /// legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:25,Deployability,release,release,25,// Always disable it for release builds by preventing the observer from being; // installed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:82,Deployability,install,installed,82,// Always disable it for release builds by preventing the observer from being; // installed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:131,Availability,down,down,131,"// Perform legalization bottom up so we can DCE as we legalize.; // Traverse BB in RPOT and within each basic block, add insts top down,; // so when we pop_back_val in the legalization process, we traverse bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:3,Performance,Perform,Perform,3,"// Perform legalization bottom up so we can DCE as we legalize.; // Traverse BB in RPOT and within each basic block, add insts top down,; // so when we pop_back_val in the legalization process, we traverse bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:37,Deployability,update,updated,37,// This observer keeps the worklists updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:123,Integrability,wrap,wrapper,123,// We want both WorkListObserver as well as all the auxiliary observers (e.g.; // CSEInfo) to observe all changes. Use the wrapper observer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:7,Deployability,install,install,7,// Now install the observer as the delegate to MF.; // This will keep all the observers notified about new insertions/deletions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:3,Availability,Error,Error,3,// Error out if we couldn't legalize this instruction. We may want to; // fall back to DAG ISel instead in the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:50,Safety,abort,aborting,50,// Move illegal artifacts to RetryList instead of aborting because; // legalizing InstList may generate artifacts that allow; // ArtifactCombiner to combine away them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:182,Integrability,wrap,wrapper,182,"// If for some reason CSE was not enabled, make sure that we invalidate the; // CSEInfo object (as we currently declare that the analysis is preserved).; // The next time get on the wrapper is called, it will force it to recompute; // the analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:504,Integrability,wrap,wrapper,504,"//===-- llvm/CodeGen/GlobalISel/LegalizerHelper.cpp -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the LegalizerHelper class to legalize; /// individual instructions and the LegalizeMachineIR wrapper pass for the; /// primary legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:17,Availability,down,down,17,"/// Try to break down \p OrigTy into \p NarrowTy sized pieces.; ///; /// Returns the number of \p NarrowTy elements needed to reconstruct \p OrigTy,; /// with any leftover piece as type \p LeftoverTy; ///; /// Returns -1 in the first element of the pair if the breakdown is not; /// satisfiable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating additional instructions if we're just adding additional; // copies of padding bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:15,Modifiability,extend,extend,15,"// In the sign extend padding case, re-use the first all-signbit merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Safety,safe,safe,12,// It's not safe to eliminate the sign / zero extension of the return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:89,Integrability,rout,routines,89,"// For MEMCPY/MOMMOVE/MEMSET these will be the first use (the dst), as the; // mempy/etc routines return the same parameter. For other it will be the; // returned value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:35,Security,validat,validated,35,// Skip over the COPY that we just validated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:303,Modifiability,variab,variable,303,"// Some library functions that read FP state (fegetmode, fegetenv) write the; // state into a region in memory. IR intrinsics that do the same operations; // (get_fpmode, get_fpenv) return the state as integer value. To implement these; // intrinsics via the library functions, we need to use temporary variable,; // for example:; //; // %0:_(s32) = G_GET_FPMODE; //; // is transformed to:; //; // %1:_(p0) = G_FRAME_INDEX %stack.0; // BL &fegetmode; // %0:_(s32) = G_LOAD % 1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Performance,load,load,12,// Create a load from the temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:28,Performance,load,load,28,// FIXME: Need to split the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:20,Energy Efficiency,power,power-of-two,20,// TODO: Handle non-power-of-two types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:61,Modifiability,extend,extending,61,// So long as the new type has more bits than the bits we're extending we; // don't need to break it apart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:75,Modifiability,extend,extending,75,// We don't lose any non-extension bits by truncating the src and; // sign-extending the dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:159,Energy Efficiency,reduce,reduce,159,"// Widen SrcTy to WideTy. This does not affect the result, but since the; // user requested this size, it is probably better handled than SrcTy and; // should reduce the total number of legalization artifacts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,// Extend the source to a wider type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:74,Usability,simpl,simple,74,// Extracts from pointers can be handled only if they are really just; // simple integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid a shift in the degenerate case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:144,Energy Efficiency,efficient,efficient,144,"// We can convert this to:; // 1. Any extend iN to iM; // 2. SHL by M-N; // 3. [US][ADD|SUB|SHL]SAT; // 4. L/ASHR by M-N; //; // It may be more efficient to lower this to a min and a max operation in; // the higher precision arithmetic if the promoted operation isn't legal,; // but this decision is up to the target's lowering request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Modifiability,extend,extend,38,"// We can convert this to:; // 1. Any extend iN to iM; // 2. SHL by M-N; // 3. [US][ADD|SUB|SHL]SAT; // 4. L/ASHR by M-N; //; // It may be more efficient to lower this to a min and a max operation in; // the higher precision arithmetic if the promoted operation isn't legal,; // but this decision is up to the target's lowering request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:20,Modifiability,extend,extend,20,"// Shifts must zero-extend the RHS to preserve the unsigned quantity, and; // must not left shift the RHS to preserve the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:64,Modifiability,extend,extend,64,"// To determine if the result overflowed in the larger type, we extend the; // input to the larger type, do the multiply (checking if it overflows),; // then also check the high bits of the result to see if overflow happened; // there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:113,Modifiability,extend,extend,113,"// Overflow occurred if it occurred in the larger type, or if the high part; // of the result does not zero/sign-extend the low part. Check this second; // possibility first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:66,Modifiability,extend,extend,66,"// For signed, overflow occurred when the high part does not sign-extend; // the low part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:63,Modifiability,extend,extend,63,// Unsigned overflow occurred when the high part does not zero-extend the; // low part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:9,Modifiability,extend,extend,9,// First extend the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Perform,Perform,3,// Perform the operation at the larger size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Perform,Perform,3,"// Perform operation at larger width (any extension is fines here, high bits; // don't affect the result) and then truncate the result back to the; // original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Perform,Perform,3,"// Perform operation at larger width (any extension is fine here, high; // bits don't affect the result) and then truncate the result back to the; // original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:6,Safety,avoid,avoid,6,"// To avoid changing the bits of the constant due to extension to a larger; // type and then using G_FPTRUNC, we simply convert to a G_CONSTANT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:113,Usability,simpl,simply,113,"// To avoid changing the bits of the constant due to extension to a larger; // type and then using G_FPTRUNC, we simply convert to a G_CONSTANT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid changing the result vector type if the source element type was; // requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:4,Performance,Perform,Perform,4,"/// Perform a G_EXTRACT_VECTOR_ELT in a different sized vector element. If this; /// is casting to a vector with a smaller element size, perform multiple element; /// extracts and merge the results. If this is coercing to a vector with larger; /// elements, index the bitcasted vector and extract the target element with bit; /// operations. This is intended to force the indexing in the native register; /// size for architectures that can dynamically index the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:137,Performance,perform,perform,137,"/// Perform a G_EXTRACT_VECTOR_ELT in a different sized vector element. If this; /// is casting to a vector with a smaller element size, perform multiple element; /// extracts and merge the results. If this is coercing to a vector with larger; /// elements, index the bitcasted vector and extract the target element with bit; /// operations. This is intended to force the indexing in the native register; /// size for architectures that can dynamically index the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Energy Efficiency,power,powers,24,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:13,Integrability,depend,depends,13,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Usability,Clear,Clear,3,// Clear out the bits in the wide element,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:67,Availability,mask,masked,67,"// The value to insert has all zeros already, so stick it into the masked; // wide element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:4,Performance,Perform,Perform,4,"/// Perform a G_INSERT_VECTOR_ELT in a different sized vector element. If this; /// is increasing the element size, perform the indexing in the target element; /// type, and use bit operations to insert at the element position. This is; /// intended for architectures that can dynamically index the register file and; /// want to force indexing in the native register size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:116,Performance,perform,perform,116,"/// Perform a G_INSERT_VECTOR_ELT in a different sized vector element. If this; /// is increasing the element size, perform the indexing in the target element; /// type, and use bit operations to insert at the element position. This is; /// intended for architectures that can dynamically index the register file and; /// want to force indexing in the native register size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Energy Efficiency,power,powers,24,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:13,Integrability,depend,depends,13,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Performance,load,load,27,"// Promote to a byte-sized load if not loading an integral number of; // bytes. For example, promote EXTLOAD:i20 -> EXTLOAD:i24.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:39,Performance,load,loading,39,"// Promote to a byte-sized load if not loading an integral number of; // bytes. For example, promote EXTLOAD:i20 -> EXTLOAD:i24.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:29,Modifiability,extend,extending,29,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:39,Performance,load,load,39,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:106,Performance,load,load,106,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:89,Safety,avoid,avoid,89,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:87,Performance,load,load,87,"// The extra bits are guaranteed to be zero, since we stored them that; // way. A zext load from Wide thus automatically gives zext from MemVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:259,Availability,down,down,259,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:34,Energy Efficiency,power,power,34,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:155,Energy Efficiency,power,power-,155,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:561,Modifiability,extend,extend,561,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:8,Performance,load,load,8,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:51,Performance,load,loads,51,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:112,Performance,load,loads,112,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:309,Performance,load,load,309,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:361,Performance,load,load,361,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:34,Energy Efficiency,power,power,34,// This load needs splitting into power of 2 sized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:8,Performance,load,load,8,// This load needs splitting into power of 2 sized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:51,Performance,load,loads,51,// This load needs splitting into power of 2 sized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,Energy Efficiency,power,power,21,"// This is already a power of 2, but we still need to split this in half.; //; // Assume we're being asked to decompose an unaligned load.; // TODO: If this requires multiple splits, handle them all at once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:133,Performance,load,load,133,"// This is already a power of 2, but we still need to split this in half.; //; // Assume we're being asked to decompose an unaligned load.; // TODO: If this requires multiple splits, handle them all at once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:15,Energy Efficiency,power,power,15,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:189,Energy Efficiency,power,power,189,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:142,Modifiability,extend,extending,142,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:321,Modifiability,extend,extend,321,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating a store with a narrower source than result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,"// Extend to the next pow-2. If this store was itself the result of lowering,; // e.g. an s56 store being broken into s32 + s24, we might have a stored type; // that's wider than the stored size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:45,Modifiability,extend,extending,45,// Not sure how to interpret a bitcast of an extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:55,Performance,load,load,55,// Not sure how to interpret a bitcast of an extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Safety,detect,detected,38,"// For *signed* multiply, overflow is detected by checking:; // (hi != (lo >> bitwidth-1))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:189,Energy Efficiency,reduce,reduce,189,"// FIXME: We're missing a way to go back from LLT to llvm::Type to query the; // datalayout for the preferred alignment. Also there should be a target hook; // for this to allow targets to reduce the alignment and ignore the; // datalayout. e.g. AMDGPU should always use a 4-byte alignment, regardless of; // the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:102,Integrability,depend,depending,102,/// Operand \p Op is used on \p N sub-instructions. Fill \p Ops with \p N SrcOps; /// made from \p Op depending on operand type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,Performance,perform,perform,21,// Instructions that perform register split will be inserted in basic block; // where register is defined (basic block is in the next operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:191,Performance,perform,perform,191,// Requires compatible types. Otherwise SrcReg should have been defined by; // merge-like instruction that would get artifact combined. Most likely; // instruction that defines SrcReg has to perform more/fewer elements; // legalization compatible with NarrowTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:63,Performance,perform,perform,63,// Requires compatible types. Otherwise user of DstReg did not perform unmerge; // that should have been artifact combined. Most likely instruction that uses; // DstReg has to do more/fewer elements legalization compatible with NarrowTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:96,Testability,test,tests,96,// This attempts to lower part of LCMTy merge/unmerge sequence. Intended use; // is for old mir tests. Since the changes to more/fewer elements it should no; // longer be possible to generate MIR like this when starting from llvm-ir; // because LCMTy approach was replaced with merge/unmerge to vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:56,Availability,down,down,56,"// If the index is a constant, we can really break this down as you would; // expect, and index into the target size pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid out of bounds indexing the pieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:10,Modifiability,variab,variable,10,"// With a variable index, we can't perform the operation in a smaller type, so; // we're forced to expand this.; //; // TODO: We could emit a chain of compare/select to figure out which piece to; // index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:35,Performance,perform,perform,35,"// With a variable index, we can't perform the operation in a smaller type, so; // we're forced to expand this.; //; // TODO: We could emit a chain of compare/select to figure out which piece to; // index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:13,Performance,load,load,13,"// Split the load/store into PartTy sized pieces starting at Offset. If this; // is a load, return the new registers in ValRegs. For a store, each elements; // of ValRegs should be PartTy. Returns the next offset that needs to be; // handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:86,Performance,load,load,86,"// Split the load/store into PartTy sized pieces starting at Offset. If this; // is a load, return the new registers in ValRegs. For a store, each elements; // of ValRegs should be PartTy. Returns the next offset that needs to be; // handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:2,Availability,mask,mask,2,"/*mask,fpsem*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:19,Availability,mask,mask,19,"// Build a shuffle mask for the output, discovering on the fly which; // input vectors to use as shuffle operands (recorded in InputUsed).; // If building a suitable shuffle vector proves too hard, then bail; // out with useBuildVector set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,// The mask element. This indexes into the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:25,Availability,mask,mask,25,// The input vector this mask element indexes into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,// The mask element does not index into any input vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:11,Availability,mask,mask,11,// Add the mask index for the new shuffle vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,// The mask element. This indexes into the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:25,Availability,mask,mask,25,// The input vector this mask element indexes into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,"// The mask element is ""undef"" or indexes off the end of the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:43,Energy Efficiency,reduce,reduce,43,// Generate a tree of scalar operations to reduce the critical path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:29,Energy Efficiency,power,powers,29,"// If the types involved are powers of 2, we can generate intermediate vector; // ops, before generating a final reduction operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:9,Performance,Optimiz,Optimize,9,// TODO: Optimize if constant shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:161,Modifiability,refactor,refactoring,161,"// TODO: the symmetric MoreTy works for targets like, e.g. NEON.; // For targets, like e.g. MVE, the result is a predicated vector (i1).; // This will need some refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:10,Availability,mask,mask,10,// Extend mask to match new destination vector size with; // undef values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,// Extend mask to match new destination vector size with; // undef values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Availability,mask,mask,12,// Readjust mask for new input vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:10,Availability,mask,mask,10,// Adjust mask based on new input vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:79,Modifiability,extend,extended,79,// OpSegStart is where this destination segment would start in OpReg if it; // extended infinitely in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:60,Modifiability,extend,extend,60,"// The leftover reg is smaller than NarrowTy, so we need to extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:79,Modifiability,extend,extended,79,// OpSegStart is where this destination segment would start in OpReg if it; // extended infinitely in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:50,Availability,mask,mask,50,"// For count in blocks of 8 bits we don't have to mask high 4 bits before; // addition since count value sits in range {0,...,8} and 4 bits are enough; // to hold such binary values. After addition high 4 bits still hold count; // of set bits in high 4 bit block, set them to zero and get 8 bit result.; // B8Count = { B4Count + (B4Count >> 4) } & 0x0F0F0F0F",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:15,Performance,optimiz,optimized,15,// FIXME: Emit optimized urem by constant instead of letting it expand later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:58,Safety,avoid,avoiding,58,// These operations approximately do the following (while avoiding undefined; // shifts by BW):; // G_FSHL: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // G_FSHR: (X << (BW - (Z % BW))) | (Y >> (Z % BW)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:23,Energy Efficiency,power,powers,23,"// This only works for powers of 2, fallback to shifts if it fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:20,Modifiability,extend,extend,20,"// The step between extend is too large, split it by creating an intermediate; // extend instruction",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:82,Modifiability,extend,extend,82,"// The step between extend is too large, split it by creating an intermediate; // extend instruction",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:114,Availability,avail,available,114,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:193,Energy Efficiency,efficient,efficiently,193,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:97,Integrability,depend,depending,97,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:139,Performance,optimiz,optimization,139,"// Insert canonicalizes if it's possible we need to quiet to get correct; // sNaN behavior.; // Note this must be done here, and not as an optimization combine in the; // absence of a dedicate quiet-snan instruction as we're using an; // omni-purpose G_FCANONICALIZE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:30,Safety,safe,safe,30,"// If there are no nans, it's safe to simply replace this with the non-IEEE; // version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Usability,simpl,simply,38,"// If there are no nans, it's safe to simply replace this with the non-IEEE; // version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:30,Modifiability,variab,variable,30,// We lose information with a variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,Security,access,access,21,// Unmerge and allow access to each Src element for the artifact combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:57,Safety,detect,detect,57,"// TODO: If SADDSAT/SSUBSAT is legal, compare results to detect overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Availability,Mask,Mask,12,// AND with Mask leaves byte i unchanged and sets remaining bytes to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:55,Availability,Mask,Mask,55,// Low byte shifted left to place of high byte: (Src & Mask) << ShiftAmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:69,Availability,Mask,Mask,69,// High byte shifted right to place of low byte: (Src >> ShiftAmt) & Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:11,Availability,Mask,Mask,11,//{ (Src & Mask) >> N } | { (Src << N) & Mask },MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:41,Availability,Mask,Mask,41,//{ (Src & Mask) >> N } | { (Src << N) & Mask },MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Testability,test,test,27,// TODO: Try inverting the test with getInvertedFPClassTest like the DAG; // version,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:11,Availability,mask,masks,11,// Various masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Testability,Test,Tests,3,// Tests that involve more than one class should be processed first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Testability,test,test,27,// fcZero | fcSubnormal => test all exponent bits are 0; // TODO: Handle sign bit specific cases; // TODO: Handle inverted case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:53,Availability,mask,mask,53,// Turn the scalar condition into a vector condition mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Modifiability,extend,extended,38,"// The condition was potentially zero extended before, but we want a sign; // extended boolean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:78,Modifiability,extend,extended,78,"// The condition was potentially zero extended before, but we want a sign; // extended boolean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,optimiz,optimize,24,"// On Darwin, -Os means optimize for size without hurting performance, so; // only really optimize for size when -Oz (MinSize) is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:58,Performance,perform,performance,58,"// On Darwin, -Os means optimize for size without hurting performance, so; // only really optimize for size when -Oz (MinSize) is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:90,Performance,optimiz,optimize,90,"// On Darwin, -Os means optimize for size without hurting performance, so; // only really optimize for size when -Oz (MinSize) is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:50,Performance,load,load,50,// FIXME: check for the largest legal type we can load/store to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:32,Performance,load,load,32,"// For now, only use non-vector load / store's for the left-over pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Safety,safe,safety,27,// FIXME: check for mem op safety and legality of the types. Not all of; // SDAGisms map cleanly to GISel concepts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:127,Performance,load,load,127,"// If the new LLT cannot cover all of the remaining bits, then consider; // issuing a (or a pair of) unaligned and overlapping load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,"// Extend the byte value to the larger type, and then multiply by a magic; // value 0x010101... in order to replicate it across every byte.; // Unless it's zero, in which case just emit a larger G_CONSTANT 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,load,load,24,// Issuing an unaligned load / store pair that overlaps with the previous; // pair. Adjust the offset accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:328,Integrability,depend,depending,328,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:33,Performance,load,load,33,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:123,Performance,load,load,123,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:253,Performance,load,loaded,253,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:294,Performance,load,loads,294,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,load,load,24,// Issuing an unaligned load / store pair that overlaps with the previous; // pair. Adjust the offset accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:26,Security,access,accesses,26,// Construct MMOs for the accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:14,Performance,load,load,14,// Create the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:28,Performance,perform,perform,28,"// Memmove requires that we perform the loads first before issuing the stores.; // Apart from that, this loop is pretty much doing the same thing as the; // memcpy codegen function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:40,Performance,load,loads,40,"// Memmove requires that we perform the loads first before issuing the stores.; // Apart from that, this loop is pretty much doing the same thing as the; // memcpy codegen function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:25,Performance,load,load,25,// Construct MMO for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:14,Performance,load,load,14,// Create the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,load,loaded,24,// Now store the values loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:16,Performance,optimiz,optimize,16,// Don't try to optimize volatile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:396,Integrability,interface,interface,396,"//===- lib/CodeGen/GlobalISel/LegalizerInfo.cpp - Legalizer ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implement an interface to specify and query how an illegal operation on a; // given type should be expanded.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:24,Modifiability,variab,variable,24,"// G_UNMERGE_VALUES has variable number of operands, but there is only; // one source type and one destination type as all destinations must be the; // same type. So, get the last operand if TypeIdx == 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:33,Performance,cache,cache,33,// FIXME: probably we'll need to cache the results here somehow?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:113,Availability,down,down,113,// We must only record actions once for each TypeIdx; otherwise we'd; // try to legalize operands multiple times down the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:7,Performance,Load,LoadStoreOpt,7,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:51,Performance,optimiz,optimizations,51,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:416,Performance,Load,LoadStoreOpt,416,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:429,Performance,optimiz,optimization,429,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:20,Usability,simpl,simple,20,// Just recognize a simple case for now. In future we'll need to match; // indexing patterns for base + index + constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:126,Performance,load,load,126,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:137,Performance,scalab,scalable,137,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:25,Security,access,access,25,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:113,Security,access,access,113,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:149,Testability,test,tests,149,"// Try to prove that there is aliasing, or that there is no aliasing. Either; // way, we can return now. If nothing can be proved, proceed with more tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:59,Safety,hazard,hazard,59,/// Returns true if the instruction creates an unavoidable hazard that; /// forces a boundary between store merge candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:3,Performance,Perform,Perform,3,// Perform the actual merging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:226,Availability,avail,available,226,"// We know that all the stores are consecutive and there are no aliasing; // operations in the range. However, the values that are being stored may be; // generated anywhere before each store. To ensure we have the values; // available, we materialize the wide value and new store at the place of the; // final store in the merge sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:133,Performance,load,loads,133,"// Mimic the SDAG behaviour here and don't try to do anything for unknown; // values. In future, we should also support the cases of loads and; // extracted vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:164,Performance,load,load,164,"// We know that the stores in the candidate are adjacent.; // Now we need to check if any potential aliasing instructions recorded; // during the search alias with load/stores added to the candidate after.; // For example, if we have the candidate:; // C.Stores = [ST1, ST2, ST3, ST4]; // and after seeing ST2 we saw a load LD1, which did not alias with ST1 or; // ST2, then we would have recorded it into the PotentialAliases structure; // with the associated index value of ""1"". Then we see ST3 and ST4 and add; // them to the candidate group. We know that LD1 does not alias with ST1 or; // ST2, since we already did that check. However we don't yet know if it; // may alias ST3 and ST4, so we perform those checks now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:319,Performance,load,load,319,"// We know that the stores in the candidate are adjacent.; // Now we need to check if any potential aliasing instructions recorded; // during the search alias with load/stores added to the candidate after.; // For example, if we have the candidate:; // C.Stores = [ST1, ST2, ST3, ST4]; // and after seeing ST2 we saw a load LD1, which did not alias with ST1 or; // ST2, then we would have recorded it into the PotentialAliases structure; // with the associated index value of ""1"". Then we see ST3 and ST4 and add; // them to the candidate group. We know that LD1 does not alias with ST1 or; // ST2, since we already did that check. However we don't yet know if it; // may alias ST3 and ST4, so we perform those checks now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:697,Performance,perform,perform,697,"// We know that the stores in the candidate are adjacent.; // Now we need to check if any potential aliasing instructions recorded; // during the search alias with load/stores added to the candidate after.; // For example, if we have the candidate:; // C.Stores = [ST1, ST2, ST3, ST4]; // and after seeing ST2 we saw a load LD1, which did not alias with ST1 or; // ST2, then we would have recorded it into the PotentialAliases structure; // with the associated index value of ""1"". Then we see ST3 and ST4 and add; // them to the candidate group. We know that LD1 does not alias with ST1 or; // ST2, since we already did that check. However we don't yet know if it; // may alias ST3 and ST4, so we perform those checks now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:34,Safety,hazard,hazards,34,"// Now we've checked for aliasing hazards, merge any stores left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding volatile or ordered stores to the candidate. We already have a; // check for this in instMayAlias() but that only get's called later between; // potential aliasing hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:180,Safety,hazard,hazards,180,// Avoid adding volatile or ordered stores to the candidate. We already have a; // check for this in instMayAlias() but that only get's called later between; // potential aliasing hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:26,Usability,simpl,simple,26,// We only handle merging simple stores of 1-4 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:89,Safety,hazard,hazard,89,// We do a simple search for mergeable stores prior to this one.; // Any potential alias hazard along the way terminates the search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:11,Usability,simpl,simple,11,// We do a simple search for mergeable stores prior to this one.; // Any potential alias hazard along the way terminates the search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:13,Safety,safe,safe,13,// This is a safe instruction we can look past.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:11,Performance,cache,cached,11,// Already cached sizes for this address space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:99,Deployability,pipeline,pipeline,99,"// Since the IRTranslator only emits constants into the entry block, and the; // rest of the GISel pipeline generally emits constants close to their users,; // we only localize instructions in the entry block here. This might change if; // we start doing CSE across blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:10,Performance,Tune,Tune,10,// FIXME: Tune this more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:3,Deployability,Update,Update,3,// Update the user reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:99,Availability,down,down,99,"// For each already-localized instruction which has multiple users, then we; // scan the block top down from the current position until we hit one of them.; // FIXME: Consider doing inst duplication if live ranges are very long due to; // many users, but this case may be better served by regalloc improvements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:114,Energy Efficiency,reduce,reduce,114,// Keep track of the instructions we localized. We'll do a second pass of; // intra-block localization to further reduce live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LostDebugLocObserver.cpp:409,Availability,checkpoint,checkpoints,409,"//===----- llvm/CodeGen/GlobalISel/LostDebugLocObserver.cpp -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// Tracks DebugLocs between checkpoints and verifies that they are transferred.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LostDebugLocObserver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LostDebugLocObserver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp:37,Usability,usab,usable,37,// Insert $noreg if we didn't find a usable constant and had to drop it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp:39,Performance,load,load,39,// This may be a size or type changing load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,Availability,repair,repair,40,// By default we assume we will have to repair something.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:24,Availability,down,down,24,"// Each part of a break down needs to end up in a different register.; // In other word, Reg assignment does not match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:32,Usability,simpl,simple,32,"// Reg is free of assignment, a simple assignment will make the; // register bank to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:43,Availability,repair,repairing,43,// An empty range of new register means no repairing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:17,Availability,repair,repairing,17,"// Assume we are repairing a use and thus, the original reg will be; // the source of the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:90,Availability,repair,repairing,90,"// Assume we are repairing a use and thus, the original reg will be; // the source of the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:9,Availability,repair,repair,9,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:74,Availability,repair,repairing,74,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:33,Availability,repair,repair,33,"// Build the instruction used to repair, then clone it at the right; // places. Avoiding buildCopy bypasses the check that Src and Dst have the; // same types because the type is a placeholder when this function is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:80,Safety,Avoid,Avoiding,80,"// Build the instruction used to repair, then clone it at the right; // places. Avoiding buildCopy bypasses the check that Src and Dst have the; // same types because the type is a placeholder when this function is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:119,Availability,down,down,119,"// If MO does not have a register bank, we should have just been; // able to set one unless we have to break the value down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:326,Availability,avail,available,326,"// Def: Val <- NewDefs; // Same number of values: copy; // Different number: Val = build_sequence Defs1, Defs2, ...; // Use: NewSources <- Val.; // Same number of values: copy.; // Different number: Src1, Src2, ... =; // extract_value Val, Src1Begin, Src1Len, Src2Begin, Src2Len, ...; // We should remember that this value is available somewhere else to; // coalesce the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:9,Availability,repair,repair,9,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:74,Availability,repair,repairing,74,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:66,Availability,repair,repair,66,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:466,Availability,repair,repairing,466,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,Safety,avoid,avoid,40,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:306,Usability,simpl,simply,306,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,Availability,repair,repairing,40,// Return the legalization cost of that repairing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:120,Availability,repair,repairing,120,"// If none of the mapping worked that means they are all impossible.; // Thus, pick the first one and set an impossible repairing point.; // It will trigger the failed isel mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:93,Availability,repair,repairing,93,"// Splitting should only occur for PHIs or between terminators,; // because we only do local repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:15,Availability,repair,repair,15,// We split to repair the use of a phi or a terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:29,Availability,repair,repair,29,"// At this point, we need to repair a defintion of a terminator.; // Technically we need to fix the def of MI on all outgoing; // edges of MI to keep the repairing local. In other words, we; // will create several definitions of the same register. This; // does not work for SSA unless that definition is a physical; // register.; // However, there are other cases where we can get away with; // that while still keeping the repairing local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:154,Availability,repair,repairing,154,"// At this point, we need to repair a defintion of a terminator.; // Technically we need to fix the def of MI on all outgoing; // edges of MI to keep the repairing local. In other words, we; // will create several definitions of the same register. This; // does not work for SSA unless that definition is a physical; // register.; // However, there are other cases where we can get away with; // that while still keeping the repairing local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:425,Availability,repair,repairing,425,"// At this point, we need to repair a defintion of a terminator.; // Technically we need to fix the def of MI on all outgoing; // edges of MI to keep the repairing local. In other words, we; // will create several definitions of the same register. This; // does not work for SSA unless that definition is a physical; // register.; // However, there are other cases where we can get away with; // that while still keeping the repairing local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:45,Availability,repair,repair,45,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:943,Availability,repair,repairing,943,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1044,Availability,down,down,1044,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1081,Availability,repair,repairing,1081,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1501,Availability,repair,repairing,1501,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1614,Availability,repair,repairing,1614,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1126,Deployability,patch,patch,1126,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:340,Testability,Assert,Assert,340,"// We are going to split every outgoing edges.; // Check that this is possible.; // FIXME: The machine representation is currently broken; // since it also several terminators in one basic block.; // Because of that we would technically need a way to get; // the targets of just one terminator to know which edges; // we have to split.; // Assert that we do not hit the ill-formed representation.; // If there are other terminators before that one, some of; // the outgoing edges may not be dominated by this definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:35,Availability,repair,repair,35,// We will split all the edges and repair there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:23,Availability,repair,repair,23,"// There is nothing to repair, but we may actually lie on; // the repairing cost because of the PHIs already proceeded; // as already stated.; // Though the code will be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:66,Availability,repair,repairing,66,"// There is nothing to repair, but we may actually lie on; // the repairing cost because of the PHIs already proceeded; // as already stated.; // Though the code will be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:27,Availability,repair,repairing,27,"// We need to do non-local repairing. Basically, patch all; // the uses (i.e., phis) that we already proceeded.; // For now, just say this mapping is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:49,Deployability,patch,patch,49,"// We need to do non-local repairing. Basically, patch all; // the uses (i.e., phis) that we already proceeded.; // For now, just say this mapping is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:190,Availability,repair,repairing,190,"// Moreover, to realize this mapping, the register bank of each operand must; // match this mapping. In other words, we may need to locally reassign the; // register banks. Account for that repairing cost as well.; // In this context, local means in the surrounding of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:36,Availability,repair,repairing,36,// Find the insertion point for the repairing code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:41,Availability,repair,repairing,41,// Check that the materialization of the repairing is possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:34,Availability,repair,repair,34,// Account for the split cost and repair cost.; // Unless the cost is already saturated or we do not care about the cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:37,Availability,repair,repairing,37,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:67,Availability,repair,repairing,67,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:151,Availability,down,down,151,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:245,Availability,repair,repairing,245,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:344,Availability,repair,repairing,344,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:515,Availability,repair,repairing,515,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:82,Integrability,depend,depends,82,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:28,Availability,repair,repair,28,// This is an impossible to repair cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:60,Availability,repair,repair,60,"// We should not need more than a couple of instructions to repair; // an assignment. In other words, the computation should not; // overflow because the repairing cost is free of basic block; // frequency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:154,Availability,repair,repairing,154,"// We should not need more than a couple of instructions to repair; // an assignment. In other words, the computation should not; // overflow because the repairing cost is free of basic block; // frequency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:38,Availability,repair,repair,38,"// Stop looking into what it takes to repair, this is already; // too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:80,Availability,repair,repairing,80,// No need to accumulate more cost information.; // We need to still gather the repairing information though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:20,Availability,repair,repairing,20,"// First, place the repairing code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:11,Modifiability,rewrite,rewrite,11,"// Second, rewrite the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:16,Availability,repair,repairing,16,// Remember the repairing placement for all the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:46,Availability,repair,repair,46,"// Default is, we are going to insert code to repair OpIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:3,Availability,Repair,Repairings,3,"// Repairings for definitions happen after MI, uses happen before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:6,Availability,repair,repair,6,"// We repair a use of a phi, we may need to split the related edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:23,Availability,repair,repairing,23,// We cannot hoist the repairing code in the predecessor.; // Split the edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:56,Deployability,update,update,56,"// Since we do not support splitting, we do not need to update; // liveness and such, so do not do anything with P.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:192,Deployability,update,update,192,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:368,Deployability,update,update,368,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:505,Deployability,update,update,505,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:578,Security,access,access,578,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:77,Integrability,depend,depending,77,"// Otherwise the insertion point is just the current or next; // instruction depending on Before. I.e., there is nothing to do; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:16,Availability,repair,repairing,16,"// If we end up repairing twice at the same place before materializing the; // insertion point, we may think we have to split an edge twice.; // We should have a factory for the insert point such that identical points; // are the same instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:223,Safety,avoid,avoid,223,"// At this point we know both costs hold sensible values.; // If both values have a different base frequency, there is no much; // we can do but to scale everything.; // However, if they have the same base frequency we can avoid making; // complicated computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:103,Safety,avoid,avoiding,103,// The base costs are comparable so we may only keep the relative; // value to increase our chances of avoiding overflows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:457,Deployability,pipeline,pipeline,457,"//===- llvm/CodeGen/GlobalISel/Utils.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file This file implements the utility functions used by the GlobalISel; /// pipeline.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:15,Testability,log,logical,15,// FIXME: This logical is mostly duplicated with; // DeadMachineInstructionElim::isDead. Why is LOCAL_ESCAPE not considered in; // MachineInstr::isLabel?; // Don't delete frame allocation labels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:149,Availability,error,error,149,// Print the function name explicitly if we don't have a debug location (which; // makes the diagnostic less useful) or if we're going to emit a raw error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:3,Performance,Perform,Perform,3,// Perform irregular split. Leftover is last element of RegPieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:35,Security,access,access,35,// Irregular split. Provide direct access to all elements for artifact; // combiner using unmerge to elements. Then build vectors with NumElts; // elements. Remaining element(s) will be (used to build vector) Leftover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:190,Integrability,wrap,wrapper,190,"// FIXME: These operations were unfortunately named. fminnum/fmaxnum do not; // follow the IEEE behavior for signaling nans and follow libm's fmin/fmax,; // and currently there isn't a nice wrapper in APFloat for the version with; // correct snan handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:123,Usability,simpl,simplify,123,"// If all elements are undefined, this shuffle can be considered a splat.; // Return 0 for better potential for callers to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1401,Availability,avail,available,1401,"------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2933,Energy Efficiency,efficient,efficient,2933," /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:578,Modifiability,variab,variable,578,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:765,Modifiability,variab,variable,765,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:816,Modifiability,variab,variable,816,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:847,Modifiability,variab,variable,847,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:973,Modifiability,variab,variable,973,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1123,Modifiability,variab,variable,1123,"----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the varia",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1321,Modifiability,variab,variable,1321,"------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1439,Modifiability,variab,variable,1439,"mentation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1941,Modifiability,variab,variable,1941," /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2067,Modifiability,variab,variable,2067," /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2212,Modifiability,variab,variable,2212,"mplete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2340,Modifiability,Variab,Variables,2340,"ineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A mac",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2479,Modifiability,variab,variable,2479,"m two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2577,Modifiability,Variab,Variable,2577,"of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2651,Modifiability,variab,variable,2651,"of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3234,Modifiability,variab,variables,3234," value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3478,Modifiability,variab,variable,3478,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3525,Modifiability,variab,variable,3525,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3537,Modifiability,variab,variable,3537,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3617,Modifiability,variab,variable,3617,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3971,Modifiability,variab,variables,3971,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3990,Modifiability,variab,variable,3990,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:4059,Modifiability,variab,variable,4059,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1504,Performance,perform,perform,1504,"d VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1953,Performance,perform,perform,1953," /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3175,Performance,perform,perform,3175," value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:202,Energy Efficiency,consumption,consumption,202,"// Limit for the maximum number of stack slots we should track, past which we; // will ignore any spills. InstrRefBasedLDV gathers detailed information on all; // stack slots which leads to high memory consumption, and in some scenarios; // (such as asan with very many locals) the working set of the function can be; // very large, causing many spills. In these scenarios, it is very unlikely that; // the developer has hundreds of variables live at the same time that they're; // carefully thinking about -- instead, they probably autogenerated the code.; // When this happens, gracefully stop tracking excess spill slots, rather than; // consuming all the developer's memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:433,Modifiability,variab,variables,433,"// Limit for the maximum number of stack slots we should track, past which we; // will ignore any spills. InstrRefBasedLDV gathers detailed information on all; // stack slots which leads to high memory consumption, and in some scenarios; // (such as asan with very many locals) the working set of the function can be; // very large, causing many spills. In these scenarios, it is very unlikely that; // the developer has hundreds of variables live at the same time that they're; // carefully thinking about -- instead, they probably autogenerated the code.; // When this happens, gracefully stop tracking excess spill slots, rather than; // consuming all the developer's memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:937,Availability,avail,available,937,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:55,Modifiability,variab,variable,55,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:81,Modifiability,variab,variable,81,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:356,Modifiability,variab,variable,356,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:483,Modifiability,variab,variable,483,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:518,Modifiability,variab,variable,518,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:825,Modifiability,variab,variable,825,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1001,Modifiability,variab,variable,1001,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:291,Performance,load,loaded,291,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:961,Safety,detect,detect,961,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:29,Modifiability,variab,variable,29,"/// Record of all changes in variable locations at a block position. Awkwardly; /// we allow inserting either before or after the point: MBB != nullptr; /// indicates it's before, otherwise after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:116,Modifiability,variab,variable,116,"/// Local cache of what-value-is-in-what-LocIdx. Used to identify differences; /// between TransferTrackers view of variable locations and MLocTrackers. For; /// example, MLocTracker observes all clobbers, but TransferTracker lazily; /// does not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Performance,cache,cache,10,"/// Local cache of what-value-is-in-what-LocIdx. Used to identify differences; /// between TransferTrackers view of variable locations and MLocTrackers. For; /// example, MLocTracker observes all clobbers, but TransferTracker lazily; /// does not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Performance,cache,cache,14,/// Temporary cache of DBG_VALUEs to be entered into the Transfers collection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:100,Availability,avail,available,100,"/// Record of a use-before-def: created when a value that's live-in to the; /// current block isn't available in any machine location, but it will be; /// defined in this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:18,Modifiability,variab,variable,18,"/// Value of this variable, def'd in block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:21,Modifiability,variab,variable,21,/// Identity of this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:15,Modifiability,variab,variable,15,/// Additional variable properties.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:15,Modifiability,variab,variables,15,/// The set of variables that are in UseBeforeDefs and can become a location; /// once the relevant value is defined. An element being erased from this; /// collection prevents the use-before-def materializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variable,10,"/// For a variable \p Var with the live-in value \p Value, attempts to resolve; /// the DbgValue to a concrete DBG_VALUE, emitting that value and loading the; /// tracking information to track Var throughout the block.; /// \p ValueToLoc is a map containing the best known location for every; /// ValueIDNum that Value may use.; /// \p MBB is the basic block that we are loading the live-in value for.; /// \p DbgOpStore is the map containing the DbgOpID->DbgOp mapping needed to; /// determine the values used by Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:146,Performance,load,loading,146,"/// For a variable \p Var with the live-in value \p Value, attempts to resolve; /// the DbgValue to a concrete DBG_VALUE, emitting that value and loading the; /// tracking information to track Var throughout the block.; /// \p ValueToLoc is a map containing the best known location for every; /// ValueIDNum that Value may use.; /// \p MBB is the basic block that we are loading the live-in value for.; /// \p DbgOpStore is the map containing the DbgOpID->DbgOp mapping needed to; /// determine the values used by Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:371,Performance,load,loading,371,"/// For a variable \p Var with the live-in value \p Value, attempts to resolve; /// the DbgValue to a concrete DBG_VALUE, emitting that value and loading the; /// tracking information to track Var throughout the block.; /// \p ValueToLoc is a map containing the best known location for every; /// ValueIDNum that Value may use.; /// \p MBB is the basic block that we are loading the live-in value for.; /// \p DbgOpStore is the map containing the DbgOpID->DbgOp mapping needed to; /// determine the values used by Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:51,Availability,avail,available,51,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:243,Availability,avail,available,243,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:541,Availability,avail,available,541,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:591,Availability,recover,recover,591,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:662,Modifiability,variab,variable,662,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:591,Safety,recover,recover,591,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:49,Modifiability,variab,variable,49,"// If the value has no location, we can't make a variable location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:92,Modifiability,variab,variable,92,"// If we cannot produce a valid value for the LiveIn value within this; // block, skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Availability,avail,available,23,"// The LiveIn value is available at block entry, begin tracking and record; // the transfer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:29,Modifiability,variab,variable,29,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:141,Modifiability,variab,variable,141,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:181,Modifiability,variab,variable,181,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:216,Modifiability,variab,variables,216,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:332,Modifiability,variab,variable,332,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:4,Performance,Load,Load,4,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,"// Is there a variable that wants a location for this value? If not, skip.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Modifiability,variab,variables,11,// Now map variables to their picked LocIdxes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:61,Availability,avail,available,61,"/// Record that \p Var has value \p ID, a value that becomes available; /// later in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:115,Modifiability,variab,variable,115,"/// After the instruction at index \p Inst and position \p pos has been; /// processed, check whether it defines a variable value in a use-before-def.; /// If so, and the variable value hasn't changed since the start of the; /// block, create a DBG_VALUE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:171,Modifiability,variab,variable,171,"/// After the instruction at index \p Inst and position \p pos has been; /// processed, check whether it defines a variable value in a use-before-def.; /// If so, and the variable value hasn't changed since the start of the; /// block, create a DBG_VALUE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:113,Availability,avail,available,113,// Map of values to the locations that store them for every value used by; // the variables that may have become available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:82,Modifiability,variab,variables,82,// Map of values to the locations that store them for every value used by; // the variables that may have become available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:98,Modifiability,variab,variables,98,// Populate ValueToLoc with illegal default mappings for every value used by; // any UseBeforeDef variables for this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,"// Is there a variable that wants a location for this value? If not, skip.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:84,Modifiability,variab,variable,84,"// Using the map of values to locations, produce a final set of values for; // this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:63,Availability,avail,available,63,"// If at least one value used by this debug value is no longer available,; // i.e. one of the values was killed before we finished defining all of; // the values used by this variable, discard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:175,Modifiability,variab,variable,175,"// If at least one value used by this debug value is no longer available,; // i.e. one of the values was killed before we finished defining all of; // the values used by this variable, discard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Modifiability,variab,variable,11,"// Is this variable location a candidate to be an entry value. First,; // should we be trying this at all?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variable,10,"// Is the variable appropriate for entry values (i.e., is a parameter).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Modifiability,variab,variable,33,// Is the value assigned to this variable still the entry value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variable,10,// Emit a variable location using an entry value expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Modifiability,variab,variable,13,/// Change a variable value after encountering a DBG_VALUE inside a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Modifiability,variab,variable,23,"/// Handle a change in variable location within a block. Terminate the; /// variables current location, and record the value it now refers to, so; /// that we can detect location transfers later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:76,Modifiability,variab,variables,76,"/// Handle a change in variable location within a block. Terminate the; /// variables current location, and record the value it now refers to, so; /// that we can detect location transfers later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:163,Safety,detect,detect,163,"/// Handle a change in variable location within a block. Terminate the; /// variables current location, and record the value it now refers to, so; /// that we can detect location transfers later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Modifiability,variab,variable,16,"// Every active variable mapping for NewLoc will be cleared, no; // need to track individual variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,Modifiability,variab,variables,93,"// Every active variable mapping for NewLoc will be cleared, no; // need to track individual variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:52,Usability,clear,cleared,52,"// Every active variable mapping for NewLoc will be cleared, no; // need to track individual variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:124,Availability,recover,recover,124,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:273,Availability,recover,recovered,273,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:64,Modifiability,variab,variable,64,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:124,Safety,recover,recover,124,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:273,Safety,recover,recovered,273,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:20,Modifiability,variab,variable,20,// What was the old variable value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:156,Deployability,update,updated,156,/// Overload that takes an explicit value \p OldValue for when the value in; /// \p MLoc has changed and the TransferTracker's locations have not been; /// updated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,Availability,recover,recover,93,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Modifiability,variab,variable,25,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,Safety,recover,recover,93,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:61,Modifiability,variab,variable,61,"// If there is no location, and we weren't asked to make the variable; // explicitly undef, then stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Availability,recover,recover,11,// Try and recover a few more locations with entry values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Safety,recover,recover,11,// Try and recover a few more locations with entry values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:19,Modifiability,variab,variables,19,// Examine all the variables based on this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Integrability,depend,depends,58,"// If no new location has been found, every variable that depends on this; // MLoc is dead, so end their existing MLoc->Var mappings as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Modifiability,variab,variable,44,"// If no new location has been found, every variable that depends on this; // MLoc is dead, so end their existing MLoc->Var mappings as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Modifiability,variab,variable,16,"// Re-state the variable location: if there's no replacement then NewLoc; // is std::nullopt and a $noreg DBG_VALUE will be created. Otherwise, a; // DBG_VALUE identifying the alternative location will be emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Update,Update,3,// Update machine locations <=> variable locations maps. Defer updating; // ActiveMLocs to avoid invalidating the ActiveMLocIt iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:32,Modifiability,variab,variable,32,// Update machine locations <=> variable locations maps. Defer updating; // ActiveMLocs to avoid invalidating the ActiveMLocIt iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:91,Safety,avoid,avoid,91,// Update machine locations <=> variable locations maps. Defer updating; // ActiveMLocs to avoid invalidating the ActiveMLocIt iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variables,10,// Remove variables from ActiveMLocs if they no longer use any other MLocs; // due to being killed by this clobber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Modifiability,variab,variables,13,/// Transfer variables based on \p Src to be based on \p Dst. This handles; /// both register copies as well as spills and restores. Creates DBG_VALUEs; /// describing the movement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:108,Modifiability,variab,variable,108,"// Does Src still contain the value num we expect? If not, it's been; // clobbered in the meantime, and our variable locations are stale.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:142,Modifiability,variab,variables,142,// assert(ActiveMLocs[Dst].size() == 0);; //^^^ Legitimate scenario on account of un-clobbered slot being assigned to?; // Move set of active variables from one location to another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Testability,assert,assert,3,// assert(ActiveMLocs[Dst].size() == 0);; //^^^ Legitimate scenario on account of un-clobbered slot being assigned to?; // Move set of active variables from one location to another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:12,Modifiability,variab,variable,12,// For each variable based on Src; create a location at Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Update,Update,3,// Update all instances of Src in the variable's tracked values to Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:38,Modifiability,variab,variable,38,// Update all instances of Src in the variable's tracked values to Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:22,Availability,failure,failure,22,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Safety,Detect,Detect,3,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:56,Safety,avoid,avoids,56,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Availability,mask,mask,33,"// Don't clobber SP, even if the mask says it's clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:119,Deployability,update,update,119,"// If all locations are valid, accumulate them into our list of; // MachineOperands. For any spilled locations, either update the indirectness; // register or apply the appropriate transformations in the DIExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:17,Modifiability,variab,variables,17,"// TODO: support variables that are located in spill slots, with non-zero; // offsets from the start of the spill slot. It would require some more; // complex DIExpression calculations. This doesn't seem to be produced by; // LLVM right now, so don't try and support it.; // Accept no-subregister slots and subregisters where the offset is zero.; // The consumer should already have type information to work out how large; // the variable is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:430,Modifiability,variab,variable,430,"// TODO: support variables that are located in spill slots, with non-zero; // offsets from the start of the spill slot. It would require some more; // complex DIExpression calculations. This doesn't seem to be produced by; // LLVM right now, so don't try and support it.; // Accept no-subregister slots and subregisters where the offset is zero.; // The consumer should already have type information to work out how large; // the variable is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:100,Modifiability,variab,variables,100,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:206,Modifiability,Variab,Variables,206,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:351,Modifiability,variab,variable,351,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:560,Modifiability,variab,variable,560,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:676,Safety,avoid,avoid,676,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:428,Usability,simpl,simple,428,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Modifiability,variab,variable,34,"// This is something like an NRVO variable, where the pointer has been; // spilt to the stack. It should end up being a memory location, with; // the pointer to the variable loaded off the stack with a deref:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:165,Modifiability,variab,variable,165,"// This is something like an NRVO variable, where the pointer has been; // spilt to the stack. It should end up being a memory location, with; // the pointer to the variable loaded off the stack with a deref:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:174,Performance,load,loaded,174,"// This is something like an NRVO variable, where the pointer has been; // spilt to the stack. It should end up being a memory location, with; // the pointer to the variable loaded off the stack with a deref:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:153,Modifiability,variab,variable,153,"// TODO: Figure out how to handle deref size issues for variadic; // values.; // We're loading a value off the stack that's not the same size as the; // variable. Add / subtract stack offset, explicitly deref with a; // size, and add DW_OP_stack_value if not already present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:87,Performance,load,loading,87,"// TODO: Figure out how to handle deref size issues for variadic; // values.; // We're loading a value off the stack that's not the same size as the; // variable. Add / subtract stack offset, explicitly deref with a; // size, and add DW_OP_stack_value if not already present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:5,Modifiability,variab,variable,5,"// A variable with no size ambiguity, but with extra elements in it's; // expression. Manually dereference the stack location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:133,Performance,load,loaded,133,"// Where in the stack slot is this value defined -- i.e., what size of value; // is this? An important question, because it could be loaded into a register; // from the stack at some point. Happily the memory operand will tell us; // the size written to the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:120,Modifiability,variab,variable,120,"// That index is not tracked. This is suprising, and unlikely to ever; // occur, but the safe action is to indicate the variable is optimised out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,Safety,safe,safe,89,"// That index is not tracked. This is suprising, and unlikely to ever; // occur, but the safe action is to indicate the variable is optimised out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:96,Modifiability,variab,variable,96,"// If there are no instructions in this lexical scope, do no location tracking; // at all, this variable shouldn't get a legitimate location range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:47,Modifiability,variab,variables,47,"// If we're preparing for the second analysis (variables), the machine value; // locations are already solved, and we report this DBG_VALUE and the value; // it refers to to VLocTracker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Modifiability,variab,variable,23,"// Feed defVar the new variable location, or if this is a DBG_VALUE $noreg,; // feed defVar None.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Modifiability,variab,variable,58,"// If performing final tracking of transfers, report this variable definition; // to the TransferTracker too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,Performance,perform,performing,6,"// If performing final tracking of transfers, report this variable definition; // to the TransferTracker too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Performance,optimiz,optimizations,11,"// Various optimizations may have happened to the value during codegen,; // recorded in the value substitution table. Apply any substitutions to; // the instruction / operand number in this DBG_INSTR_REF, and collect; // any subregister extractions performed during optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:249,Performance,perform,performed,249,"// Various optimizations may have happened to the value during codegen,; // recorded in the value substitution table. Apply any substitutions to; // the instruction / operand number in this DBG_INSTR_REF, and collect; // any subregister extractions performed during optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:266,Performance,optimiz,optimization,266,"// Various optimizations may have happened to the value during codegen,; // recorded in the value substitution table. Apply any substitutions to; // the instruction / operand number in this DBG_INSTR_REF, and collect; // any subregister extractions performed during optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:118,Performance,optimiz,optimized,118,"// Default machine value number is <None> -- if no instruction defines; // the corresponding value, it must have been optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:273,Modifiability,variab,variable,273,"// Permit the debug-info to be completely wrong: identifying a nonexistant; // operand, or one that is not a register definition, means something; // unexpected happened during optimisation. Broken debug-info, however,; // shouldn't crash the compiler -- instead leave the variable value as; // None, which will make it appear ""optimised out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:57,Modifiability,variab,variable,57,// Only handle this instruction when we are building the variable value; // transfer function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Modifiability,variab,variable,34,// Handled by doing nothing. This variable is never in scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:118,Performance,optimiz,optimized,118,"// Default machine value number is <None> -- if no instruction defines; // the corresponding value, it must have been optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:269,Availability,avail,available,269,"// We have a DbgOpID for every value or for none. Tell the variable value; // tracker about it. The rest of this LiveDebugValues implementation acts; // exactly the same for DBG_INSTR_REFs as DBG_VALUEs (just, the former can; // refer to values that aren't immediately available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:59,Modifiability,variab,variable,59,"// We have a DbgOpID for every value or for none. Tell the variable value; // tracker about it. The rest of this LiveDebugValues implementation acts; // exactly the same for DBG_INSTR_REFs as DBG_VALUEs (just, the former can; // refer to values that aren't immediately available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Modifiability,variab,variable,34,// Tell transfer tracker that the variable value has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Performance,optimiz,optimized,44,"// If the stack slot is dead, then this was optimized away.; // FIXME: stack slot colouring should account for slots that get merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:64,Safety,avoid,avoid,64,"// We might be able to find a value, but have chosen not to, to avoid; // tracking too much stack information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Testability,Test,Test,3,// Test whether we should ignore a def of this register due to it being part; // of the stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:105,Energy Efficiency,allocate,allocated,105,"// Find the regs killed by MI, and find regmasks of preserved regs.; // Max out the number of statically allocated elements in `DeadRegs`, as this; // prevents fallback to std::set::count() operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:122,Availability,recover,recover,122,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:19,Modifiability,variab,variable,19,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,Modifiability,variab,variable,134,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:122,Safety,recover,recover,122,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:49,Availability,mask,mask,49,// Look for any clobbers performed by a register mask. Only test locations; // that are actually being tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Performance,perform,performed,25,// Look for any clobbers performed by a register mask. Only test locations; // that are actually being tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:60,Testability,test,test,60,// Look for any clobbers performed by a register mask. Only test locations; // that are actually being tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:37,Performance,load,loads,37,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,Security,access,access,89,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:37,Performance,load,loads,37,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,Security,access,access,89,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Modifiability,variab,variable,102,"// First, if there are any DBG_VALUEs pointing at a spill slot that is; // written to, terminate that variable location. The value in memory; // will have changed. DbgEntityHistoryCalculator doesn't try to detect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:206,Safety,detect,detect,206,"// First, if there are any DBG_VALUEs pointing at a spill slot that is; // written to, terminate that variable location. The value in memory; // will have changed. DbgEntityHistoryCalculator doesn't try to detect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:208,Availability,recover,recover,208,"// We need to over-write the stack slot with something (here, a def at; // this instruction) to ensure no values are preserved in this stack slot; // after the spill. It also prevents TTracker from trying to recover the; // location and re-installing it in the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:240,Deployability,install,installing,240,"// We need to over-write the stack slot with something (here, a def at; // this instruction) to ensure no values are preserved in this stack slot; // after the spill. It also prevents TTracker from trying to recover the; // location and re-installing it in the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:208,Safety,recover,recover,208,"// We need to over-write the stack slot with something (here, a def at; // this instruction) to ensure no values are preserved in this stack slot; // after the spill. It also prevents TTracker from trying to recover the; // location and re-installing it in the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:62,Performance,load,load,62,"// Now find subregisters within the destination register, and load values; // from stack slot positions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,Availability,recover,recover,134,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Deployability,update,update,13,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:172,Modifiability,variab,variables,172,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,Safety,recover,recover,134,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:63,Modifiability,variab,variables,63,"// If ActiveMLocs isn't tracking this location or there are no variables; // using it, don't bother remembering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Availability,avail,available,44,"// Copy MTracker info, including subregs if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Modifiability,variab,variables,33,"// The copy might have clobbered variables based on the destination register.; // Tell TTracker about it, passing the old ValueIDNum to search for; // alternative locations (or else terminating those variables).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:200,Modifiability,variab,variables,200,"// The copy might have clobbered variables based on the destination register.; // Tell TTracker about it, passing the old ValueIDNum to search for; // alternative locations (or else terminating those variables).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:132,Energy Efficiency,reduce,reduces,132,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed debug instruction to analyze for; /// fragment usage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:41,Modifiability,variab,variable,41,"// If this is the first sighting of this variable, then we are guaranteed; // there are currently no overlapping fragments either. Initialize the set; // of seen fragments, record no overlaps for the current one, and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:22,Modifiability,Variab,Variable,22,"// If this particular Variable/Fragment pair already exists in the overlap; // map, it has already been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:56,Modifiability,variab,variable,56,"// Otherwise, examine all other seen fragments for this variable, with ""this""; // fragment being a previously unseen fragment. Record any pair of; // overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:46,Availability,mask,mask,46,"// Because we try to optimize around register mask operands by ignoring regs; // that aren't currently tracked, we set up something ugly for later: RegMask; // operands that are seen earlier than the first use of a register, still need; // to clobber that register in the transfer function. But this information; // isn't actively recorded. Instead, we track each RegMask used in each block,; // and accumulated the clobbered but untracked registers in each block into; // the following bitvector. Later, if new values are tracked, we can add; // appropriate clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:21,Performance,optimiz,optimize,21,"// Because we try to optimize around register mask operands by ignoring regs; // that aren't currently tracked, we set up something ugly for later: RegMask; // operands that are seen earlier than the first use of a register, still need; // to clobber that register in the transfer function. But this information; // isn't actively recorded. Instead, we track each RegMask used in each block,; // and accumulated the clobbered but untracked registers in each block into; // the following bitvector. Later, if new values are tracked, we can add; // appropriate clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:40,Availability,mask,masks,40,// Reserve one bit per register for the masks described above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Deployability,update,update,13,// Insert-or-update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Availability,mask,mask,58,// Accumulate any bitmask operands into the clobbered reg mask for this; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Install,Install,3,"// Install a value representing the fact that this location is effectively; // written to in this block. As there's no reserved value, instead use; // a value number that is never generated. Pick the value number for the; // first instruction in the block, def'ing this location, which we know; // this block never used anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:237,Availability,redundant,redundant,237,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:237,Safety,redund,redundant,237,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:202,Testability,test,test,202,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Testability,assert,assert,23,// FIXME: We don't use assert here to prevent instr-ref-unreachable.mir; // failing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Availability,redundant,redundant,102,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Safety,redund,redundant,102,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:68,Testability,test,test,68,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:108,Testability,test,test,108,// We're now examining a PHI to see whether it's un-necessary. Loop around; // the other live-in values and test whether they're all the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,Safety,avoid,avoid,6,"// To avoid repeatedly running the PHI placement algorithm, leverage the; // fact that a def of register MUST also def its register units. Find the; // units for registers, place PHIs for them, and then replicate them for; // aliasing registers. Some inputs that are never def'd (DBG_PHIs of; // arguments) don't lead to register units being tracked, just place PHIs for; // those registers directly. Stack slots have their own form of ""unit"",; // store them to one side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:22,Performance,load,loaded,22,"// Not all roots were loaded into the tracking map: this register; // isn't actually def'd anywhere, we only read from it. Generate PHIs; // for this reg, but don't iterate units.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:64,Usability,Clear,Clear,64,// Ask the SSA construction algorithm where we should put PHIs. Clear; // anything that might have been hanging around from earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Install,Install,3,// Install those PHI values into the live-in value array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:77,Deployability,install,install,77,"// For stack slots, calculate PHIs for the equivalent of the units, then; // install for each index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:48,Deployability,install,install,48,"// Find anything that aliases this stack index, install PHIs for it too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Install,Install,3,// Install those PHI values into the live-in value array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:24,Deployability,install,install,24,// Now find aliases and install PHIs for those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:144,Performance,queue,queue,144,"// We track what is on the current and pending worklist to avoid inserting; // the same thing twice. We could avoid this with a custom priority queue,; // but this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:59,Safety,avoid,avoid,59,"// We track what is on the current and pending worklist to avoid inserting; // the same thing twice. We could avoid this with a custom priority queue,; // but this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:110,Safety,avoid,avoid,110,"// We track what is on the current and pending worklist to avoid inserting; // the same thing twice. We could avoid this with a custom priority queue,; // but this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Availability,redundant,redundant,33,"// Propagate values to eliminate redundant PHIs. At the same time, this; // produces the table of Block x Location => Value for the entry to each; // block.; // The kind of PHIs we can eliminate are, for example, where one path in a; // conditional spills and restores a register, and the register still has; // the same value once control flow joins, unbeknowns to the PHI placement; // code. Propagating values allows us to identify such un-necessary PHIs and; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Safety,redund,redundant,33,"// Propagate values to eliminate redundant PHIs. At the same time, this; // produces the table of Block x Location => Value for the entry to each; // block.; // The kind of PHIs we can eliminate are, for example, where one path in a; // conditional spills and restores a register, and the register still has; // the same value once control flow joins, unbeknowns to the PHI placement; // code. Propagating values allows us to identify such un-necessary PHIs and; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Performance,Load,Load,3,// Load the current set of live-ins into MLocTracker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,Availability,redundant,redundant,78,"// Once all the live-ins don't change on mlocJoin(), we've eliminated all; // redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,Safety,redund,redundant,78,"// Once all the live-ins don't change on mlocJoin(), we've eliminated all; // redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:47,Modifiability,variab,variable,47,"// Collect all the incoming DbgValues for this variable, from predecessor; // live-out values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:117,Safety,safe,safe,117,"// If there were no values, or one of the predecessors couldn't have a; // value, then give up immediately. It's not safe to produce a live-in; // value. Leave as whatever it was before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:83,Modifiability,variab,variable,83,"// All (non-entry) blocks have at least one non-backedge predecessor.; // Pick the variable value from the first of these, to compare against; // all others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:12,Modifiability,variab,variable,12,"// Scan for variable values that can never be resolved: if they have; // different DIExpressions, different indirectness, or are mixed constants /; // non-constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Modifiability,variab,variable,33,"// VarLoc LiveDebugValues tracks variable locations that are defined in; // blocks not in scope. This is something we could legitimately ignore, but; // lets allow it for now for the sake of coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:49,Modifiability,variab,variable,49,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:83,Modifiability,variab,variables,83,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:293,Performance,Perform,Perform,293,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,Safety,avoid,avoid,6,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:128,Modifiability,variab,variables,128,"// This method is much like buildMLocValueMap: but focuses on a single; // LexicalScope at a time. Pick out a set of blocks and variables that are; // to have their value assignments solved, then run our dataflow algorithm; // until a fixedpoint is reached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate some vectors for storing the live ins and live outs. Large.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:18,Modifiability,variab,variable,18,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:189,Modifiability,variab,variable,189,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:228,Modifiability,variab,variable,228,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:168,Safety,avoid,avoids,168,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,Modifiability,variab,variables,78,"// Re-initialize live-ins and live-outs, to clear the remains of previous; // variables live-ins / live-outs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Usability,clear,clear,44,"// Re-initialize live-ins and live-outs, to clear the remains of previous; // variables live-ins / live-outs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:18,Modifiability,variab,variable,18,"// Place PHIs for variable values, using the LLVM IDF calculator.; // Collect the set of blocks where variables are def'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Modifiability,variab,variables,102,"// Place PHIs for variable values, using the LLVM IDF calculator.; // Collect the set of blocks where variables are def'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:53,Modifiability,variab,variable,53,"// Request the set of PHIs we should insert for this variable. If there's; // only one value definition, things are very simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:121,Usability,simpl,simple,121,"// Request the set of PHIs we should insert for this variable. If there's; // only one value definition, things are very simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Modifiability,variab,variable,58,// Insert PHIs into the per-block live-in tables for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:60,Modifiability,variab,variables,60,"// Iterate over all the blocks we selected, propagating the variables value.; // This loop does two things:; // * Eliminates un-necessary VPHIs in vlocJoin,; // * Evaluates the blocks transfer function (i.e. variable assignments) and; // stores the result to the blocks live-outs.; // Always evaluate the transfer function on the first iteration, and when; // the live-ins change thereafter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:208,Modifiability,variab,variable,208,"// Iterate over all the blocks we selected, propagating the variables value.; // This loop does two things:; // * Eliminates un-necessary VPHIs in vlocJoin,; // * Evaluates the blocks transfer function (i.e. variable assignments) and; // stores the result to the blocks live-outs.; // Always evaluate the transfer function on the first iteration, and when; // the live-ins change thereafter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Deployability,Update,Updates,34,"// Join values from predecessors. Updates LiveInIdx, and writes output; // into JoinedInLocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:113,Availability,avail,available,113,"// If this block's live-in value is a VPHI, try to pick a machine-value; // for it. This makes the machine-value available and propagated; // through all blocks by the time value propagation finishes. We can't; // do this any earlier as it needs to read the block live-outs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,// Insert new variable value; or overwrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:179,Availability,avail,available,179,"// Save live-ins to output vector. Ignore any that are still marked as being; // VPHIs with no location -- those are variables that we know the value of,; // but are not actually available in the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:117,Modifiability,variab,variables,117,"// Save live-ins to output vector. Ignore any that are still marked as being; // VPHIs with no location -- those are variables that we know the value of,; // but are not actually available in the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:7,Modifiability,variab,variable,7,// Per-variable loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:42,Modifiability,variab,variable,42,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:298,Modifiability,variab,variable,298,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:402,Modifiability,variab,variable,402,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:526,Modifiability,variab,variables,526,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:103,Usability,simpl,simple,103,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,// Assign the variable value to entry to each dominated block that's in scope.; // Skip the definition block -- it's assigned the variable value in the middle; // of the block somewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:130,Modifiability,variab,variable,130,// Assign the variable value to entry to each dominated block that's in scope.; // Skip the definition block -- it's assigned the variable value in the middle; // of the block somewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:67,Modifiability,variab,variable,67,"// All blocks that aren't dominated have no live-in value, thus no variable; // value will be given to them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:26,Testability,test,test,26,"// As an expensive check, test whether there are any duplicate substitution; // sources in the collection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:17,Modifiability,variab,variable,17,// No scopes? No variable locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:104,Modifiability,variab,variable,104,"// Helper lambda for ejecting a block -- if nothing is going to use the block,; // we can translate the variable location information into DBG_VALUEs and then; // free all of InstrRefBasedLDV's data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:85,Deployability,install,installing,85,"// Prime the transfer-tracker, and then step through all the block; // instructions, installing transfers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Modifiability,variab,variable,25,// We don't need live-in variable values for this block either.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:291,Modifiability,variab,variable,291,"// We obesrve scopes with children twice here, once descending in, once; // ascending out of the scope nest. Use HighestDFSIn as a ratchet to ensure; // we don't process a scope twice. Additionally, ignore scopes that don't; // have a DILocation -- by proxy, this means we never tracked any variable; // assignments in that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:79,Modifiability,extend,extend,79,/// Calculate the liveness information for the given machine function and; /// extend ranges across basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate and initialize two array-of-arrays for the live-in and live-out; // machine values. The outer dimension is the block number; while the inner; // dimension is a LocIdx from MLocTracker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:215,Modifiability,variab,variable,215,"// Solve the machine value dataflow problem using the MLocTransfer function,; // storing the computed live-ins / live-outs into the array-of-arrays. We use; // both live-ins and live-outs for decision making in the variable value; // dataflow problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Patch,Patch,3,"// Patch up debug phi numbers, turning unknown block-live-in values into; // either live-through machine values, or PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variables,14,"// Number all variables in the order that they appear, to be used as a stable; // insertion order later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:40,Modifiability,variab,variables,40,// Map from one LexicalScope to all the variables in that scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Modifiability,variab,variables,44,"// To mirror old LiveDebugValues, enumerate variables in RPOT order. Otherwise; // the order is unimportant, it just has to be stable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Modifiability,variab,variable,16,// Collect each variable with a DBG_VALUE in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:43,Modifiability,variab,variable,43,"// If we have an extremely large number of variable assignments and blocks,; // bail out at this point. We've burnt some time doing analysis already,; // however we should cut our losses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Modifiability,variab,variable,25,"// Optionally, solve the variable value problem and emit to blocks by using; // a lexical-scope-depth search. It should be functionally identical to; // the ""else"" block of this condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:101,Availability,robust,robust,101,"// Pick a type to identify incoming block values as we construct SSA. We; // can't use anything more robust than an integer unfortunately, as SSAUpdater; // expects to zero-initialize the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:43,Deployability,update,updater,43,"/// Represents an SSA PHI node for the SSA updater class. Contains the block; /// this PHI is in, the value number it would have, and the expected incoming; /// values from parent blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:9,Integrability,wrap,wrapper,9,/// Thin wrapper around a block predecessor iterator. Only difference from a; /// normal block iterator is that it dereferences to an LDVSSABlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:40,Deployability,Update,Updater,40,/// Thin wrapper around a block for SSA Updater interface. Necessary because; /// we need to track the PHI value(s) that we may have observed as necessary; /// in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:9,Integrability,wrap,wrapper,9,/// Thin wrapper around a block for SSA Updater interface. Necessary because; /// we need to track the PHI value(s) that we may have observed as necessary; /// in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:48,Integrability,interface,interface,48,/// Thin wrapper around a block for SSA Updater interface. Necessary because; /// we need to track the PHI value(s) that we may have observed as necessary; /// in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:37,Integrability,interface,interface,37,"/// Utility class for the SSAUpdater interface: tracks blocks, PHIs and values; /// while SSAUpdater is exploring the CFG. It's passed as a handle / baton to; // SSAUpdaterTraits<LDVSSAUpdater>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:30,Integrability,wrap,wrapper,30,"/// For a given MBB, create a wrapper block for it. Stores it in the; /// LDVSSAUpdater block map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:47,Security,access,access,47,"/// Template specialization to give SSAUpdater access to CFG and value; /// information. SSAUpdater calls methods in these traits, passing in the; /// LDVSSAUpdater object, to learn about blocks and the values they define.; /// It also provides methods to create PHI nodes and track them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:176,Usability,learn,learn,176,"/// Template specialization to give SSAUpdater access to CFG and value; /// information. SSAUpdater calls methods in these traits, passing in the; /// LDVSSAUpdater object, to learn about blocks and the values they define.; /// It also provides methods to create PHI nodes and track them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:62,Integrability,wrap,wrapper,62,// Methods to access block successors -- dereferencing to our wrapper class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Security,access,access,14,// Methods to access block successors -- dereferencing to our wrapper class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:138,Availability,recover,recover,138,"// If any DBG_PHIs referred to a location we didn't understand, don't try to; // compute a value. There might be scenarios where we could recover a value; // for some range of DBG_INSTR_REFs, but at this point we can have high; // confidence that we've seen a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:138,Safety,recover,recover,138,"// If any DBG_PHIs referred to a location we didn't understand, don't try to; // compute a value. There might be scenarios where we could recover a value; // for some range of DBG_INSTR_REFs, but at this point we can have high; // confidence that we've seen a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:287,Deployability,update,updater,287,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:413,Deployability,Update,Updater,413,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:396,Energy Efficiency,Adapt,Adapted,396,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:396,Modifiability,Adapt,Adapted,396,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Deployability,Update,Updater,34,"// Otherwise, we must use the SSA Updater. It will identify the value number; // that we are to use, and the PHIs that must happen along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:295,Safety,abort,abort,295,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:404,Security,Validat,Validate,404,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:669,Security,validat,validated,669,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:701,Security,Validat,ValidatedValues,701,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:42,Security,Validat,ValidatedValues,42,// Define all the input DBG_PHI values in ValidatedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Security,validat,validate,16,// Sort PHIs to validate into RPO-order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:24,Security,validat,validated,24,// Record this value as validated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:23,Testability,test,test,23,"// Forward dec of unit test class, so that we can peer into the LDV object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:80,Security,access,accessor,80,"/// A collection of ValueTables, one per BB in a function, with convenient; /// accessor methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:9,Integrability,wrap,wrapper,9,/// Thin wrapper around an integer -- designed to give more type safety to; /// spill location numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:65,Safety,safe,safety,65,/// Thin wrapper around an integer -- designed to give more type safety to; /// spill location numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:169,Safety,avoid,avoid,169,"/// TODO: Might pack better if we changed this to a Struct of Arrays, since; /// MachineOperand is width 32, making this struct width 33. We could also; /// potentially avoid storing the whole MachineOperand (sizeof=32), instead; /// choosing to store just the contents portion (sizeof=8) and a Kind enum,; /// since we already know it is some type of immediate value.; /// Stores a single debug operand, which can either be a MachineOperand for; /// directly storing immediate values, or a ValueIDNum representing some value; /// computed at some point in the program. IsConst is used as a discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:135,Energy Efficiency,reduce,reduce,135,"/// An ID used in the DbgOpIDMap (below) to lookup a stored DbgOp. This is used; /// in place of actual DbgOps inside of a DbgValue to reduce its size, as; /// DbgValue is very frequently used and passed around, and the actual DbgOp is; /// over 8x larger than this class, due to storing a MachineOperand. This ID; /// should be equal for all equal DbgOps, and also encodes whether the mapped; /// DbgOp is a constant, meaning that for simple equality or const-ness checks; /// it is not necessary to lookup this ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:436,Usability,simpl,simple,436,"/// An ID used in the DbgOpIDMap (below) to lookup a stored DbgOp. This is used; /// in place of actual DbgOps inside of a DbgValue to reduce its size, as; /// DbgValue is very frequently used and passed around, and the actual DbgOp is; /// over 8x larger than this class, due to storing a MachineOperand. This ID; /// should be equal for all equal DbgOps, and also encodes whether the mapped; /// DbgOp is a constant, meaning that for simple equality or const-ness checks; /// it is not necessary to lookup this ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:50,Modifiability,variab,variable,50,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:93,Modifiability,variab,variable,93,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:375,Modifiability,variab,variable,375,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:396,Performance,perform,performing,396,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:69,Modifiability,variab,variable,69,"// Returns an array of all the machine values used to calculate this variable; // value, or an empty list for an Undef or unjoined VPHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:1476,Availability,mask,mask,1476,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:526,Modifiability,layers,layers,526,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:486,Safety,avoid,avoid,486,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:583,Safety,avoid,avoid,583,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:1575,Safety,avoid,avoid,1575,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:29,Availability,mask,masks,29,"/// When clobbering register masks, we chose to not believe the machine model; /// and don't clobber SP. Do the same for SP aliases, and for efficiency,; /// keep a set of them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Performance,Cache,Cached,4,/// Cached local copy of the number of registers the target has.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:27,Availability,mask,mask,27,/// Collection of register mask operands that have been observed. Second part; /// of pair indicates the instruction that they happened in. Used to; /// reconstruct where defs happened if we start tracking a location later; /// on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:195,Usability,Simpl,Simplifies,195,"/// Iterator for locations and the values they contain. Dereferencing; /// produces a struct/pair containing the LocIdx key for this location,; /// and a reference to the value currently stored. Simplifies the process; /// of seeking a particular location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:87,Safety,safe,safety,87,/// Produce location ID number for a Register. Provides some small amount of; /// type safety.; /// \param Reg The register we're looking up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Performance,Load,Load,4,/// Load values for each location from array of ValueIDNums. Take current; /// bbnum just in case we read a value from a hitherto untouched register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:43,Performance,load,load,43,"// Iterate over all tracked locations, and load each locations live-in; // value into our local index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:155,Availability,Mask,Masks,155,"// We could reset all the location values too; however either loadFromArray; // or setMPhis should be called before this object is re-used. Just; // clear Masks, they're definitely not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:62,Performance,load,loadFromArray,62,"// We could reset all the location values too; however either loadFromArray; // or setMPhis should be called before this object is re-used. Just; // clear Masks, they're definitely not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:149,Usability,clear,clear,149,"// We could reset all the location values too; however either loadFromArray; // or setMPhis should be called before this object is re-used. Just; // clear Masks, they're definitely not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Usability,Clear,Clear,4,"/// Clear all data. Destroys the LocID <=> LocIdx map, which makes most of; /// the information in this pass uninterpretable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:138,Availability,mask,mask,138,"/// Create a LocIdx for an untracked register ID. Initialize it to either an; /// mphi value representing a live-in, or a recent register mask clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:144,Usability,clear,clears,144,/// Reset a register value to zero / empty. Needed to replicate the; /// VarLoc implementation where a copy to/from a register effectively; /// clears the contents of the source register. (Values can only have one; /// machine location in VarLocBasedImpl).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:112,Availability,mask,mask,112,"/// Record a RegMask operand being executed. Defs any register we currently; /// track, stores a pointer to the mask in case we have to account for it; /// later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:116,Modifiability,variab,variable,116,"/// Create a DBG_VALUE based on debug operands \p DbgOps. Qualify it with the; /// information in \pProperties, for variable Var. Don't insert it anywhere,; /// just return the builder for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:176,Energy Efficiency,reduce,reduce,176,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:32,Modifiability,variab,variable,32,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:88,Modifiability,variab,variable,88,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:136,Modifiability,variab,variable,136,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:81,Modifiability,variab,variable,81,"/// Collection of DBG_VALUEs observed when traversing a block. Records each; /// variable and the value the DBG_VALUE refers to. Requires the machine value; /// location dataflow algorithm to have run already, so that values can be; /// identified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:237,Modifiability,variab,variable,237,"/// Map DebugVariable to the latest Value it's defined to have.; /// Needs to be a MapVector because we determine order-in-the-input-MIR from; /// the order in this container.; /// We only retain the last DbgValue in each block for each variable, to; /// determine the blocks live-out variable value. The Vars container forms the; /// transfer function for this block, as part of the dataflow analysis. The; /// movement of values between locations inside of a block is handled at a; /// much later stage, in the TransferTracker class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:285,Modifiability,variab,variable,285,"/// Map DebugVariable to the latest Value it's defined to have.; /// Needs to be a MapVector because we determine order-in-the-input-MIR from; /// the order in this container.; /// We only retain the last DbgValue in each block for each variable, to; /// determine the blocks live-out variable value. The Vars container forms the; /// transfer function for this block, as part of the dataflow analysis. The; /// movement of values between locations inside of a block is handled at a; /// much later stage, in the TransferTracker class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:39,Modifiability,variab,variable,39,// Otherwise: terminate any overlapped variable locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:34,Modifiability,variab,variable,34,/// Live in/out structure for the variable values: a per-block map of; /// variables to their values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:75,Modifiability,variab,variables,75,/// Live in/out structure for the variable values: a per-block map of; /// variables to their values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:109,Modifiability,variab,variable,109,/// Vector (per block) of a collection (inner smallvector) of live-ins.; /// Used as the result type for the variable value dataflow problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:35,Modifiability,variab,variables,35,/// Mapping from lexical scopes to variables in that scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:48,Modifiability,variab,variables,48,"/// Mapping from lexical scopes to blocks where variables in that scope are; /// assigned. Such blocks aren't necessarily ""in"" the lexical scope, it's; /// just a block where an assignment happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Modifiability,Variab,Variable,4,/// Variable tracker -- listens to DBG_VALUEs occurring as InstrRefBasedImpl; /// steps through a block. Reads the values at each location from the; /// MLocTracker object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:195,Deployability,Update,Updater,195,/// Map from instruction numbers defined by DBG_PHIs to a record of what that; /// DBG_PHI read and where. Populated and edited during the machine value; /// location problem -- we use LLVMs SSA Updater to fix changes by; /// optimizations that destroy PHI instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:226,Performance,optimiz,optimizations,226,/// Map from instruction numbers defined by DBG_PHIs to a record of what that; /// DBG_PHI read and where. Populated and edited during the machine value; /// location problem -- we use LLVMs SSA Updater to fix changes by; /// optimizations that destroy PHI instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:22,Modifiability,variab,variable,22,// Map of overlapping variable fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:121,Modifiability,variab,variable,121,"/// Mapping of DBG_INSTR_REF instructions to their values, for those; /// DBG_INSTR_REFs that call resolveDbgPHIs. These variable references solve; /// a mini SSA problem caused by DBG_PHIs being cloned, this collection caches; /// the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:220,Performance,cache,caches,220,"/// Mapping of DBG_INSTR_REF instructions to their values, for those; /// DBG_INSTR_REFs that call resolveDbgPHIs. These variable references solve; /// a mini SSA problem caused by DBG_PHIs being cloned, this collection caches; /// the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Testability,Test,Tests,4,/// Tests whether this instruction is a spill to a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:247,Performance,optimiz,optimization,247,/// Decide if @MI is a spill instruction and return true if it is. We use 2; /// criteria to make this decision:; /// - Is this instruction a store to a spill slot?; /// - Is there a register operand that is both used and killed?; /// TODO: Store optimization can fold spills into other stores (including; /// other spills). We do not handle this yet (more than one memory operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Deployability,Install,Install,4,"/// Install PHI values into the live-in array for each block, according to; /// the IDF of each register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:14,Modifiability,variab,variable,14,/// Propagate variable values to blocks in the common case where there's; /// only one value assigned to the variable. This function has better; /// performance as it doesn't have to find the dominance frontier between; /// different assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:109,Modifiability,variab,variable,109,/// Propagate variable values to blocks in the common case where there's; /// only one value assigned to the variable. This function has better; /// performance as it doesn't have to find the dominance frontier between; /// different assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:149,Performance,perform,performance,149,/// Propagate variable values to blocks in the common case where there's; /// only one value assigned to the variable. This function has better; /// performance as it doesn't have to find the dominance frontier between; /// different assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:158,Modifiability,variab,variable,158,"/// Calculate the iterated-dominance-frontier for a set of defs, using the; /// existing LLVM facilities for this. Works for a single ""value"" or; /// machine/variable location.; /// \p AllBlocks Set of blocks where we might consume the value.; /// \p DefBlocks Set of blocks where the value/location is defined.; /// \p PHIBlocks Output set of blocks where PHIs must be placed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:426,Availability,down,downgrade,426,"/// Perform a control flow join (lattice value meet) of the values in machine; /// locations at \p MBB. Follows the algorithm described in the file-comment,; /// reading live-outs of predecessors from \p OutLocs, the current live ins; /// from \p InLocs, and assigning the newly computed live ins back into; /// \p InLocs. \returns two bools -- the first indicates whether a change; /// was made, the second whether a lattice downgrade occurred. If the latter; /// is true, revisiting this block is necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Performance,Perform,Perform,4,"/// Perform a control flow join (lattice value meet) of the values in machine; /// locations at \p MBB. Follows the algorithm described in the file-comment,; /// reading live-outs of predecessors from \p OutLocs, the current live ins; /// from \p InLocs, and assigning the newly computed live ins back into; /// \p InLocs. \returns two bools -- the first indicates whether a change; /// was made, the second whether a lattice downgrade occurred. If the latter; /// is true, revisiting this block is necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:171,Modifiability,variab,variables,171,"/// Produce a set of blocks that are in the current lexical scope. This means; /// those blocks that contain instructions ""in"" the scope, blocks where; /// assignments to variables in scope occur, and artificial blocks that are; /// successors to any of the earlier blocks. See https://llvm.org/PR48091 for; /// more commentry on what ""in scope"" means.; /// \p DILoc A location in the scope that we're fetching blocks for.; /// \p Output Set to put in-scope-blocks into.; /// \p AssignBlocks Blocks known to contain assignments of variables in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:531,Modifiability,variab,variables,531,"/// Produce a set of blocks that are in the current lexical scope. This means; /// those blocks that contain instructions ""in"" the scope, blocks where; /// assignments to variables in scope occur, and artificial blocks that are; /// successors to any of the earlier blocks. See https://llvm.org/PR48091 for; /// more commentry on what ""in scope"" means.; /// \p DILoc A location in the scope that we're fetching blocks for.; /// \p Output Set to put in-scope-blocks into.; /// \p AssignBlocks Blocks known to contain assignments of variables in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:14,Modifiability,variab,variable,14,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:328,Modifiability,variab,variable,328,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:409,Modifiability,variab,variable,409,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:583,Modifiability,variab,variables,583,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:76,Deployability,install,install,76,"/// Take collections of DBG_VALUE instructions stored in TTracker, and; /// install them into their output blocks. Preserves a stable order of; /// DBG_VALUEs produced (which would otherwise cause nondeterminism) through; /// the AllVarsNumbering order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:188,Deployability,install,install,188,"/// Produce a map of the last lexical scope that uses a block, using the; /// scopes DFSOut number. Mapping is block-number to DFSOut.; /// \p EjectionMap Pre-allocated vector in which to install the built ma.; /// \p ScopeToDILocation Mapping of LexicalScopes to their DILocations.; /// \p AssignBlocks Map of blocks where assignments happen for a scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:159,Energy Efficiency,allocate,allocated,159,"/// Produce a map of the last lexical scope that uses a block, using the; /// scopes DFSOut number. Mapping is block-number to DFSOut.; /// \p EjectionMap Pre-allocated vector in which to install the built ma.; /// \p ScopeToDILocation Mapping of LexicalScopes to their DILocations.; /// \p AssignBlocks Map of blocks where assignments happen for a scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:31,Modifiability,variab,variable,31,"/// When determining per-block variable values and emitting to DBG_VALUEs,; /// this function explores by lexical scope depth. Doing so means that per; /// block information can be fully computed before exploration finishes,; /// allowing us to emit it and free data structures earlier than otherwise.; /// It's also good for locality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:134,Modifiability,variab,variable,134,"// Instruction must have a memory operand that's a stack slot, and isn't; // aliased, meaning it's a spill from regalloc instead of a variable.; // If it's aliased, we can't guarantee its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:65,Modifiability,extend,extends,65,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:86,Modifiability,variab,variable,86,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:225,Modifiability,variab,variable,225,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:368,Modifiability,variab,variable,368,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:626,Modifiability,variab,variable,626,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:94,Performance,perform,perform,94,"/// Generic LiveDebugValues pass. Calls through to VarLocBasedLDV or; /// InstrRefBasedLDV to perform location propagation, via the LDVImpl; /// base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:135,Deployability,pipeline,pipeline,135,"// Except for Wasm, all targets should be only using physical register at this; // point. Wasm only use virtual registers throught its pipeline, but its; // virtual registers don't participate in this LiveDebugValues analysis; only; // its target indices do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h:43,Integrability,interface,interfaces,43,// Expose a base class for LiveDebugValues interfaces to inherit from. This; // allows the generic LiveDebugValues pass handles to call into the; // implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h:57,Modifiability,inherit,inherit,57,// Expose a base class for LiveDebugValues interfaces to inherit from. This; // allows the generic LiveDebugValues pass handles to call into the; // implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h:3,Security,Expose,Expose,3,// Expose a base class for LiveDebugValues interfaces to inherit from. This; // allows the generic LiveDebugValues pass handles to call into the; // implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:455,Availability,avail,available,455,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:794,Availability,avail,availability,794,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1168,Availability,avail,available,1168," Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1332,Availability,avail,available,1332,"mpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1532,Availability,avail,available,1532,"and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1661,Availability,avail,available,1661,"and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2037,Availability,avail,available,2037,"lues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; ///  ""Unknown""; /// |; /// v; /// True; /// |; /// v; ///  False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2902,Availability,avail,available,2902,"eded when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; ///  ""Unknown""; /// |; /// v; /// True; /// |; /// v; ///  False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable loca",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5239,Availability,down,down,5239,"at variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5504,Deployability,install,installs,5504,"r DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with its bit not set in predecessor InLocs or; /// OutLocs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:626,Modifiability,variab,variable,626,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:735,Modifiability,variab,variable,735,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1127,Modifiability,extend,extend,1127," Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1134,Modifiability,variab,variable,1134," Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1419,Modifiability,variab,variable,1419,"mpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1476,Modifiability,variab,variable,1476,"mpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1602,Modifiability,variab,variable,1602,"and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1740,Modifiability,variab,variable,1740,"bugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verba",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2172,Modifiability,variab,variable,2172," /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; ///  ""Unknown""; /// |; /// v; /// True; /// |; /// v; ///  False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2487,Modifiability,variab,variable,2487,"pressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; ///  ""Unknown""; /// |; /// v; /// True; /// |; /// v; ///  False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// funct",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:3851,Modifiability,variab,variable,3851,"ssion is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4201,Modifiability,variab,variable,4201,"zed to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4348,Modifiability,variab,variable,4348,"igns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4432,Modifiability,variab,variable,4432,"igns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5041,Modifiability,variab,variable,5041,". This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function can",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5203,Modifiability,Extend,ExtendRanges,5203,"at variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5382,Modifiability,variab,variable,5382,"ntifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:6179,Modifiability,variab,variable,6179,"r DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with its bit not set in predecessor InLocs or; /// OutLocs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2366,Performance,optimiz,optimization,2366," /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; ///  ""Unknown""; /// |; /// v; /// True; /// |; /// v; ///  False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5684,Safety,avoid,avoid,5684,"r DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with its bit not set in predecessor InLocs or; /// OutLocs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2645,Testability,test,testing,2645," a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; ///  ""Unknown""; /// |; /// v; /// True; /// |; /// v; ///  False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:3793,Usability,Intuit,Intuitively,3793,"ssion is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:100,Safety,avoid,avoid,100,"/// If \p Op is a stack or frame register return true, otherwise return false.; /// This is used to avoid basing the debug entry values on the registers, since; /// we do not support it at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:36,Energy Efficiency,allocate,allocated,36,"// Max out the number of statically allocated elements in DefinedRegsSet, as; // this prevents fallback to std::set::count() operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:116,Energy Efficiency,efficient,efficiently,116,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:200,Energy Efficiency,efficient,efficiently,200,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:465,Performance,perform,performance-critical,465,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:3,Usability,Simpl,Simple,3,// Simple Set for storing all the VarLoc Indices at a Location bucket.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:20,Modifiability,variab,variable,20,/// A pair of debug variable and value location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:35,Modifiability,variab,variable,35,// The location at which a spilled variable resides. It consists of a; // register and an offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:20,Modifiability,variab,variable,20,/// Identity of the variable at this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:45,Safety,avoid,avoid,45,/// The value location. Stored separately to avoid repeatedly; /// extracting it from MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:55,Modifiability,variab,variable,55,"/// The set of machine locations used to determine the variable's value, in; /// conjunction with Expr. Initially populated with MI's debug operands,; /// but may be transformed independently afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:209,Security,access,accessed,209,/// Used to map the index of each location in Locs back to the index of its; /// original debug operand in MI. Used when multiple location operands are; /// coalesced and the original MI's operands need to be accessed while; /// emitting a debug value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable and machine-location in DBG_VALUE MI, and build an; /// entry location using the given expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable and machine-location from the DBG_VALUE (from the; /// function entry), and build an entry value backup location. The backup; /// location will turn into the normal location if the backup is valid at; /// the time of the primary location clobbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable and machine-location from the DBG_VALUE (from the; /// function entry), and build a copy of an entry value backup location by; /// setting the register location to NewReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable described by DBG_VALUE* MI, and create a VarLoc; /// locating it in the specified spill location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:83,Modifiability,variab,variable-specific,83,"/// Create a DBG_VALUE representing this VarLoc in the given function.; /// Copies variable-specific information such as DILocalVariable and; /// inlining information from the original DBG_VALUE instruction, which may; /// have been several transfers ago.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:56,Deployability,update,updated,56,"// An entry value is a register location -- but with an updated; // expression. The register location of such DBG_VALUE is always the; // one from the entry DBG_VALUE, it does not matter if the entry value; // was copied in to another register due to some optimizations.; // Non-entry value register locations are like the source; // DBG_VALUE, but with the register number from this VarLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:256,Performance,optimiz,optimizations,256,"// An entry value is a register location -- but with an updated; // expression. The register location of such DBG_VALUE is always the; // one from the entry DBG_VALUE, it does not matter if the entry value; // was copied in to another register due to some optimizations.; // Non-entry value register locations are like the source; // DBG_VALUE, but with the register number from this VarLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described by register \p Reg holding the entry; /// value, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described by register \p Reg holding a copy of the; /// entry value, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p Reg, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p Reg, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by 1 or more registers,; /// add each of them to \p Regs and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p SpillLocation,; /// return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p SpillLocation,; /// return the index .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p WasmLocation,; /// return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:56,Modifiability,Variab,Variable,56,/// This operator guarantees that VarLocs are sorted by Variable first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:173,Energy Efficiency,reduce,reduce,173,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:31,Modifiability,variab,variable,31,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:86,Modifiability,variab,variable,86,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:134,Modifiability,variab,variable,134,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:372,Integrability,depend,depending,372,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:242,Modifiability,variab,variable,242,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:564,Performance,perform,perform,564,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:71,Security,access,access,71,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4,Testability,Test,Tests,4,/// Tests whether this instruction is a spill to a stack location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:247,Performance,optimiz,optimization,247,/// Decide if @MI is a spill instruction and return true if it is. We use 2; /// criteria to make this decision:; /// - Is this instruction a store to a spill slot?; /// - Is there a register operand that is both used and killed?; /// TODO: Store optimization can fold spills into other stores (including; /// other spills). We do not handle this yet (more than one memory operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:28,Integrability,message,message,28,/// Print to ostream with a message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// Erase a variable from the set of open ranges, and additionally erase any; /// fragments that may overlap it. If the VarLoc is a backup location, erase; /// the variable from the EntryValuesBackupVars set, indicating we should stop; /// tracking its backup entry location. Otherwise, if the VarLoc is primary; /// location, erase the variable from the Vars set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:164,Modifiability,variab,variable,164,"/// Erase a variable from the set of open ranges, and additionally erase any; /// fragments that may overlap it. If the VarLoc is a backup location, erase; /// the variable from the EntryValuesBackupVars set, indicating we should stop; /// tracking its backup entry location. Otherwise, if the VarLoc is primary; /// location, erase the variable from the Vars set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:337,Modifiability,variab,variable,337,"/// Erase a variable from the set of open ranges, and additionally erase any; /// fragments that may overlap it. If the VarLoc is a backup location, erase; /// the variable from the EntryValuesBackupVars set, indicating we should stop; /// tracking its backup entry location. Otherwise, if the VarLoc is primary; /// location, erase the variable from the Vars set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,// Erase the variable/fragment that ends here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:83,Modifiability,variab,variable,83,"/// Return the Loc ID of an entry value backup location, if it exists for the; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:331,Modifiability,variab,variable,331,"/// Create new TransferDebugPair and insert it in \p Transfers. The VarLoc; /// with \p OldVarID should be deleted form \p OpenRanges and replaced with; /// new VarLoc. If \p NewReg is different than default zero value then the; /// new location will be register location created by the copy like instruction,; /// otherwise it is variable's location on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:14,Modifiability,variab,variable,14,// Close this variable's previous location range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:64,Performance,perform,performance,64,"// Erase VarLocs which reside in one of the dead registers. For performance; // reasons, it's critical to not iterate over the full set of open VarLocs.; // Iterate over the set of dying/used regs instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:54,Availability,mask,masks,54,"// Remove ranges of all clobbered registers. Register masks don't usually; // list SP as preserved. Assume that call instructions never clobber SP,; // because some backends (e.g., AArch64) never list SP in the regmask.; // While the debug info may be off for an instruction or two around; // callee-cleanup calls, transferring the DEBUG_VALUE across the call is; // still a better user experience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:382,Usability,user experience,user experience,382,"// Remove ranges of all clobbered registers. Register masks don't usually; // list SP as preserved. Assume that call instructions never clobber SP,; // because some backends (e.g., AArch64) never list SP in the regmask.; // While the debug info may be off for an instruction or two around; // callee-cleanup calls, transferring the DEBUG_VALUE across the call is; // still a better user experience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:58,Modifiability,variab,variable,58,"// Find the target indices killed by MI, and delete those variable locations; // from the open range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:172,Availability,down,down,172,// Check whether next instruction kills the spilled register.; // FIXME: Current solution does not cover search for killed register in; // bundles and instructions further down the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:84,Modifiability,variab,variable,84,"/// A spilled register may indicate that we have to end the current range of; /// a variable and create a new one for the spill location.; /// A restored register may indicate the reverse situation.; /// We don't want to insert any instructions in process(), so we just create; /// the DBG_VALUE without inserting it and keep track of it in \p Transfers.; /// It will be inserted into the BB when we're done iterating over the; /// instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:102,Modifiability,variab,variable,102,"// First, if there are any DBG_VALUEs pointing at a spill slot that is; // written to, then close the variable location. The value in memory; // will have changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:77,Modifiability,variab,variable,77,// Try to recognise spill and restore instructions that may create a new; // variable location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:132,Energy Efficiency,reduce,reduces,132,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed DEBUG_VALUE instruction to analyze for; /// fragment usage.; /// \param SeenFragments Map from DILocalVariable to all fragments of that; /// Variable which are known to exist.; /// \param OverlappingFragments The overlap map being constructed, from one; /// Var/Fragment pair to a vector of fragments known to overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:459,Modifiability,Variab,Variable,459,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed DEBUG_VALUE instruction to analyze for; /// fragment usage.; /// \param SeenFragments Map from DILocalVariable to all fragments of that; /// Variable which are known to exist.; /// \param OverlappingFragments The overlap map being constructed, from one; /// Var/Fragment pair to a vector of fragments known to overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:41,Modifiability,variab,variable,41,"// If this is the first sighting of this variable, then we are guaranteed; // there are currently no overlapping fragments either. Initialize the set; // of seen fragments, record no overlaps for the current one, and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:22,Modifiability,Variab,Variable,22,"// If this particular Variable/Fragment pair already exists in the overlap; // map, it has already been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:56,Modifiability,variab,variable,56,"// Otherwise, examine all other seen fragments for this variable, with ""this""; // fragment being a previously unseen fragment. Record any pair of; // overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:9,Integrability,rout,routine,9,/// This routine creates OpenRanges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:9,Integrability,rout,routine,9,/// This routine joins the analysis results of all incoming edges in @MBB by; /// inserting a new DBG_VALUE instruction at the start of the @MBB - if the same; /// source variable in all the predecessors of @MBB reside in the same location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:171,Modifiability,variab,variable,171,/// This routine joins the analysis results of all incoming edges in @MBB by; /// inserting a new DBG_VALUE instruction at the start of the @MBB - if the same; /// source variable in all the predecessors of @MBB reside in the same location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:31,Modifiability,variab,variables,31,// TODO: Add support for local variables that are expressed in terms of; // parameters entry values.; // TODO: Add support for modified arguments that can be expressed; // by using its entry value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:107,Usability,simpl,simple,107,// TODO: Add support for parameters that have a pre-existing debug expressions; // (e.g. fragments).; // A simple deref expression is equivalent to an indirect debug value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:9,Integrability,rout,routine,9,"/// This routine records the entry values of function parameters. The values; /// could be used as backup values. If we loose the track of some unmodified; /// parameters, the backup values will be used as a primary locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:79,Modifiability,extend,extend,79,/// Calculate the liveness information for the given machine function and; /// extend ranges across basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:22,Modifiability,variab,variable,22,// Map of overlapping variable fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:88,Performance,perform,perform,88,"// This is a standard ""union of predecessor outs"" dataflow problem.; // To solve it, we perform join() and process() using the two worklist method; // until the ranges converge.; // Ranges have converged when both worklists are empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:132,Performance,queue,queue,132,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but this; // is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:47,Safety,avoid,avoid,47,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but this; // is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:98,Safety,avoid,avoid,98,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but this; // is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:31,Modifiability,extend,extend,31,"// Now that we have started to extend ranges across BBs we need to; // examine spill, copy and restore instructions to see whether they; // operate with registers that correspond to user variables.; // First load any pending inlocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:187,Modifiability,variab,variables,187,"// Now that we have started to extend ranges across BBs we need to; // examine spill, copy and restore instructions to see whether they; // operate with registers that correspond to user variables.; // First load any pending inlocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:208,Performance,load,load,208,"// Now that we have started to extend ranges across BBs we need to; // examine spill, copy and restore instructions to see whether they; // operate with registers that correspond to user variables.; // First load any pending inlocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp:58,Deployability,update,updated,58,/// Skip the leading whitespace characters and return the updated cursor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp:39,Deployability,update,updated,39,/// Skip a line comment and return the updated cursor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp:9,Usability,simpl,simple,9,// Try a simple unquoted name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper struct around the 'MachineOperand' struct that includes a source; /// range and other attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,Availability,error,error,14,/// Report an error at the current location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:59,Integrability,message,message,59,/// Report an error at the current location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,Availability,error,error,14,/// Report an error at the given location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:57,Integrability,message,message,57,/// Report an error at the given location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:107,Availability,error,error,107,/// Convert the integer literal in the current token into an unsigned integer.; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:97,Availability,error,error,97,/// Convert the integer literal in the current token into an uint64.; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:101,Availability,error,error,101,"/// If the current token is of the given kind, consume it and return false.; /// Otherwise report an error and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error when multiple same attributes are specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error when both name and ir block are specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,Availability,mask,mask,14,// Parse lane mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:102,Availability,mask,mask,102,// We can't verify call instructions as they can contain arbitrary implicit; // register and register mask operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:9,Availability,redundant,redundant,9,// Try a redundant low-level type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:9,Safety,redund,redundant,9,// Try a redundant low-level type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error if the same register is used more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error if the same register is used more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error when using a duplicate bit target flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:43,Performance,load,load,43,// Optional 'store' for operands that both load and store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:12,Integrability,synchroniz,synchronization,12,// Optional synchronization scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:62,Availability,failure,failure,62,// Up to two atomic orderings (cmpxchg provides guarantees on failure).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error on duplicate metadata nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:294,Testability,test,test,294,"// FIXME: Currently we can't recognize temporary or local symbols and call all; // of the appropriate forms to create them. However, this handles basic cases; // well as most of the special aspects are recognized by a prefix on their; // name, and the input names should already be unique. For test cases, keeping; // the symbol name out of the symbol table isn't terribly important.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:14,Availability,error,error,14,/// Report an error with the given message at unknown location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:35,Integrability,message,message,35,/// Report an error with the given message at unknown location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:14,Availability,error,error,14,/// Report an error with the given message at the given location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:35,Integrability,message,message,35,/// Report an error with the given message at the given location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:19,Availability,error,error,19,/// Report a given error with the location translated from the location in an; /// embedded string literal to a location in the MIR file.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:118,Availability,error,error,118,/// Try to parse the optional LLVM module and the machine functions in the MIR; /// file.; ///; /// Return null if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:94,Availability,error,error,94,/// Parse the machine function in the current YAML document.; ///; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:113,Availability,error,error,113,/// Initialize the machine function to the state that's described in the MIR; /// file.; ///; /// Return true if error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:3,Performance,Load,Load,3,// Load any substitutions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:3,Safety,Avoid,Avoid,3,// Avoid clearing state if we're using the same subtarget again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:9,Usability,clear,clearing,9,// Avoid clearing state if we're using the same subtarget again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:124,Integrability,depend,depend,124,"// Note this is called after the initial constructor of the; // MachineFunctionInfo based on the MachineFunction, which may depend on the; // IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:64,Availability,error,error,64,/// Verify that given node is of a certain type. Return true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:33,Availability,error,error,33,// Translate the location of the error from the location in the MI string to; // the corresponding location in the MIR file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:33,Availability,error,error,33,// Translate the location of the error from the location in the llvm IR string; // to the corresponding location in the MIR file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:696,Security,expose,exposed,696,"//===- DAGCombiner.cpp - Implement a DAG node combiner --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines dag nodes to form fewer, simpler DAG nodes. It can be run; // both before and after the DAG is legalized.; //; // This pass is not a substitute for the LLVM IR instcombine pass. This pass is; // primarily intended to handle simplification opportunities that are implicit; // in the LLVM IR and exposed by the various codegen lowering phases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:427,Usability,simpl,simpler,427,"//===- DAGCombiner.cpp - Implement a DAG node combiner --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines dag nodes to form fewer, simpler DAG nodes. It can be run; // both before and after the DAG is legalized.; //; // This pass is not a substitute for the LLVM IR instcombine pass. This pass is; // primarily intended to handle simplification opportunities that are implicit; // in the LLVM IR and exposed by the various codegen lowering phases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:626,Usability,simpl,simplification,626,"//===- DAGCombiner.cpp - Implement a DAG node combiner --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines dag nodes to form fewer, simpler DAG nodes. It can be run; // both before and after the DAG is legalized.; //; // This pass is not a substitute for the LLVM IR instcombine pass. This pass is; // primarily intended to handle simplification opportunities that are implicit; // in the LLVM IR and exposed by the various codegen lowering phases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,load,33,"/// Hidden option to stress test load slicing, i.e., when this option; /// is enabled, load slicing bypasses most of its profitability guards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,Performance,load,load,87,"/// Hidden option to stress test load slicing, i.e., when this option; /// is enabled, load slicing bypasses most of its profitability guards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Testability,test,test,28,"/// Hidden option to stress test load slicing, i.e., when this option; /// is enabled, load slicing bypasses most of its profitability guards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Usability,simpl,simplified,49,/// Worklist of all of the nodes that need to be simplified.; ///; /// This must behave as a stack -- new nodes to process are pushed onto the; /// back and when processing we pop off of the back.; ///; /// The worklist will not contain duplicates but may contain null entries; /// due to nodes being deleted from the underlying DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,Availability,reliab,reliably,97,/// Set of nodes which have been combined (at least once).; ///; /// This is used to allow us to reliably add any operands of a DAG node; /// which have not yet been combined to the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Integrability,depend,dependence,182,"/// Map from candidate StoreNode to the pair of RootNode and count.; /// The count is used to track how many times we have seen the StoreNode; /// with the same RootNode bail out in dependence check. If we have seen; /// the bail out for the same pair many times over a limit, we won't; /// consider the StoreNode with the same RootNode as store merging; /// candidate again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,// AA - Used for DAG load/store alias analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Usability,simpl,simplified,27,"/// When an instruction is simplified, add all users of the instruction to; /// the work lists because they might get more simplified now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,Usability,simpl,simplified,123,"/// When an instruction is simplified, add all users of the instruction to; /// the work lists because they might get more simplified now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Integrability,rout,routine,27,/// Call the node-specific routine that folds each particular type of node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:85,Performance,scalab,scalable,85,"// We use the minimum store size here, since that's all we can guarantee; // for the scalable vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Safety,avoid,avoid,73,// Not in the worklist.; // Null out the entry rather than erasing it to avoid a linear operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Usability,simpl,simplified,63,"/// Check the specified integer node value to see if it can be simplified or; /// if things it uses can be simplified by bit propagation.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Usability,simpl,simplified,107,"/// Check the specified integer node value to see if it can be simplified or; /// if things it uses can be simplified by bit propagation.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Usability,simpl,simplified,62,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the; /// elements. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:106,Usability,simpl,simplified,106,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the; /// elements. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Usability,simpl,simplified,43,// TODO: For now just pretend it cannot be simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:80,Performance,load,load,80,"// Looks up the chain to find a unique (unaliased) store feeding the passed; // load. If no such store is found, returns a nullptr.; // Note: This will look past a CALLSEQ_START if the load is chained to it so; // so that it can find stack stores for byval params.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:185,Performance,load,load,185,"// Looks up the chain to find a unique (unaliased) store feeding the passed; // load. If no such store is found, returns a nullptr.; // Note: This will look past a CALLSEQ_START if the load is chained to it so; // so that it can find stack stores for byval params.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:375,Availability,failure,failure,375,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:70,Performance,load,load,70,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:262,Performance,load,load,262,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:293,Performance,load,load,293,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Integrability,rout,routine,27,"/// Call the node-specific routine that knows how to fold each; /// particular type of node. If that doesn't do anything, try the; /// target-specific DAG combines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Modifiability,extend,extended,189,/// This is a helper function for visitAND and visitZERO_EXTEND. Returns; /// true if the (and (load x) c) pattern matches an extload. ExtVT returns; /// the type of the loaded value to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Performance,load,load,96,/// This is a helper function for visitAND and visitZERO_EXTEND. Returns; /// true if the (and (load x) c) pattern matches an extload. ExtVT returns; /// the type of the loaded value to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:170,Performance,load,loaded,170,/// This is a helper function for visitAND and visitZERO_EXTEND. Returns; /// true if the (and (load x) c) pattern matches an extload. ExtVT returns; /// the type of the loaded value to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Energy Efficiency,reduce,reduced,86,/// Helper function to calculate whether the given Load/Store can have its; /// width reduced to ExtVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Performance,Load,Load,51,/// Helper function to calculate whether the given Load/Store can have its; /// width reduced to ExtVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Performance,load,loads,52,/// Used by BackwardsPropagateMask to find suitable loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Performance,load,load,50,/// Attempt to propagate a given AND node back to load leaves so that they; /// can be combined into narrow loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Performance,load,loads,108,/// Attempt to propagate a given AND node back to load leaves so that they; /// can be combined into narrow loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,Integrability,depend,dependency,94,/// Helper function for mergeConsecutiveStores. Checks if candidate stores; /// have indirect dependency through their operands. RootNode is the; /// predecessor to all stores calculated by getStoreMergeCandidates and is; /// used to prune the dependency check. \return True if safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:244,Integrability,depend,dependency,244,/// Helper function for mergeConsecutiveStores. Checks if candidate stores; /// have indirect dependency through their operands. RootNode is the; /// predecessor to all stores calculated by getStoreMergeCandidates and is; /// used to prune the dependency check. \return True if safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:278,Safety,safe,safe,278,/// Helper function for mergeConsecutiveStores. Checks if candidate stores; /// have indirect dependency through their operands. RootNode is the; /// predecessor to all stores calculated by getStoreMergeCandidates and is; /// used to prune the dependency check. \return True if safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:121,Performance,load,loaded,121,/// This is a helper function for mergeConsecutiveStores. It is used for; /// store chains that are composed entirely of loaded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:68,Performance,optimiz,optimization,68,/// Merge consecutive store operations into a wide store.; /// This optimization uses wide integers or vectors when possible.; /// \return true if stores were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Integrability,wrap,wrapper,16,/// Convenience wrapper around TargetLowering::getSetCCResultType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Availability,mask,mask,17,// Make sure the mask of OpVal is true mask or is same as Root's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Availability,mask,mask,39,// Make sure the mask of OpVal is true mask or is same as Root's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Availability,Mask,MaskOp,77,"// Specialize based on number of operands.; // TODO emit VP intrinsics where MaskOp/VectorLenOp != null; // SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT) { return; // DAG.getNode(Opcode, DL, VT); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:165,Performance,load,load,165,"// For an operand generating multiple values, one of the values may; // become dead allowing further simplification (e.g. split index; // arithmetic from an indexed load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:101,Usability,simpl,simplification,101,"// For an operand generating multiple values, one of the values may; // become dead allowing further simplification (e.g. split index; // arithmetic from an indexed load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Modifiability,extend,extends,83,"// APInts must be the same size for most operations, this helper; // function zero extends the shorter of the pair so that they match.; // We provide an Offset so that we can create bitwidths that won't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:295,Usability,simpl,simplifies,295,"// Return true if this node is a setcc, or is a select_cc; // that selects between the target values used for true and false, making it; // equivalent to a setcc. Also, set the incoming LHS, RHS, and CC references to; // the appropriate nodes based on the type of node we are checking. This; // simplifies life a bit for the callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Performance,load,load,32,// Determine if this an indexed load with an opaque target constant index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:226,Performance,load,load,226,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:280,Performance,load,load,280,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:324,Performance,load,load,324,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:372,Performance,load,load,372,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Usability,undo,undo,48,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:181,Performance,load,load,181,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Testability,test,test,116,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Testability,log,logic,30,// Check for repeated operand logic simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Usability,simpl,simplifications,36,// Check for repeated operand logic simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,Safety,avoid,avoid,75,"// if Op (Op N00, N1), N01 already exist; // we need to stop reassciate to avoid dead loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,Safety,avoid,avoid,75,"// if Op (Op N01, N1), N00 already exist; // we need to stop reassciate to avoid dead loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,Performance,optimiz,optimizations,277,"// Reassociate the operands from (OR/AND (OR/AND(N00, N001)), N1) to (OR/AND; // (OR/AND(N00, N1)), N01) when N00 and N1 are comparisons with the same; // predicate or to (OR/AND (OR/AND(N1, N01)), N00) when N01 and N1 are; // comparisons with the same predicate. This enables optimizations as the; // following one:; // CMP(A,C)||CMP(B,C) => CMP(MIN/MAX(A,B), C); // CMP(A,C)&&CMP(B,C) => CMP(MIN/MAX(A,B), C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Usability,simpl,simplified,131,"// Finally, if the node is now dead, remove it from the graph. The node; // may not be dead if the replacement process recursively simplified to; // something else needing this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Usability,simpl,simplified,63,"/// Check the specified integer node value to see if it can be simplified or if; /// things it uses can be simplified by bit propagation. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Usability,simpl,simplified,107,"/// Check the specified integer node value to see if it can be simplified or if; /// things it uses can be simplified by bit propagation. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Usability,simpl,simplified,62,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the elements.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:106,Usability,simpl,simplified,106,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the elements.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:295,Performance,load,load,295,"// We are always replacing N0/N1's use in N and only need additional; // replacements if there are additional uses.; // Note: We are checking uses of the *nodes* (SDNode) rather than values; // (SDValue) here because the node may reference multiple values; // (for example, the chain value of a load node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,Integrability,rout,routines,57,"// set the instance variables, so that the various visit routines may use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Modifiability,variab,variables,20,"// set the instance variables, so that the various visit routines may use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:156,Energy Efficiency,reduce,reduced,156,"// If N has no uses, it is dead. Make sure to revisit all N's operands once; // N is deleted from the DAG, since they too may now be dead or may have a; // reduced number of uses, allowing other xforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:134,Performance,optimiz,optimized,134,"// Push the new node and any users onto the worklist. Omit this if the; // new node is the EntryToken (e.g. if a store managed to get optimized; // out), because re-visiting the EntryToken and its users will not uncover; // any additional opportunities, but there may be a large number of such; // users, potentially causing compile time explosion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Usability,simpl,simplified,131,"// Finally, if the node is now dead, remove it from the graph. The node; // may not be dead if the replacement process recursively simplified to; // something else needing this node. This will also take care of adding any; // operands which have lost a user to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Deployability,update,update,49,"// If the root changed (e.g. it was a dead load, update the root).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Performance,load,load,43,"// If the root changed (e.g. it was a dead load, update the root).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Security,Expose,Expose,3,// Expose the DAG combiner to the target combiner impls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Availability,redundant,redundant,100,"// If N has two operands, where one has an input chain equal to the other,; // the 'other' chain is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Safety,redund,redundant,100,"// If N has two operands, where one has an input chain equal to the other,; // the 'other' chain is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Usability,simpl,simplify,9,// Don't simplify token factors if optnone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Usability,simpl,simplify,9,// Don't simplify the token factor if the node itself has too many operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:148,Performance,optimiz,optimizations,148,"// If the sole user is a token factor, we should make sure we have a; // chance to merge them together. This prevents TF chains from inhibiting; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Safety,avoid,avoid,39,"// Limit number of nodes to inline, to avoid quadratic compile times.; // We have to add the outstanding Token Factors to Ops, otherwise we might; // drop Ops from the resulting Token Factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Availability,redundant,redundant,65,// Entry tokens don't need to be added to the list. They are; // redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Safety,redund,redundant,65,// Entry tokens don't need to be added to the list. They are; // redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Queue,Queue,3,// Queue up for processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Safety,safe,safely,182,"// Replacing results may cause a different MERGE_VALUES to suddenly; // be CSE'd with N, and carry its uses with it. Iterate until no; // uses remain, to ensure that the node can be safely deleted.; // First add the users of this node to the work list so that they; // can be tried again once they have new operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Safety,avoid,avoid,33,// Do as a single replacement to avoid rewalking use lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:200,Safety,avoid,avoid,200,"// isTruncateOf - If N is a truncate of some other value, return true, record; // the value being truncated in Op and which of Op's bits are zero/one in Known.; // This function computes KnownBits to avoid a duplicated call to; // computeKnownBits in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,load,load,30,/// Return true if 'Use' is a load or a store that uses N as its base pointer; /// and that N may be folded in the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:115,Performance,load,load,115,/// Return true if 'Use' is a load or a store that uses N as its base pointer; /// and that N may be folded in the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:234,Availability,mask,masked,234,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Modifiability,variab,variable,58,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:144,Modifiability,variab,variable,144,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,Performance,load,load,178,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Safety,safe,safe,59,"// This transform increases uses of N0, so freeze it to be safe.; // binop N0, (vselect Cond, IDC, FVal) --> vselect Cond, N0, (binop N0, FVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Testability,log,logical,78,"// We need a constant operand for the add/sub, and the other operand is a; // logical shift right: add (srl), C or sub C, (srl).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:221,Performance,optimiz,optimization,221,"// Reassociate (add (or x, c), y) -> (add add(x, y), c)) if (or x, c) is; // equivalent to (add x, c).; // Reassociate (add (xor x, c), y) -> (add add(x, y), c)) if (xor x, c) is; // equivalent to (add x, c).; // Do this optimization only when adding c does not introduce instructions; // for adding carries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Availability,mask,mask,44,"// If N0's type does not split or is a sign mask, it does not introduce; // add carry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Integrability,wrap,wrap,51,// Limit this to after legalization if the add has wrap flags,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Availability,mask,masked,20,"// If the result is masked, then no matter what kind of bool it is we can; // return. If it isn't, then we need to make sure the bool type is either 0 or; // 1 and not other values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Availability,mask,masked,81,"/// Given the operands of an add/sub operation, see if the 2nd operand is a; /// masked 0/1 whose source operand is actually known to be 0/-1. If so, invert; /// the opcode and bypass the mask operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:188,Availability,mask,mask,188,"/// Given the operands of an add/sub operation, see if the 2nd operand is a; /// masked 0/1 whose source operand is actually known to be 0/-1. If so, invert; /// the opcode and bypass the mask operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Testability,Assert,AssertSext,17,"// add N0, (and (AssertSext X, i1), 1) --> sub N0, X; // sub N0, (and (AssertSext X, i1), 1) --> add N0, X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:71,Testability,Assert,AssertSext,71,"// add N0, (and (AssertSext X, i1), 1) --> sub N0, X; // sub N0, (and (AssertSext X, i1), 1) --> add N0, X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Integrability,wrap,wrap,51,// Limit this to after legalization if the add has wrap flags,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Safety,avoid,avoid,14,"// We want to avoid useless duplication.; // TODO: This is done automatically for binary operations. As UADDO_CARRY is; // not a binary operation, this is not really possible to leverage this; // existing mechanism for it. However, if more operations require the same; // deduplication logic, then it may be worth generalize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:286,Testability,log,logic,286,"// We want to avoid useless duplication.; // TODO: This is done automatically for binary operations. As UADDO_CARRY is; // not a binary operation, this is not really possible to leverage this; // existing mechanism for it. However, if more operations require the same; // deduplication logic, then it may be worth generalize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:317,Performance,optimiz,optimize,317,"/**; * If we are facing some sort of diamond carry propapagtion pattern try to; * break it up to generate something like:; * (uaddo_carry X, 0, (uaddo_carry A, B, Z):Carry); *; * The end result is usually an increase in operation required, but because the; * carry is now linearized, other transforms can kick in and optimize the DAG.; *; * Patterns typically look something like; * (uaddo A, B); * / \; * Carry Sum; * | \; * | (uaddo_carry *, 0, Z); * | /; * \ Carry; * | /; * (uaddo_carry X, *, *); *; * But numerous variation exist. Our goal is to identify A, B, X and Z and; * produce a combine with a single path for carry propagation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:196,Integrability,depend,dependency,196,"// Iff the flag result is dead:; // (uaddo_carry (add|uaddo X, Y), 0, Carry) -> (uaddo_carry X, Y, Carry); // Don't do this if the Carry comes from the uaddo. It won't remove the uaddo; // or the dependency between the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,perform,performing,58,"// Attempt to create a USUBSAT(LHS, RHS) node with DstVT, performing a; // clamp/truncation if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Modifiability,extend,extended,22,// If the LHS is zero-extended then we can perform the USUBSAT as DstVT by; // clamping RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Performance,perform,perform,43,// If the LHS is zero-extended then we can perform the USUBSAT as DstVT by; // clamping RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Modifiability,Refactor,Refactor,35,"// fold (sub x, x) -> 0; // FIXME: Refactor this and xor and other similar operations together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:110,Testability,log,logical,110,// Right-shifting everything out but the sign bit followed by negation is; // the same as flipping arithmetic/logical shift type without the negation:; // -(X >>u 31) -> (X >>s 31); // -(X >>s 31) -> (X >>u 31),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Energy Efficiency,power,power-of-,42,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:307,Energy Efficiency,reduce,reduces,307,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:353,Energy Efficiency,power,power-of-,353,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:368,Energy Efficiency,power,power-of-,368,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Availability,mask,mask,73,"// Fold ((mul x, 0/undef) -> 0,; // (mul x, 1) -> x) -> x); // -> and(x, mask); // We can replace vectors with '0' and '1' factors with a clearing mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Availability,mask,mask,147,"// Fold ((mul x, 0/undef) -> 0,; // (mul x, 1) -> x) -> x); // -> and(x, mask); // We can replace vectors with '0' and '1' factors with a clearing mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Usability,clear,clearing,138,"// Fold ((mul x, 0/undef) -> 0,; // (mul x, 1) -> x) -> x); // -> and(x, mask); // We can replace vectors with '0' and '1' factors with a clearing mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,avail,available,37,/// Return true if divmod libcall is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Availability,avail,available,82,"// If DIVREM is going to get expanded into a libcall,; // but there is no libcall available, then don't combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:204,Modifiability,extend,extending,204,"// X / 1 -> X; // X % 1 -> 0; // If this is a boolean op (single-bit element type), we can't have; // division-by-zero or remainder-by-zero, so assume the divisor is 1.; // TODO: Similarly, if we're zero-extending a boolean divisor, then assume; // it's a 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Energy Efficiency,reduce,reduce,64,"// If we know the sign bits of both operands are zero, strength reduce to a; // udiv instead. Handles (X&15) /s 4 -> X&15 >> 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Deployability,update,update,47,"// If the corresponding remainder node exists, update its users with; // (Dividend - (Quotient * Divisor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:152,Testability,log,logic,152,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Usability,simpl,simplification,137,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Energy Efficiency,power,power-,47,// Helper for determining whether a value is a power-2 constant scalar or a; // vector of such elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:235,Energy Efficiency,efficient,efficiently,235,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Usability,simpl,simple,26,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:199,Usability,learn,learn,199,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Deployability,update,update,47,"// If the corresponding remainder node exists, update its users with; // (Dividend - (Quotient * Divisor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:152,Testability,log,logic,152,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Usability,simpl,simplification,137,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Energy Efficiency,power,power,59,"// fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,Safety,avoid,avoid,76,"// fold (urem X, -1) -> select(FX == -1, 0, FX); // Freeze the numerator to avoid a miscompile with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Energy Efficiency,reduce,reduce,64,"// If we know the sign bits of both operands are zero, strength reduce to a; // urem instead. Handles (X & 0x0FFFFFFF) %s 16 -> X&15",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:153,Safety,avoid,avoid,153,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Testability,log,logic,56,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,simpl,simplified,17,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,Usability,simpl,simplification,277,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:435,Usability,simpl,simplification,435,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Deployability,update,update,43,"// If the equivalent Div node also exists, update its users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.; // We don't have demanded bits support for MULHU so this just enables constant; // folding based on known bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:4,Performance,Perform,Perform,4,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Performance,optimiz,optimizations,12,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,Performance,perform,performed,143,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:176,Usability,simpl,simplification,176,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Usability,simpl,simplified,38,"// If the two computed results can be simplified separately, separate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:407,Usability,Simpl,SimplifySelectCC,407,"// Function to calculate whether the Min/Max pair of SDNodes (potentially; // swapped around) make a signed saturate pattern, clamping to between a signed; // saturate of -2^(BW-1) and 2^(BW-1)-1, or an unsigned saturate of 0 and 2^BW.; // Returns the node being clamped and the bitwidth of the clamp in BW. Should; // work with both SMIN/SMAX nodes and setcc/select combo. The operands are the; // same as SimplifySelectCC. N0<N1 ? N2 : N3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Testability,log,logic,25,"/// If this is a bitwise logic instruction and both operands have the same; /// opcode, try to sink the other opcode after the logic instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:127,Testability,log,logic,127,"/// If this is a bitwise logic instruction and both operands have the same; /// opcode, try to sink the other opcode after the logic instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,// Avoid infinite looping with PromoteIntBinOp.; // TODO: Should we apply desirable/legal constraints to all opcodes?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,Testability,log,logic,117,"// Be extra careful sinking truncate. If it's free, there's no benefit in; // widening a binop. Also, don't create a logic op on an illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Performance,perform,perform,78,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Performance,optimiz,optimization,91,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:306,Usability,undo,undo,306,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:177,Availability,mask,mask,177,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:618,Availability,mask,mask,618,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:342,Performance,load,loading,342,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:437,Performance,optimiz,optimizations,437,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:565,Performance,perform,perform,565,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Usability,Simpl,Simplify,83,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Availability,mask,mask,41,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Availability,mask,masks,51,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,Safety,avoid,avoid,190,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,Energy Efficiency,efficient,efficient,61,"/// Try to make (and/or setcc (LL, LR), setcc (RL, RR)) more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Testability,log,logic,42,"// If we're here post-legalization or the logic op type is not i1, the logic; // op type must match a setcc result type. Also, all folds require new; // operations on the left and right operands, so those types must match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:71,Testability,log,logic,71,"// If we're here post-legalization or the logic op type is not i1, the logic; // op type must match a setcc result type. Also, all folds require new; // operations on the left and right operands, so those types must match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Usability,clear,clear,12,// All bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,clear,clear,17,// All sign bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Usability,clear,clear,12,// Any bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,clear,clear,17,// Any sign bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Modifiability,variab,variable,18,// Match a shared variable operand and 2 non-opaque constant operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Performance,optimiz,optimization,7,"// The optimization cannot be applied for all the predicates because; // of the way FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle; // NaNs. For FMINNUM_IEEE/FMAXNUM_IEEE, the optimization cannot be; // applied at all if one of the operands is a signaling NaN.; // It is safe to use FMINNUM_IEEE/FMAXNUM_IEEE if all the operands; // are non NaN values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Performance,optimiz,optimization,182,"// The optimization cannot be applied for all the predicates because; // of the way FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle; // NaNs. For FMINNUM_IEEE/FMAXNUM_IEEE, the optimization cannot be; // applied at all if one of the operands is a signaling NaN.; // It is safe to use FMINNUM_IEEE/FMAXNUM_IEEE if all the operands; // are non NaN values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,Safety,safe,safe,277,"// The optimization cannot be applied for all the predicates because; // of the way FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle; // NaNs. For FMINNUM_IEEE/FMAXNUM_IEEE, the optimization cannot be; // applied at all if one of the operands is a signaling NaN.; // It is safe to use FMINNUM_IEEE/FMAXNUM_IEEE if all the operands; // are non NaN values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:246,Performance,optimiz,optimization,246,"// Both FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle quiet; // NaNs in the same way. But, FMINNUM/FMAXNUM and FMINNUM_IEEE/; // FMAXNUM_IEEE handle signaling NaNs differently. If we cannot prove; // that there are not any sNaNs, then the optimization is not valid; // for FMINNUM_IEEE/FMAXNUM_IEEE. In the presence of sNaNs, we apply; // the optimization using FMINNUM/FMAXNUM for the following cases. If; // we can prove that we do not have any sNaNs, then we can do the; // optimization using FMINNUM_IEEE/FMAXNUM_IEEE for the following; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:350,Performance,optimiz,optimization,350,"// Both FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle quiet; // NaNs in the same way. But, FMINNUM/FMAXNUM and FMINNUM_IEEE/; // FMAXNUM_IEEE handle signaling NaNs differently. If we cannot prove; // that there are not any sNaNs, then the optimization is not valid; // for FMINNUM_IEEE/FMAXNUM_IEEE. In the presence of sNaNs, we apply; // the optimization using FMINNUM/FMAXNUM for the following cases. If; // we can prove that we do not have any sNaNs, then we can do the; // optimization using FMINNUM_IEEE/FMAXNUM_IEEE for the following; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:484,Performance,optimiz,optimization,484,"// Both FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle quiet; // NaNs in the same way. But, FMINNUM/FMAXNUM and FMINNUM_IEEE/; // FMAXNUM_IEEE handle signaling NaNs differently. If we cannot prove; // that there are not any sNaNs, then the optimization is not valid; // for FMINNUM_IEEE/FMAXNUM_IEEE. In the presence of sNaNs, we apply; // the optimization using FMINNUM/FMAXNUM for the following cases. If; // we can prove that we do not have any sNaNs, then we can do the; // optimization using FMINNUM_IEEE/FMAXNUM_IEEE for the following; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:466,Performance,optimiz,optimization,466,"// Check if the operands of an and/or operation are comparisons and if they; // compare against the same value. Replace the and/or-cmp-cmp sequence with; // min/max cmp sequence. If LHS1 is equal to RHS1, then the or-cmp-cmp; // sequence will be replaced with min-cmp sequence:; // (LHS0 < LHS1) | (RHS0 < RHS1) -> min(LHS0, RHS0) < LHS1; // and and-cmp-cmp will be replaced with max-cmp sequence:; // (LHS0 < LHS1) & (RHS0 < RHS1) -> max(LHS0, RHS0) < LHS1; // The optimization does not work for `==` or `!=` .; // The two comparisons should have either the same predicate or the; // predicate of one of the comparisons is the opposite of the other one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Testability,test,tests,40,// Don't do this transform for sign bit tests. Let foldLogicOfSetCCs; // handle it using OR/AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:171,Testability,test,tested,171,"// Combine `(select c, (X & 1), 0)` -> `(and (zext c), X)`.; // We canonicalize to the `select` form in the middle end, but the `and` form; // gets better codegen and all tested targets (arm, x86, riscv)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Energy Efficiency,reduce,reduce,45,/// This contains all DAGCombine rules which reduce two values combined by; /// an And operation to a single value. This makes them reusable in the context; /// of visitSELECT(). Rules involving constants are not included as; /// visitSELECT() already handles those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Modifiability,Rewrite,Rewrite,9,// TODO: Rewrite this to return a new 'AND' instead of using CombineTo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Performance,load,loaded,81,// ZEXTLOAD will match without needing to change the size of the value being; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Performance,load,loads,51,// Do not change the width of a volatile or atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,loads,19,// Do not generate loads of non-round integer types since these can; // be expensive (and would be wrong if the type is not byte sized).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,loads,19,// Do not generate loads of non-round integer types since these can; // be expensive (and would be wrong if the type is not byte sized).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Performance,load,loads,50,// Don't change the width of a volatile or atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,scalab,scalable,30,"// Bail out when changing the scalable property, since we can't be sure that; // we're actually narrowing here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Performance,load,load,42,// Verify that we are actually reducing a load width here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Security,access,access,65,// Ensure that this isn't going to produce an unsupported memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Modifiability,extend,extended,47,// It's not possible to generate a constant of extended or untyped type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:79,Performance,load,load,79,"// Don't transform one with multiple uses, this would require adding a new; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:256,Availability,down,downstream,256,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Performance,load,load,38,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,Performance,load,loaded,87,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Performance,load,load,146,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:267,Testability,log,logic,267,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,// If the load that we're shrinking is an extload and we're not just; // discarding the extension we can't simply shrink the load. Bail.; // TODO: It would be possible to merge the extensions in some cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125,Performance,load,load,125,// If the load that we're shrinking is an extload and we're not just; // discarding the extension we can't simply shrink the load. Bail.; // TODO: It would be possible to merge the extensions in some cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Usability,simpl,simply,107,// If the load that we're shrinking is an extload and we're not just; // discarding the extension we can't simply shrink the load. Bail.; // TODO: It would be possible to merge the extensions in some cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Performance,load,loads,52,"// Recursively search for the operands, looking for loads which can be; // narrowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loads,33,// Use LE to convert equal sized loads to zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Availability,mask,mask,40,// We can accept extending nodes if the mask is wider or an equal; // width to the original type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Modifiability,extend,extending,17,// We can accept extending nodes if the mask is wider or an equal; // width to the original type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Availability,mask,masked,29,// Allow one node which will masked along with any loads found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Performance,load,loads,51,// Allow one node which will masked along with any loads found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Availability,mask,masked,35,// Also ensure that the node to be masked only produces one data result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,load,53,// No need to do anything if the and directly uses a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,Availability,mask,masking,75,"// If it exists, fixup the single node we allow in the tree that needs; // masking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Performance,load,loads,17,// Create narrow loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125,Performance,perform,performance,125,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Testability,log,logical,23,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Testability,log,logical,65,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:84,Testability,log,logical,84,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,mask,37,// Do we actually prefer shifts over mask?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Testability,log,logical,29,// Try to match (-1 '[outer] logical shift' y),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Testability,log,logical,21,// tmp = x 'opposite logical shift' y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Testability,log,logical,14,// ret = tmp 'logical shift' y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Availability,mask,mask,65,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Testability,log,logic,25,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Testability,test,tests,36,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Testability,test,test,108,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:141,Testability,test,test,141,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Usability,clear,clear,54,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,Testability,test,test,57,// Attempt to find a 'not' op.; // TODO: Should we favor test+set even without the 'not' op?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:140,Availability,mask,masking,140,"// Look though an optional truncation. The source operand may not be the; // same type as the original 'and', but that is ok because we are masking; // off everything but the low bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Testability,test,test,59,// Try again to find a 'not' op.; // TODO: Should we favor test+set even with two 'not' ops?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Availability,mask,mask,43,"// Turn this into a bit-test pattern using mask op + setcc:; // and (not (srl X, C)), 1 --> (and X, 1<<C) == 0; // and (srl (not X), C)), 1 --> (and X, 1<<C) == 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,Testability,test,test,24,"// Turn this into a bit-test pattern using mask op + setcc:; // and (not (srl X, C)), 1 --> (and X, 1<<C) == 0; // and (srl (not X), C)), 1 --> (and X, 1<<C) == 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Testability,log,logically,36,// xor/add with SMIN (signmask) are logically equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Testability,log,logic,20,"/// Given a bitwise logic operation N with a matching bitwise logic operand,; /// fold a pattern where 2 of the source operands are identically shifted; /// values. For example:; /// ((X0 << Y) | Z) | (X1 << Y) --> ((X0 | X1) << Y) | Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Testability,log,logic,62,"/// Given a bitwise logic operation N with a matching bitwise logic operand,; /// fold a pattern where 2 of the source operands are identically shifted; /// values. For example:; /// ((X0 << Y) | Z) | (X1 << Y) --> ((X0 | X1) << Y) | Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Testability,log,logic,25,// Match another bitwise logic op and a shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Testability,log,logic,43,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,Testability,LOG,LOGIC,102,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Testability,LOG,LOGIC,109,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Testability,LOG,LOGIC,146,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,Testability,LOG,LOGIC,157,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Testability,LOG,LOGIC,182,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Testability,LOG,LOGIC,189,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:226,Testability,LOG,LOGIC,226,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:237,Testability,LOG,LOGIC,237,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Testability,log,logic,20,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Testability,LOG,LOGIC,59,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,Testability,LOG,LOGIC,66,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:80,Testability,LOG,LOGIC,80,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,Testability,LOG,LOGIC,190,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:197,Testability,LOG,LOGIC,197,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:220,Testability,LOG,LOGIC,220,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:254,Testability,LOG,LOGIC,254,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:265,Testability,LOG,LOGIC,265,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:285,Testability,LOG,LOGIC,285,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Testability,LOG,LOGIC,47,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Testability,LOG,LOGIC,54,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Testability,LOG,LOGIC,77,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,Testability,LOG,LOGIC,102,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Testability,LOG,LOGIC,109,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:132,Testability,LOG,LOGIC,132,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,Availability,mask,masked,46,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Availability,mask,mask,96,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:124,Modifiability,extend,extended,124,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,load,53,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Usability,clear,clears,59,"// fold (and (any_ext V), c) -> (zero_ext V) if 'and' only clears top bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,load,load,27,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:80,Performance,load,load,80,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:218,Performance,load,load,218,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:124,Usability,clear,clears,124,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Modifiability,variab,variable,18,"// Make sure that variable 'Constant' is only set if 'SplatBitSize' is a; // multiple of 'BitWidth'. Otherwise, we could propagate a wrong value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,Availability,mask,mask,142,"// The splat value may be something like ""0x00FFFFFF"", which means 0 for; // the first vector value and FF for the rest, repeating. We need a mask; // that will apply equally to all members of the vector, so AND all the; // lanes of the constant together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Security,access,access,63,// Resize the constant to the same size as the original memory access before; // extension. If it is still the AllOnesValue then this AND is completely; // unneeded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,"// If the load type was an EXTLOAD, convert to ZEXTLOAD in order to; // preserve semantics once we get rid of the AND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,loads,16,// PRE/POST_INC loads have 3 values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Availability,mask,mask,29,// Try to convert a constant mask AND into a shuffle clear mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Availability,mask,mask,59,// Try to convert a constant mask AND into a shuffle clear mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Usability,clear,clear,53,// Try to convert a constant mask AND into a shuffle clear mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,// Avoid recheck of N.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,load,14,"// fold (and (load x), 255) -> (zextload x, i8); // fold (and (extload x, i16), 255) -> (zextload x, i8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:187,Modifiability,extend,extend,187,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,Performance,load,loads,76,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Performance,load,loads,109,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:152,Performance,Perform,Perform,152,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:238,Performance,load,loads,238,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify: (and (op x...), (op y...)) -> (op (and x, y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Availability,Mask,Masking,3,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Modifiability,extend,extended,63,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:203,Usability,Simpl,SimplifyDemandedBits,203,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:104,Performance,load,load,104,// fold (zext_inreg (extload x)) -> (zextload x); // fold (zext_inreg (sextload x)) -> (zextload x) iff load has one use,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Modifiability,extend,extended,31,"// If we zero all the possible extended bits, then we can turn this into; // a zextload if we are running before legalize or the operation is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:126,Availability,mask,mask,126,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:212,Energy Efficiency,power,power,212,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:136,Usability,clear,clears,136,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Safety,avoid,avoid,44,// Postpone until legalization completed to avoid interference with bswap; // folding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Usability,clear,clear,91,// Make sure everything beyond the low halfword gets set to zero since the SRL; // 16 will clear the top bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Availability,mask,masked,27,// If the left-shift isn't masked out then the only way this is a bswap is; // if all bits beyond the low 8 are 0. In that case the entire pattern; // reduces to a left shift anyway: leave it for other parts of the combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:151,Energy Efficiency,reduce,reduces,151,// If the left-shift isn't masked out then the only way this is a bswap is; // if all bits beyond the low 8 are 0. In that case the entire pattern; // reduces to a left shift anyway: leave it for other parts of the combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,masked,37,"// However, if the right shift isn't masked out then it might be because; // it's not needed. See if we can spot that too. If the high bits aren't; // demanded, we only need bits 23:16 to be zero. Otherwise, we need all; // upper bits to be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,mask,37,// SHL or SRL: look upstream for AND mask operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Usability,clear,clear,32,// In case demanded bits didn't clear the bits that will be shifted out.; // This is needed for X86.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Modifiability,rewrite,rewrite,103,"// Match this pattern:; // (or (and (shl (A, 8)), 0xff00ff00), (and (srl (A, 8)), 0x00ff00ff)); // And rewrite this to:; // (rotr (bswap A), 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Testability,test,tests,73,// TODO: this is too restrictive; lifting this restriction requires more tests,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Energy Efficiency,reduce,reduce,45,/// This contains all DAGCombine rules which reduce two values combined by; /// an Or operation to a single value \see visitANDLike().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Availability,Mask,Mask,65,"// fold (or (shuf A, V_0, MA), (shuf B, V_0, MB)) -> (shuf A, B, Mask); // Do this only if the resulting type / shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify: (or (op x...), (op y...)) -> (op (or x, y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Safety,avoid,avoid,44,// Postpone until legalization completed to avoid interference with bswap; // folding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:285,Energy Efficiency,reduce,reduces,285,"// Return true if we can prove that, whenever Neg and Pos are both in the; // range [0, EltSize), Neg == (Pos == 0 ? 0 : EltSize - Pos). This means that; // for two opposing shifts shift1 and shift2 and a value X with OpBits bits:; //; // (or (shift1 X, Neg), (shift2 X, Pos)); //; // reduces to a rotate in direction shift2 by Pos or (equivalently) a rotate; // in direction shift1 by Neg. The range [0, EltSize) means that we only need; // to consider shift amounts with defined behavior.; //; // The IsRotate flag should be set when the LHS of both shifts is the same.; // Otherwise if matching a general funnel shift, it should be clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:635,Usability,clear,clear,635,"// Return true if we can prove that, whenever Neg and Pos are both in the; // range [0, EltSize), Neg == (Pos == 0 ? 0 : EltSize - Pos). This means that; // for two opposing shifts shift1 and shift2 and a value X with OpBits bits:; //; // (or (shift1 X, Neg), (shift2 X, Pos)); //; // reduces to a rotate in direction shift2 by Pos or (equivalently) a rotate; // in direction shift1 by Neg. The range [0, EltSize) means that we only need; // to consider shift amounts with defined behavior.; //; // The IsRotate flag should be set when the LHS of both shifts is the same.; // Otherwise if matching a general funnel shift, it should be clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1191,Availability,Mask,Mask,1191,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1320,Availability,Mask,Mask,1320,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Energy Efficiency,power,power,19,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:209,Energy Efficiency,power,power,209,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:798,Energy Efficiency,power,power,798,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Availability,Mask,Mask,86,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Availability,redundant,redundant,161,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Safety,redund,redundant,161,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Availability,Mask,Mask,59,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:85,Availability,Mask,Mask,85,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Availability,Mask,Mask,147,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:162,Availability,Mask,Mask,162,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Availability,Mask,Mask,189,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:151,Availability,Mask,Mask,151,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Availability,Mask,Mask,189,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:228,Availability,Mask,Mask,228,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:275,Availability,Mask,Mask,275,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:302,Availability,Mask,Mask,302,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:321,Availability,Mask,Mask,321,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:345,Availability,Mask,Mask,345,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Availability,Mask,Mask,44,// Now we just need to check that EltSize & Mask == Width & Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Availability,Mask,Mask,60,// Now we just need to check that EltSize & Mask == Width & Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Availability,Mask,Mask,13,// EltSize & Mask is 0 since Mask is EltSize - 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Availability,Mask,Mask,29,// EltSize & Mask is 0 since Mask is EltSize - 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,Energy Efficiency,reduce,reduces,143,"// A subroutine of MatchRotate used once we have found an OR of two opposite; // shifts of Shifted. If Neg == <operand size> - Pos then the OR reduces; // to both (PosOpcode Shifted, Pos) and (NegOpcode Shifted, Neg), with the; // former being preferred if supported. InnerPos and InnerNeg are Pos and; // Neg with outer conversions stripped away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,Energy Efficiency,reduce,reduces,143,"// A subroutine of MatchRotate used once we have found an OR of two opposite; // shifts of N0 + N1. If Neg == <operand size> - Pos then the OR reduces; // to both (PosOpcode N0, N1, Pos) and (NegOpcode N0, N1, Neg), with the; // former being preferred if supported. InnerPos and InnerNeg are Pos and; // Neg with outer conversions stripped away.; // TODO: Merge with MatchRotatePosNeg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:398,Availability,down,down,398,"// InstCombine may have combined a constant shl, srl, mul, or udiv with one; // side of the rotate, so try to handle that here. In all cases we need to; // pass the matched shift from the opposite side to compute the opcode and; // needed shift amount to extract. We still want to do this if both sides; // matched a rotate half because one half may be a potential overshift that; // can be broken down (ie if InstCombine merged two shl or srl ops into a; // single one).; // Have LHS side of the rotate, try to extract the needed shift from the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:67,Modifiability,variab,variable,67,"// Even pre-legalization, we can't easily rotate/funnel-shift by a variable; // shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Availability,mask,mask,17,"// If there is a mask here, and we have a variable shift, we can't be sure; // that we're masking out the right stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:90,Availability,mask,masking,90,"// If there is a mask here, and we have a variable shift, we can't be sure; // that we're masking out the right stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Modifiability,variab,variable,42,"// If there is a mask here, and we have a variable shift, we can't be sure; // that we're masking out the right stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Modifiability,extend,extended,40,// If the shift amount is sign/zext/any-extended just peel it off.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:547,Performance,load,loads,547,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:595,Performance,load,load,595,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:727,Performance,Load,Load,727,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:754,Performance,Load,Load,754,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:897,Performance,load,loads,897,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1248,Performance,Load,LoadCombine,1248,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1324,Performance,load,loads,1324,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1437,Performance,load,load,1437,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1609,Performance,Load,LoadCombine,1609,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1640,Performance,load,loads,1640,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1787,Performance,LOAD,LOAD,1787,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1813,Performance,LOAD,LOAD,1813,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1818,Performance,LOAD,LOAD,1818,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1835,Performance,LOAD,LOAD,1835,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:907,Usability,simpl,simply,907,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Performance,load,load,59,// Only allow multiple uses if the instruction is a vector load (in which; // case we will use the load for every ExtractVectorElement),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:99,Performance,load,load,99,// Only allow multiple uses if the instruction is a vector load (in which; // case we will use the load for every ExtractVectorElement),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,Performance,LOAD,LOAD,57,// Fail to combine if we have encountered anything but a LOAD after handling; // an ExtractVectorElement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Usability,simpl,simply,161,"// Check to see if the position of the element in the vector corresponds; // with the byte we are trying to provide for. In the case of a vector of; // i8, this simply means the VectorIndex == StartingIndex. For non i8 cases,; // the element will provide a range of bytes. For example, if we have a; // vector of i16s, each element provides two bytes (V[1] provides byte 2 and; // 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Performance,load,load,23,"// If the width of the load does not reach byte we are trying to provide for; // and it is not a ZEXTLOAD, then the load does not provide for the byte in; // question",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Performance,load,load,116,"// If the width of the load does not reach byte we are trying to provide for; // and it is not a ZEXTLOAD, then the load does not provide for the byte in; // question",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,Performance,load,loaded,97,"// Check if the bytes offsets we are looking at match with either big or; // little endian value loaded. Return true for big endian, false for little; // endian, and std::nullopt if match failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Usability,simpl,simple,26,// We only handle merging simple stores of 1-4 bytes.; // TODO: Allow unordered atomics when wider type is legal (see D66309),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:297,Performance,load,loads,297,"// All stores must be the same size to ensure that we are writing all of the; // bytes in the wide value.; // This store should have exactly one use as a chain operand for another; // store in the merging set. If there are other chain uses, then the; // transform may not be safe because order of loads/stores outside of this; // set may not be preserved.; // TODO: We could allow multiple sizes by tracking each stored byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:275,Safety,safe,safe,275,"// All stores must be the same size to ensure that we are writing all of the; // bytes in the wide value.; // This store should have exactly one use as a chain operand for another; // store in the merging set. If there are other chain uses, then the; // transform may not be safe because order of loads/stores outside of this; // set may not be preserved.; // TODO: We could allow multiple sizes by tracking each stored byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simple,10,// Handle simple types only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:84,Modifiability,extend,extends,84,// Stores must share the same source value with different offsets.; // Truncate and extends should be stripped to get the single source value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:650,Deployability,update,updated,650,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Performance,load,loaded,54,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:84,Performance,load,loads,84,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:144,Performance,load,load,144,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:154,Performance,load,load,154,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:675,Performance,load,loads,675,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:783,Performance,load,load,783,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:897,Performance,load,load,897,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:918,Performance,load,load,918,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1069,Performance,load,load,1069,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1255,Performance,load,load,1255,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1279,Performance,load,load,1279,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Usability,simpl,simple,11,// Handles simple types only,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,load,loaded,58,// Check if all the bytes of the OR we are looking at are loaded from the same; // base address. Collect bytes offsets from Base address in ByteOffsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:74,Modifiability,extend,extend,74,"// It's OK for the N most significant bytes to be 0, we can just; // zero-extend the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:85,Performance,load,load,85,"// It's OK for the N most significant bytes to be 0, we can just; // zero-extend the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Performance,load,loads,7,// All loads must share the same chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Load,Loads,3,// Loads must share the same base address,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,loads,14,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,Performance,load,load,34,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:222,Performance,load,load,222,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:420,Performance,load,load,420,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:165,Security,access,accessing,165,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,load,load,27,// Remember the first byte load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,loads,53,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:106,Performance,load,loads,106,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:144,Performance,load,load,144,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:187,Performance,load,loads,187,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:99,Performance,load,load,99,// Check if the bytes of the OR we are looking at match with either big or; // little endian value load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loaded,33,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:70,Performance,load,load,70,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Performance,load,loaded,109,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Performance,load,load,131,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Modifiability,extend,extended,116,"// The node we are looking at matches with the pattern, check if we can; // replace it with a single (possibly zero-extended) load and bswap + shift if; // needed.; // If the load needs byte swap check if the target supports it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:126,Performance,load,load,126,"// The node we are looking at matches with the pattern, check if we can; // replace it with a single (possibly zero-extended) load and bswap + shift if; // needed.; // If the load needs byte swap check if the target supports it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:175,Performance,load,load,175,"// The node we are looking at matches with the pattern, check if we can; // replace it with a single (possibly zero-extended) load and bswap + shift if; // needed.; // If the load needs byte swap check if the target supports it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:271,Modifiability,extend,extending,271,// Before legalize we can introduce illegal bswaps which will be later; // converted to an explicit bswap sequence. This way we end up with a single; // load and byte shuffling instead of several loads and byte shuffling.; // We do not introduce illegal bswaps when zero-extending as this tends to; // introduce too many arithmetic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:153,Performance,load,load,153,// Before legalize we can introduce illegal bswaps which will be later; // converted to an explicit bswap sequence. This way we end up with a single; // load and byte shuffling instead of several loads and byte shuffling.; // We do not introduce illegal bswaps when zero-extending as this tends to; // introduce too many arithmetic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:196,Performance,load,loads,196,// Before legalize we can introduce illegal bswaps which will be later; // converted to an explicit bswap sequence. This way we end up with a single; // load and byte shuffling instead of several loads and byte shuffling.; // We do not introduce illegal bswaps when zero-extending as this tends to; // introduce too many arithmetic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Modifiability,extend,extend,32,"// If we need to bswap and zero extend, we have to insert a shift. Check that; // it is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,load,16,// Check that a load of the wide type is both allowed and fast on the target,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loads,33,// Transfer chain users from old loads to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Performance,load,load,50,// Transfer chain users from old loads to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Availability,mask,masked,91,"// If the target has andn, bsl, or a similar bit-select instruction,; // we want to unfold masked merge, with canonical pattern of:; // | A | |B|; // ((x ^ y) & m) ^ y; // | D |; // Into:; // (x & m) | (y & ~m); // If y is a constant, m is not a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // ~(~x & m) & (m | y); // If x is a constant, m is a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // (x | ~m) & ~(~m & ~y); // NOTE: we don't unfold the pattern if 'xor' is actually a 'not', because at; // the very least that breaks andnpd / andnps patterns, and because those; // patterns are simplified in IR and shouldn't be created in the DAG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:684,Usability,simpl,simplified,684,"// If the target has andn, bsl, or a similar bit-select instruction,; // we want to unfold masked merge, with canonical pattern of:; // | A | |B|; // ((x ^ y) & m) ^ y; // | D |; // Into:; // (x & m) | (y & ~m); // If y is a constant, m is not a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // ~(~x & m) & (m | y); // If x is a constant, m is a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // (x | ~m) & ~(~m & ~y); // NOTE: we don't unfold the pattern if 'xor' is actually a 'not', because at; // the very least that breaks andnpd / andnps patterns, and because those; // patterns are simplified in IR and shouldn't be created in the DAG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Availability,mask,mask,28,"// Don't do anything if the mask is constant. This should not be reachable.; // InstCombine should have already unfolded this pattern, and DAGCombiner; // probably shouldn't produce it, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify: xor (op x...), (op y...) -> (op (xor x, y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the expression using non-local knowledge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:232,Performance,throughput,throughput,232,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op. This is a; /// throughput improvement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Testability,log,logic,48,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op. This is a; /// throughput improvement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:207,Testability,log,logic,207,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op. This is a; /// throughput improvement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Testability,log,logic,27,// Match a one-use bitwise logic op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Testability,Log,Logic,3,"// Logic ops are commutative, so check each operand for a match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Testability,log,logic,10,"// shift (logic (shift X, C0), Y), C1 -> logic (shift X, C0+C1), (shift Y, C1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Testability,log,logic,41,"// shift (logic (shift X, C0), Y), C1 -> logic (shift X, C0+C1), (shift Y, C1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,Safety,avoid,avoid,123,"// fold (shl (zext (srl x, C)), C) -> (zext (shl (srl x, C), C)); // Only fold this if the inner zext has no other uses to avoid increasing; // the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Availability,MASK,MASK,60,"// fold (shl (srl x, c1), c2) -> (and (shl x, (sub c2, c1), MASK) or; // (and (srl x, (sub c1, c2), MASK); // Only fold this if the inner shift has no other uses -- if it does,; // folding this will increase the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Availability,MASK,MASK,100,"// fold (shl (srl x, c1), c2) -> (and (shl x, (sub c2, c1), MASK) or; // (and (srl x, (sub c1, c2), MASK); // Only fold this if the inner shift has no other uses -- if it does,; // folding this will increase the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,Energy Efficiency,power,power,178,"// fold (shl (add x, c1), c2) -> (add (shl x, c2), c1 << c2); // fold (shl (or x, c1), c2) -> (or (shl x, c2), c1 << c2); // Variant of version done on multiply, except mul by a power of 2 is turned; // into a shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:128,Testability,test,test,128,"// fold (shl (sext (add_nsw x, c1)), c2) -> (add (shl (sext x), c2), c1 << c2); // TODO: Add zext/add_nuw variant with suitable test coverage; // TODO: Should we limit this with isLegalAddImmediate?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Modifiability,extend,extend,36,// Both operands must be equivalent extend nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Modifiability,extend,extend,22,// Check that the two extend nodes are the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Modifiability,extend,extend,51,"// If the operation feeding into the MUL is a sign extend (sext),; // we use mulhs. Othewise, zero extends (zext) use mulhu.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:99,Modifiability,extend,extends,99,"// If the operation feeding into the MUL is a sign extend (sext),; // we use mulhs. Othewise, zero extends (zext) use mulhu.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Modifiability,extend,extend,77,"// If the shift is not a no-op (in which case this should be just a sign; // extend already), the truncated to type is legal, sign_extend is legal; // on that type, and the truncate to that type is both legal and free,; // perform the transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:223,Performance,perform,perform,223,"// If the shift is not a no-op (in which case this should be just a sign; // extend already), the truncated to type is legal, sign_extend is legal; // on that type, and the truncate to that type is both legal and free,; // perform the transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:165,Availability,mask,masking,165,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Usability,simpl,simple,13,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Usability,simpl,simple,137,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify, based on bits shifted out of the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,Safety,detect,detected,94,// Try to transform this shift into a multiply-high if; // it matches the appropriate pattern detected in combineShiftToMULH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Modifiability,extend,extending,59,// Attempt to convert a sra of a load into a narrower sign-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,load,33,// Attempt to convert a sra of a load into a narrower sign-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:69,Performance,load,load,69,// Attempt to convert a sra of a load into a narrower sign-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Availability,Mask,Mask,138,"// In the more general case, we can clear the high bits after the shift:; // srl (trunc (srl x, c1)), c2 --> trunc (and (srl x, (c1+c2)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Usability,clear,clear,36,"// In the more general case, we can clear the high bits after the shift:; // srl (trunc (srl x, c1)), c2 --> trunc (and (srl x, (c1+c2)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Availability,MASK,MASK,60,"// fold (srl (shl x, c1), c2) -> (and (shl x, (sub c1, c2), MASK) or; // (and (srl x, (sub c2, c1), MASK)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Availability,MASK,MASK,100,"// fold (srl (shl x, c1), c2) -> (and (shl x, (sub c1, c2), MASK) or; // (and (srl x, (sub c2, c1), MASK)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Availability,mask,mask,63,"// fold (srl (anyextend x), c) -> (and (anyextend (srl x, c)), mask); // TODO - support non-uniform vector shift amounts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Energy Efficiency,power,power,82,"// fold (srl (ctlz x), ""5"") -> x iff x has one bit set (the low bit), and x has a power; // of two bitwidth. The ""5"" represents (log2 (bitwidth x)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:172,Usability,clear,clear,172,"// Okay, we know that only that the single bit specified by UnknownBits; // could be set on input to the CTLZ node. If this bit is set, the SRL; // will return 0, if it is clear, it returns 1. Change the CTLZ/SRL pair; // to an SRL/XOR pair, which is likely to simplify more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:261,Usability,simpl,simplify,261,"// Okay, we know that only that the single bit specified by UnknownBits; // could be set on input to the CTLZ node. If this bit is set, the SRL; // will return 0, if it is clear, it returns 1. Change the CTLZ/SRL pair; // to an SRL/XOR pair, which is likely to simplify more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Modifiability,extend,extending,59,// Attempt to convert a srl of a load into a narrower zero-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
