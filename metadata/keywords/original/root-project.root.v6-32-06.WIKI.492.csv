id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html604/TAxisEditor.html:5419,Availability,Error,Error,5419,"const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:5548,Availability,error,error,5548," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:5632,Availability,error,error,5632,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:19711,Availability,mask,mask,19711,,MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:16282,Deployability,Update,Update,16282,"oregroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TAxisEditor(const TAxisEditor&); TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:11687,Integrability,Message,Message,11687,"TGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TAxisEditor&operator=(const TAxisEditor&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGCompositeFrame::Print(Option_t* option = """") const; virtua",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:10270,Modifiability,Inherit,InheritsFrom,10270,"irtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGCompositeFrame::HandleKey(Event_t*); virtual Bool_tTGCompositeFrame::HandleMotion(Event_t*); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() co",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:10336,Modifiability,Inherit,InheritsFrom,10336," Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGCompositeFrame::HandleKey(Event_t*); virtual Bool_tTGCompositeFrame::HandleMotion(Event_t*); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTGWindow:",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:23039,Modifiability,Inherit,Inheritance,23039,"_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of axis attribute GUI. ~TAxisEditor(); Destructor of axis editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used values of axis attributes. void DoAxisColor(Pixel_t color); Slot connected to the axis color. void DoTickLength(); Slot connected to the tick length settings. void DoTicks(); Slot connected to the ticks draw settings. void DoDivisions(); Slot connected to the number of divisions. void DoLogAxis(); Slot for Log scale setting. void DoMoreLog(); Slot connected to more Log labels flag. void DoTitle(const char* text); Slot connected to the axis color. void DoTitleColor(Pixel_t color); Slot connected to the title color. void DoTitleSize(); Slot connected to the title font size. void DoTitleFont(Int_t font); Slot connecte",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:23052,Modifiability,Inherit,Inherited,23052,"_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of axis attribute GUI. ~TAxisEditor(); Destructor of axis editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used values of axis attributes. void DoAxisColor(Pixel_t color); Slot connected to the axis color. void DoTickLength(); Slot connected to the tick length settings. void DoTicks(); Slot connected to the ticks draw settings. void DoDivisions(); Slot connected to the number of divisions. void DoLogAxis(); Slot for Log scale setting. void DoMoreLog(); Slot connected to more Log labels flag. void DoTitle(const char* text); Slot connected to the axis color. void DoTitleColor(Pixel_t color); Slot connected to the title color. void DoTitleSize(); Slot connected to the title font size. void DoTitleFont(Int_t font); Slot connecte",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:548,Performance,optimiz,optimizing,548,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() c",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:21299,Performance,optimiz,optimization,21299, layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogAxislogarithmic check box; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; TGCheckButton*fMoreLogmore logarithmic labels check box; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGCheckButton*fNoExponentcheck box for No exponent choice; TGCheckButton*fOptimizetick optimization check box; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; TGCheckButton*fRotatedcheck button for rotated title; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGNumberEntry*fTickLengthtick length number entry; TGCheckButton*fTicksBothcheck box setting ticks on both axis sides; Int_tfTicksFlagpositive/negative ticks' flag; TGTextEntry*fTitleaxis title input field; TGColorSelect*fTitleColorcolor selection widget; TGFontTypeComboBox*fTitleFonttitle font combo box; TGNumberEntry*fTitleOffsettitle offset number entry; Int_tfTitlePrecfont precision level; TGNumberEntry*fTitleSizetitle size number entry; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTG,MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:9980,Security,Hash,Hash,9980,"t_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGCompositeFrame::HandleKey(Event_t*); virtual Bool_tTGCompositeFrame::HandleMotion(Event_t*); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWi",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:411,Testability,log,logarithmic,411,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() c",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:527,Testability,log,logarithmic,527,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() c",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:16048,Testability,Test,TestBit,16048,"oregroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TAxisEditor(const TAxisEditor&); TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:16087,Testability,Test,TestBits,16087,"oregroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TAxisEditor(const TAxisEditor&); TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:20983,Testability,log,logarithmic,20983,tinit flag for setting signals/slots; TGColorSelect*fLabelColorcolor selection widget; TGFontTypeComboBox*fLabelFontlabel font combo box; TGNumberEntry*fLabelOffsetlabel offset number entry; Int_tfLabelPrecfont precision level; TGNumberEntry*fLabelSizelabel size number entry; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogAxislogarithmic check box; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; TGCheckButton*fMoreLogmore logarithmic labels check box; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGCheckButton*fNoExponentcheck box for No exponent choice; TGCheckButton*fOptimizetick optimization check box; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; TGCheckButton*fRotatedcheck button for rotated title; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGNumberEntry*fTickLengthtick length number entry; TGCheckButton*fTicksBothcheck box setting ticks on both axis sides; Int_tfTicksFlagpositive/negative ticks' flag; TGTextEntry*fTitleaxis title input field; TGColorSelect*fTitleColorcolor selection widget; TGFontTypeComboBox*fTitleFonttitle font combo box; TGNumberEntry*fTitleOffsettitle offset number entry; Int_tfTitlePrecfont precision level; TGNumberEnt,MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:23751,Testability,Log,Log,23751,"; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of axis attribute GUI. ~TAxisEditor(); Destructor of axis editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used values of axis attributes. void DoAxisColor(Pixel_t color); Slot connected to the axis color. void DoTickLength(); Slot connected to the tick length settings. void DoTicks(); Slot connected to the ticks draw settings. void DoDivisions(); Slot connected to the number of divisions. void DoLogAxis(); Slot for Log scale setting. void DoMoreLog(); Slot connected to more Log labels flag. void DoTitle(const char* text); Slot connected to the axis color. void DoTitleColor(Pixel_t color); Slot connected to the title color. void DoTitleSize(); Slot connected to the title font size. void DoTitleFont(Int_t font); Slot connected to the title font. void DoTitleOffset(); Slot connected to the title offset. void DoTitleCentered(); Slot connected to centered title option. void DoTitleRotated(); Slot connected to the title rotation. void DoLabelColor(Pixel_t color); Slot connected to the label color. void DoLabelSize(); Slot connected to the label size. void DoLabelFont(Int_t font); Slot connected to the label font. void DoLabelOffset(); Slot connected to the label offset. void DoNoExponent(); Slot connected to the labels' exponent flag. void DoDecimal(Bool_t on); Slot connected to the decimal part setting. TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChi",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:23811,Testability,Log,Log,23811,"GFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of axis attribute GUI. ~TAxisEditor(); Destructor of axis editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used values of axis attributes. void DoAxisColor(Pixel_t color); Slot connected to the axis color. void DoTickLength(); Slot connected to the tick length settings. void DoTicks(); Slot connected to the ticks draw settings. void DoDivisions(); Slot connected to the number of divisions. void DoLogAxis(); Slot for Log scale setting. void DoMoreLog(); Slot connected to more Log labels flag. void DoTitle(const char* text); Slot connected to the axis color. void DoTitleColor(Pixel_t color); Slot connected to the title color. void DoTitleSize(); Slot connected to the title font size. void DoTitleFont(Int_t font); Slot connected to the title font. void DoTitleOffset(); Slot connected to the title offset. void DoTitleCentered(); Slot connected to centered title option. void DoTitleRotated(); Slot connected to the title rotation. void DoLabelColor(Pixel_t color); Slot connected to the label color. void DoLabelSize(); Slot connected to the label size. void DoLabelFont(Int_t font); Slot connected to the label font. void DoLabelOffset(); Slot connected to the label offset. void DoNoExponent(); Slot connected to the labels' exponent flag. void DoDecimal(Bool_t on); Slot connected to the decimal part setting. TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground())",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TAxisEditor.html:2069,Usability,Clear,Clear,2069,"ar* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual TGVerticalFrame*TGedFrame::CreateEditorTabSubFrame(const char* name); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::Des",MatchSource.WIKI,root/html604/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TAxisEditor.html
https://root.cern/root/html604/TBackCompFitter.html:2220,Availability,Error,Error,2220,"se(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); virtual Double_t*GetCovarianceMatrix() const; virtual Double_tGetCovarianceMatrixElement(Int_t i, Int_t j) const; static const char*TVirtualFitter::GetDefaultFitter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:2349,Availability,error,error,2349,"se(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); virtual Double_t*GetCovarianceMatrix() const; virtual Double_tGetCovarianceMatrixElement(Int_t i, Int_t j) const; static const char*TVirtualFitter::GetDefaultFitter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:2433,Availability,error,error,2433,"se(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); virtual Double_t*GetCovarianceMatrix() const; virtual Double_tGetCovarianceMatrixElement(Int_t i, Int_t j) const; static const char*TVirtualFitter::GetDefaultFitter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:14627,Availability,error,errors,14627,"nst; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globc",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:14640,Availability,error,errors,14640,"nst; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globc",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:14878,Availability,error,error,14878," 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t ",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:15285,Availability,error,error,15285,"bject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-ne",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:15425,Availability,error,error,15425,"hErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit re",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:15480,Availability,avail,available,15480,"hErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit re",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:15606,Availability,error,errors,15606,"at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit par",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:15802,Availability,error,error,15802,"ter; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Dou",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:16020,Availability,error,errors,16020,"rvals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:19522,Availability,Error,ErrorDef,19522," done.; For keeping a minimizer pointer the method ReCreateMinimizer() could eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:19551,Availability,error,error,19551," done.; For keeping a minimizer pointer the method ReCreateMinimizer() could eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:19582,Availability,error,error,19582,"reateMinimizer() could eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail ",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:625,Deployability,configurat,configuration,625,". TBackCompFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. TBackCompFitter. Backward compatible implementation of TVirtualFitter using the; class ROOT::Fit::Fitter. This class is created after fitting an; histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class; (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using. <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also; provided. Note that after a new calls to TH1::Fit (or similar) the; class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the; class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:13103,Deployability,configurat,configuration,13103,"orDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the interva",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:16505,Deployability,Release,ReleaseParameter,16505," eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); override setFCN to use the Adapter to Minuit2 FCN interface; To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* ); To set the address of the minimization function*-;",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:16535,Deployability,release,release,16535," eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); override setFCN to use the Adapter to Minuit2 FCN interface; To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* ); To set the address of the minimization function*-;",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:19886,Deployability,configurat,configuration,19886,"ould eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:17317,Energy Efficiency,Adapt,Adapter,17317,"rameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); override setFCN to use the Adapter to Minuit2 FCN interface; To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* ); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. void SetObjFunction(ROOT::Math::IMultiGenFunction* f); set the objective function for fitting; Needed if fitting directly using TBackCompFitter class; The class clones a copy of the function and manages it. void DoSetDimension(); Private method to set dimension in objective function. ROOT::Math::IMultiGenFunction * GetObjFunction() const; return a pointer to the objective function (FCN); If fitting directly using TBackCompFitter the pointer is managed by the class,; which has been set previously when calling SetObjFunction or SetFCN; Otherwise if the class is used in the backward compatible mode (e.g. after having fitted a TH1); the return pointer will be valid after fitting a",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:12796,Integrability,interface,interface,12796,"itter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, In",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:13538,Integrability,interface,interface,13538,":Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confid",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:17317,Integrability,Adapter,Adapter,17317,"rameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); override setFCN to use the Adapter to Minuit2 FCN interface; To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* ); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. void SetObjFunction(ROOT::Math::IMultiGenFunction* f); set the objective function for fitting; Needed if fitting directly using TBackCompFitter class; The class clones a copy of the function and manages it. void DoSetDimension(); Private method to set dimension in objective function. ROOT::Math::IMultiGenFunction * GetObjFunction() const; return a pointer to the objective function (FCN); If fitting directly using TBackCompFitter the pointer is managed by the class,; which has been set previously when calling SetObjFunction or SetFCN; Otherwise if the class is used in the backward compatible mode (e.g. after having fitted a TH1); the return pointer will be valid after fitting a",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:17340,Integrability,interface,interface,17340,"rameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); override setFCN to use the Adapter to Minuit2 FCN interface; To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* ); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. void SetObjFunction(ROOT::Math::IMultiGenFunction* f); set the objective function for fitting; Needed if fitting directly using TBackCompFitter class; The class clones a copy of the function and manages it. void DoSetDimension(); Private method to set dimension in objective function. ROOT::Math::IMultiGenFunction * GetObjFunction() const; return a pointer to the objective function (FCN); If fitting directly using TBackCompFitter the pointer is managed by the class,; which has been set previously when calling SetObjFunction or SetFCN; Otherwise if the class is used in the backward compatible mode (e.g. after having fitted a TH1); the return pointer will be valid after fitting a",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:19853,Integrability,interface,interface,19853,"ould eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:625,Modifiability,config,configuration,625,". TBackCompFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. TBackCompFitter. Backward compatible implementation of TVirtualFitter using the; class ROOT::Fit::Fitter. This class is created after fitting an; histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class; (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using. <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also; provided. Note that after a new calls to TH1::Fit (or similar) the; class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the; class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:5558,Modifiability,Inherit,InheritsFrom,5558," value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; virtual Double_tGetParError(Int_t ipar) const; virtual const char*GetParName(Int_t ipar) const; static Double_tTVirtualFitter::GetPrecision(); virtual Int_tGetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; virtual Double_tGetSumLog(Int_t i); TFitResult*GetTFitResult() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TObject*TVirtualFitter::GetUserFunc() const; virtual Int_tTVirtualFitter::GetXfirst() const; virtual Int_tTVirtualFitter::GetXlast() const; virtual Int_tTVirtualFitter::GetYfirst() const; virtual Int_tTVirtualFitter::GetYlast() const; virtual Int_tTVirtualFitter::GetZfirst() const; virtual Int_tTVirtualFitter::GetZlast() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFixed(Int_t ipar) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:5624,Modifiability,Inherit,InheritsFrom,5624,"rtual Double_tGetParError(Int_t ipar) const; virtual const char*GetParName(Int_t ipar) const; static Double_tTVirtualFitter::GetPrecision(); virtual Int_tGetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; virtual Double_tGetSumLog(Int_t i); TFitResult*GetTFitResult() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TObject*TVirtualFitter::GetUserFunc() const; virtual Int_tTVirtualFitter::GetXfirst() const; virtual Int_tTVirtualFitter::GetXlast() const; virtual Int_tTVirtualFitter::GetYfirst() const; virtual Int_tTVirtualFitter::GetYlast() const; virtual Int_tTVirtualFitter::GetZfirst() const; virtual Int_tTVirtualFitter::GetZlast() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFixed(Int_t ipar) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBackCompFit",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:12663,Modifiability,Inherit,Inheritance,12663," X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::c",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:12676,Modifiability,Inherit,Inherited,12676," X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::c",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:13103,Modifiability,config,configuration,13103,"orDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the interva",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:15731,Modifiability,variab,variable,15731," Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t S",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:17317,Modifiability,Adapt,Adapter,17317,"rameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); override setFCN to use the Adapter to Minuit2 FCN interface; To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* ); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. void SetObjFunction(ROOT::Math::IMultiGenFunction* f); set the objective function for fitting; Needed if fitting directly using TBackCompFitter class; The class clones a copy of the function and manages it. void DoSetDimension(); Private method to set dimension in objective function. ROOT::Math::IMultiGenFunction * GetObjFunction() const; return a pointer to the objective function (FCN); If fitting directly using TBackCompFitter the pointer is managed by the class,; which has been set previously when calling SetObjFunction or SetFCN; Otherwise if the class is used in the backward compatible mode (e.g. after having fitted a TH1); the return pointer will be valid after fitting a",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:19886,Modifiability,config,configuration,19886,"ould eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:19968,Modifiability,Config,Config,19968,"ould eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:11479,Performance,cache,cache,11479,"eted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)TVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFu",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:1180,Safety,avoid,avoid,1180,"class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. TBackCompFitter. Backward compatible implementation of TVirtualFitter using the; class ROOT::Fit::Fitter. This class is created after fitting an; histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class; (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using. <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also; provided. Note that after a new calls to TH1::Fit (or similar) the; class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the; class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; vir",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:564,Security,access,access,564,". TBackCompFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. TBackCompFitter. Backward compatible implementation of TVirtualFitter using the; class ROOT::Fit::Fitter. This class is created after fitting an; histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class; (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using. <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also; provided. Note that after a new calls to TH1::Fit (or similar) the; class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the; class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:5448,Security,Hash,Hash,5448,"const; virtual Double_tGetParameter(Int_t ipar) const; virtual Int_tGetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; virtual Double_tGetParError(Int_t ipar) const; virtual const char*GetParName(Int_t ipar) const; static Double_tTVirtualFitter::GetPrecision(); virtual Int_tGetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; virtual Double_tGetSumLog(Int_t i); TFitResult*GetTFitResult() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TObject*TVirtualFitter::GetUserFunc() const; virtual Int_tTVirtualFitter::GetXfirst() const; virtual Int_tTVirtualFitter::GetXlast() const; virtual Int_tTVirtualFitter::GetYfirst() const; virtual Int_tTVirtualFitter::GetYlast() const; virtual Int_tTVirtualFitter::GetZfirst() const; virtual Int_tTVirtualFitter::GetZlast() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFixed(Int_t ipar) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:9484,Testability,Test,TestBit,9484,"tle); virtual voidTVirtualFitter::SetObjectFit(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetObjFunction(ROOT::Math::IMultiGenFunction* f); virtual Int_tSetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); static voidTVirtualFitter::SetPrecision(Double_t prec = 9.9999999999999995E-7); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTVirtualFitter::SetUserFunc(TObject* userfunc); virtual voidTVirtualFitter::SetXfirst(Int_t first); virtual voidTVirtualFitter::SetXlast(Int_t last); virtual voidTVirtualFitter::SetYfirst(Int_t first); virtual voidTVirtualFitter::SetYlast(Int_t last); virtual voidTVirtualFitter::SetZfirst(Int_t first); virtual voidTVirtualFitter::SetZlast(Int_t last); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBackCompFitter(); TBackCompFitter(const TBackCompFitter&); TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidDoSetDimension(); voidTObject::MakeZombie(); boolValidParameterIndex(int ipar) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TBackCompFitter::(anonymous",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:9523,Testability,Test,TestBits,9523,"tle); virtual voidTVirtualFitter::SetObjectFit(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetObjFunction(ROOT::Math::IMultiGenFunction* f); virtual Int_tSetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); static voidTVirtualFitter::SetPrecision(Double_t prec = 9.9999999999999995E-7); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTVirtualFitter::SetUserFunc(TObject* userfunc); virtual voidTVirtualFitter::SetXfirst(Int_t first); virtual voidTVirtualFitter::SetXlast(Int_t last); virtual voidTVirtualFitter::SetYfirst(Int_t first); virtual voidTVirtualFitter::SetYlast(Int_t last); virtual voidTVirtualFitter::SetZfirst(Int_t first); virtual voidTVirtualFitter::SetZlast(Int_t last); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBackCompFitter(); TBackCompFitter(const TBackCompFitter&); TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidDoSetDimension(); voidTObject::MakeZombie(); boolValidParameterIndex(int ipar) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TBackCompFitter::(anonymous",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:16271,Testability,log,log,16271,"rianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *,",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:13351,Usability,Clear,Clear,13351,"hed covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBackCompFitter.html:13381,Usability,clear,clear,13381,"hed covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is",MatchSource.WIKI,root/html604/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html
https://root.cern/root/html604/TBase64.html:346,Integrability,message,messages,346,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBase64(); TBase64(const TBase64&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBase64.html
https://root.cern/root/html604/TBase64.html:393,Integrability,protocol,protocols,393,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBase64(); TBase64(const TBase64&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBase64.html
https://root.cern/root/html604/TBase64.html:435,Integrability,message,messages,435,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBase64(); TBase64(const TBase64&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBase64.html
https://root.cern/root/html604/TBase64.html:915,Modifiability,Inherit,Inheritance,915,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBase64(); TBase64(const TBase64&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBase64.html
https://root.cern/root/html604/TBase64.html:928,Modifiability,Inherit,Inherited,928,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBase64(); TBase64(const TBase64&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBase64.html
https://root.cern/root/html604/TBase64.html:377,Security,authenticat,authentication,377,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBase64(); TBase64(const TBase64&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBase64.html
https://root.cern/root/html604/TBaseClass.html:1424,Availability,Error,Error,1424," virtual~TBaseClass(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttri",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:1553,Availability,error,error,1553," virtual~TBaseClass(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttri",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:1637,Availability,error,error,1637,"st char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_t",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:5648,Deployability,Update,UpdateInterpreterStateMarker,5648,"d::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. TBaseClass&operator=(const TBaseClass&); TBaseClass(const TBaseClass&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TDictionary::ESTLTypeTDictionary::kBitset; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TDictionary::ESTLTypeTDictionary::kDeque; static TDictionary::ESTLTypeTDictionary::kForwardlist; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TDictionary::ESTLTypeTDictionary::kList; static TDictionary::ESTLTypeTDictionary::kMap; static TDictionary::ESTLTypeTDictionary::kMultimap; static TDictionary::ESTLTypeTDictionary::kMultiset; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TDict",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:530,Modifiability,inherit,inherited,530,". TBaseClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TBaseClass. class TBaseClass: public TDictionary. Each class (see TClass) has a linked list of its base class(es).; This class describes one single base class.; The base class info is obtained via the CINT api.; see class TCling. The base class information is used a.o. in to find all inherited; methods. Function Members (Methods); public:. virtual~TBaseClass(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttri",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:2810,Modifiability,Inherit,InheritsFrom,2810,"uffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; ROOT::ESTLTypeIsSTLContainer(); Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::o",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:2876,Modifiability,Inherit,InheritsFrom,2876,"ar* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; ROOT::ESTLTypeIsSTLContainer(); Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Opt",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:7642,Modifiability,Inherit,Inheritance,7642,"Deleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TDictionary::ESTLTypeTDictionary::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDictionary::ESTLTypeTDictionary::kUnorderedMap; static TDictionary::ESTLTypeTDictionary::kUnorderedMultimap; static TDictionary::ESTLTypeTDictionary::kUnorderedMultiset; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!pointer to parent class; TClassReffClassPtrpointer to the base class TClass; Int_tfDeltaBaseClassInfo_t offset (INT_MAX if unset); BaseClassInfo_t*fInfo!pointer to CINT base class info; Int_tfPropertyBaseClassInfo_t's properties; Int_tfSTLTypecache of IsSTLContainer(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCling::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta(); Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). ROOT::ESTLType IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Streamer(TBuffer& ); Stream an object of TBaseClass. Triggers the calculation of the; cache variables to store them. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {retur",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:7655,Modifiability,Inherit,Inherited,7655,"Deleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TDictionary::ESTLTypeTDictionary::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDictionary::ESTLTypeTDictionary::kUnorderedMap; static TDictionary::ESTLTypeTDictionary::kUnorderedMultimap; static TDictionary::ESTLTypeTDictionary::kUnorderedMultiset; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!pointer to parent class; TClassReffClassPtrpointer to the base class TClass; Int_tfDeltaBaseClassInfo_t offset (INT_MAX if unset); BaseClassInfo_t*fInfo!pointer to CINT base class info; Int_tfPropertyBaseClassInfo_t's properties; Int_tfSTLTypecache of IsSTLContainer(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCling::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta(); Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). ROOT::ESTLType IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Streamer(TBuffer& ); Stream an object of TBaseClass. Triggers the calculation of the; cache variables to store them. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {retur",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:8537,Modifiability,variab,variables,8537,"set; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!pointer to parent class; TClassReffClassPtrpointer to the base class TClass; Int_tfDeltaBaseClassInfo_t offset (INT_MAX if unset); BaseClassInfo_t*fInfo!pointer to CINT base class info; Int_tfPropertyBaseClassInfo_t's properties; Int_tfSTLTypecache of IsSTLContainer(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCling::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta(); Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). ROOT::ESTLType IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Streamer(TBuffer& ); Stream an object of TBaseClass. Triggers the calculation of the; cache variables to store them. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. void SetClass(TClass* cl); { fClass = cl; }. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:2048,Performance,load,load,2048,"nary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(c",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:8066,Performance,load,load,8066,"set; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!pointer to parent class; TClassReffClassPtrpointer to the base class TClass; Int_tfDeltaBaseClassInfo_t offset (INT_MAX if unset); BaseClassInfo_t*fInfo!pointer to CINT base class info; Int_tfPropertyBaseClassInfo_t's properties; Int_tfSTLTypecache of IsSTLContainer(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCling::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta(); Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). ROOT::ESTLType IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Streamer(TBuffer& ); Stream an object of TBaseClass. Triggers the calculation of the; cache variables to store them. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. void SetClass(TClass* cl); { fClass = cl; }. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:8531,Performance,cache,cache,8531,"set; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!pointer to parent class; TClassReffClassPtrpointer to the base class TClass; Int_tfDeltaBaseClassInfo_t offset (INT_MAX if unset); BaseClassInfo_t*fInfo!pointer to CINT base class info; Int_tfPropertyBaseClassInfo_t's properties; Int_tfSTLTypecache of IsSTLContainer(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCling::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta(); Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). ROOT::ESTLType IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Streamer(TBuffer& ); Stream an object of TBaseClass. Triggers the calculation of the; cache variables to store them. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. void SetClass(TClass* cl); { fClass = cl; }. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:2700,Security,Hash,Hash,2700,"px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta(); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; ROOT::ESTLTypeIsSTLContainer(); Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(siz",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:5129,Testability,Test,TestBit,5129,"Object::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tProperty() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClass(TClass* cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:5168,Testability,Test,TestBits,5168,"Object::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Long_tProperty() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClass(TClass* cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBaseClass.html:842,Usability,Clear,Clear,842," virtual~TBaseClass(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttri",MatchSource.WIKI,root/html604/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBaseClass.html
https://root.cern/root/html604/TBasket.html:1333,Availability,Error,Error,1333," virtual~TBasket(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustSize(Int_t newsize); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tCopyTo(TFile* to); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidDeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tGetBufferSize() const; vir",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:1462,Availability,error,error,1462,"AdjustSize(Int_t newsize); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tCopyTo(TFile* to); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidDeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tGetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*GetEntryOffset() const; Int_tGetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:1546,Availability,error,error,1546,"rtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tCopyTo(TFile* to); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidDeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tGetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*GetEntryOffset() const; Int_tGetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::G",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:10721,Availability,error,error,10721,"ctory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:11597,Availability,error,error,11597," 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:12774,Availability,error,error,12774,"te that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {return fEntryOffset;}. Int_t GetNevBuf() const; {return fNevBuf;}. Int_t GetNevBufSize() const; {return fNevBufSize;}. Int_t GetLast() const; {return fLast;}. void PrepareBasket(Long64_t ); {}. void SetBranch(TBranch* branch); { fBranch = branch; }. void SetNevBufSize(Int_t n); { fNevBufSize=n; }. void Update(Int_t newlast); { Update(newlast,newlast); }. » Author: Rene Brun 19/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:12544,Deployability,Update,Update,12544,"s, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {return fEntryOffset;}. Int_t GetNevBuf() const; {return fNevBuf;}. Int_t GetNevBufSize() const; {return fNevBufSize;}. Int_t GetLast() const; {return fLast;}. void PrepareBasket(Long64_t ); {}. void SetBranch(TBranch* branch); { fBranch = branch; }. void SetNevBufSize(Int_t n); { fNevBufSize=n; }. void Update(Int_t newlast); { Update(newlast,newlast); }. » Author: Rene Brun 19/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. ",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:12582,Deployability,Update,Update,12582,"s, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {return fEntryOffset;}. Int_t GetNevBuf() const; {return fNevBuf;}. Int_t GetNevBufSize() const; {return fNevBufSize;}. Int_t GetLast() const; {return fLast;}. void PrepareBasket(Long64_t ); {}. void SetBranch(TBranch* branch); { fBranch = branch; }. void SetNevBufSize(Int_t n); { fNevBufSize=n; }. void Update(Int_t newlast); { Update(newlast,newlast); }. » Author: Rene Brun 19/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. ",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:13442,Deployability,Update,Update,13442,"), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {return fEntryOffset;}. Int_t GetNevBuf() const; {return fNevBuf;}. Int_t GetNevBufSize() const; {return fNevBufSize;}. Int_t GetLast() const; {return fLast;}. void PrepareBasket(Long64_t ); {}. void SetBranch(TBranch* branch); { fBranch = branch; }. void SetNevBufSize(Int_t n); { fNevBufSize=n; }. void Update(Int_t newlast); { Update(newlast,newlast); }. » Author: Rene Brun 19/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:13467,Deployability,Update,Update,13467,"), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {return fEntryOffset;}. Int_t GetNevBuf() const; {return fNevBuf;}. Int_t GetNevBufSize() const; {return fNevBufSize;}. Int_t GetLast() const; {return fLast;}. void PrepareBasket(Long64_t ); {}. void SetBranch(TBranch* branch); { fBranch = branch; }. void SetNevBufSize(Int_t n); { fNevBufSize=n; }. void Update(Int_t newlast); { Update(newlast,newlast); }. » Author: Rene Brun 19/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:12334,Energy Efficiency,Reduce,Reduce,12334,"buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {return fEntryOffset;}. Int_t GetNevBuf() const; {return fNevBuf;}. Int_t GetNevBufSize() const; {return fNevBufSize;}. Int_t GetLast() const; {return fLast;}. void PrepareBasket(Long64_t ); {}. void SetBranch(TBranch* branch);",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:3236,Modifiability,Inherit,InheritsFrom,3236,"ntryOffset() const; Int_tGetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; Int_tGetNevBuf() const; Int_tGetNevBufSize() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tLoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:3302,Modifiability,Inherit,InheritsFrom,3302,":GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; Int_tGetNevBuf() const; Int_tGetNevBufSize() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tLoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:9802,Modifiability,Inherit,Inheritance,9802,"s for the key itself; Int_tfLastPointer to last used byte in basket; Int_tfLastWriteBufferSize! Size of the buffer last time we wrote it to disk; Int_tTKey::fLeftNumber of bytes left in current segment; TDirectory*TKey::fMotherDir! pointer to mother directory; TStringTNamed::fNameobject identifier; Int_tTKey::fNbytesNumber of bytes for the object on file; Int_tfNevBufNumber of entries in basket; Int_tfNevBufSizeLength in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!; Int_tTKey::fObjlenLength of uncompressed object in bytes; Bool_tfOwnsCompressedBuffer! Whether or not we own the compressed buffer.; UShort_tTKey::fPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentr",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:9815,Modifiability,Inherit,Inherited,9815,"s for the key itself; Int_tfLastPointer to last used byte in basket; Int_tfLastWriteBufferSize! Size of the buffer last time we wrote it to disk; Int_tTKey::fLeftNumber of bytes left in current segment; TDirectory*TKey::fMotherDir! pointer to mother directory; TStringTNamed::fNameobject identifier; Int_tTKey::fNbytesNumber of bytes for the object on file; Int_tfNevBufNumber of entries in basket; Int_tfNevBufSizeLength in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!; Int_tTKey::fObjlenLength of uncompressed object in bytes; Bool_tfOwnsCompressedBuffer! Whether or not we own the compressed buffer.; UShort_tTKey::fPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentr",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:10501,Performance,Load,LoadBasketBuffers,10501,"lly saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function retu",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:10575,Performance,Load,Load,10575,"lly saved in the high bits of fSeekPdir; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function retu",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:11138,Performance,cache,cache,11138,"during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory a",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:11723,Performance,cache,cache,11723," 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:11870,Performance,cache,cache,11870," 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:11983,Performance,cache,cache,11983,"as been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(cons",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:3071,Security,Hash,Hash,3071,"t; const TDatime&TKey::GetDatime() const; Int_t*GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*GetEntryOffset() const; Int_tGetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; Int_tGetNevBuf() const; Int_tGetNevBufSize() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tLoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); void",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:6335,Testability,Test,TestBit,6335,"j(); virtual void*TKey::ReadObjectAny(const TClass* expectedClass); virtual TObject*TKey::ReadObjWithBuffer(char* bufferRead); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBranch(TBranch* branch); virtual voidTKey::SetBuffer(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTKey::SetMotherDir(TDirectory* dir); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNevBufSize(Int_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTKey::SetParent(const TObject* parent); virtual voidSetReadMode(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWriteMode(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTKey::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBasket(); TBasket(TDirectory* motherDir); TBasket(const char* name, const char* title, TBranch* branch); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdate(Int_t newlast); virtual voidUpdate(Int_t newlast, Int_t skipped); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(); virtual Int_tTKey::WriteFile(Int_t cycle = 1, TFile* f = 0).",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:6374,Testability,Test,TestBits,6374,"j(); virtual void*TKey::ReadObjectAny(const TClass* expectedClass); virtual TObject*TKey::ReadObjWithBuffer(char* bufferRead); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBranch(TBranch* branch); virtual voidTKey::SetBuffer(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTKey::SetMotherDir(TDirectory* dir); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNevBufSize(Int_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTKey::SetParent(const TObject* parent); virtual voidSetReadMode(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWriteMode(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTKey::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBasket(); TBasket(TDirectory* motherDir); TBasket(const char* name, const char* title, TBranch* branch); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdate(Int_t newlast); virtual voidUpdate(Int_t newlast, Int_t skipped); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(); virtual Int_tTKey::WriteFile(Int_t cycle = 1, TFile* f = 0).",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:12105,Testability,log,logical,12105," cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasket.html:676,Usability,Clear,Clear,676," virtual~TBasket(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustSize(Int_t newsize); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tCopyTo(TFile* to); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidDeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tGetBufferSize() const; vir",MatchSource.WIKI,root/html604/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasket.html
https://root.cern/root/html604/TBasketSQL.html:1474,Availability,Error,Error,1474,"justSize(Int_t newsize); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tTBasket::CopyTo(TFile* to); voidCreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidTBasket::DeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTBasket::DropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TBasket::GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tTBasket::GetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*TBasket::GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*TBasket::GetEntryOffset() const; Int_tTBasket::GetEntryPointer(Int_t En",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:1603,Availability,error,error,1603,"ass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tTBasket::CopyTo(TFile* to); voidCreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidTBasket::DeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTBasket::DropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TBasket::GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tTBasket::GetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*TBasket::GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*TBasket::GetEntryOffset() const; Int_tTBasket::GetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeyl",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:1687,Availability,error,error,1687,"r(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tTBasket::CopyTo(TFile* to); voidCreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidTBasket::DeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTBasket::DropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TBasket::GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tTBasket::GetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*TBasket::GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*TBasket::GetEntryOffset() const; Int_tTBasket::GetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tTBasket::GetLast() const; TDirectory*TKey::GetMotherDir() const; vi",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:10977,Deployability,Update,Update,10977,"le; Int_tTBasket::fNevBufNumber of entries in basket; Int_tTBasket::fNevBufSizeLength in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!; Int_tTKey::fObjlenLength of uncompressed object in bytes; Bool_tTBasket::fOwnsCompressedBuffer! Whether or not we own the compressed buffer.; UShort_tTKey::fPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; TSQLResult**fResultPtr!; TSQLRow**fRowPtr!; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasketSQL(); Default constructor. TBasketSQL(const char* name, const char* title, TBranch* branch, TSQLResult** rs, TString* insert_query, vector<Int_t>* vc, TSQLRow** row); Regular constructor. ~TBasketSQL(); Destructor. void CreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); Create a TSQLBuffer for this basket. void PrepareBasket(Long64_t entry); Prepare the basket for the next entry. Int_t ReadBasketBytes(Long64_t pos, TFile* file); See TBasket::ReadBasketBytes. This is not implemented in TBasketSQL. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); See TBasket::ReadBasketBuffers. This is not implemented in TBasketSQL. void Reset(); See TBasket::Reset. void Update(Int_t offset, Int_t skipped); See TBasket::Update. TBasketSQL(const TBasketSQL& ). TBasketSQL& operator=(const TBasketSQL& ). TSQLResult * GetResultSet(); { return *fResultPtr;}. » Author: Philippe Canal 2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:11027,Deployability,Update,Update,11027,"le; Int_tTBasket::fNevBufNumber of entries in basket; Int_tTBasket::fNevBufSizeLength in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!; Int_tTKey::fObjlenLength of uncompressed object in bytes; Bool_tTBasket::fOwnsCompressedBuffer! Whether or not we own the compressed buffer.; UShort_tTKey::fPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; TSQLResult**fResultPtr!; TSQLRow**fRowPtr!; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasketSQL(); Default constructor. TBasketSQL(const char* name, const char* title, TBranch* branch, TSQLResult** rs, TString* insert_query, vector<Int_t>* vc, TSQLRow** row); Regular constructor. ~TBasketSQL(); Destructor. void CreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); Create a TSQLBuffer for this basket. void PrepareBasket(Long64_t entry); Prepare the basket for the next entry. Int_t ReadBasketBytes(Long64_t pos, TFile* file); See TBasket::ReadBasketBytes. This is not implemented in TBasketSQL. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); See TBasket::ReadBasketBuffers. This is not implemented in TBasketSQL. void Reset(); See TBasket::Reset. void Update(Int_t offset, Int_t skipped); See TBasket::Update. TBasketSQL(const TBasketSQL& ). TBasketSQL& operator=(const TBasketSQL& ). TSQLResult * GetResultSet(); { return *fResultPtr;}. » Author: Philippe Canal 2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:3476,Modifiability,Inherit,InheritsFrom,3476," TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tTBasket::GetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; Int_tTBasket::GetNevBuf() const; Int_tTBasket::GetNevBufSize() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; TSQLResult*GetResultSet(); virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tTBasket::LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTBasket::MoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TOb",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:3542,Modifiability,Inherit,InheritsFrom,3542,"() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tTBasket::GetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; Int_tTBasket::GetNevBuf() const; Int_tTBasket::GetNevBufSize() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; TSQLResult*GetResultSet(); virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tTBasket::LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTBasket::MoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t s",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:10168,Modifiability,Inherit,Inheritance,10168,"t::fLastWriteBufferSize! Size of the buffer last time we wrote it to disk; Int_tTKey::fLeftNumber of bytes left in current segment; TDirectory*TKey::fMotherDir! pointer to mother directory; TStringTNamed::fNameobject identifier; Int_tTKey::fNbytesNumber of bytes for the object on file; Int_tTBasket::fNevBufNumber of entries in basket; Int_tTBasket::fNevBufSizeLength in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!; Int_tTKey::fObjlenLength of uncompressed object in bytes; Bool_tTBasket::fOwnsCompressedBuffer! Whether or not we own the compressed buffer.; UShort_tTKey::fPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; TSQLResult**fResultPtr!; TSQLRow**fRowPtr!; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasketSQL(); Default constructor. TBasketSQL(const char* name, const char* title, TBranch* branch, TSQLResult** rs, TString* insert_query, vector<Int_t>* vc, TSQLRow** row); Regular constructor. ~TBasketSQL(); Destructor. void CreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); Create a TSQLBuffer for this basket. void PrepareBasket(Long64_t entry); Prepare the basket for the next entry. Int_t ReadBasketBytes(Long64_t pos, TFile* file); See TBasket::ReadBasketBytes. This is not implemented in TBasketSQL. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); See TBasket::ReadBasketBuffers. This is not implemented in TBasketSQL. void Reset(); See TBasket::Reset. void Update(Int_t offset, Int_t skipped); See TBasket::Update. TBasketSQL(const TBasketSQL& ). TBasketSQL& operator=(const TBasketSQL& ). TSQLResult * GetResultSet(); { return *fResultPtr;}. » Author: Philippe Canal 2005 »",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:10181,Modifiability,Inherit,Inherited,10181,"t::fLastWriteBufferSize! Size of the buffer last time we wrote it to disk; Int_tTKey::fLeftNumber of bytes left in current segment; TDirectory*TKey::fMotherDir! pointer to mother directory; TStringTNamed::fNameobject identifier; Int_tTKey::fNbytesNumber of bytes for the object on file; Int_tTBasket::fNevBufNumber of entries in basket; Int_tTBasket::fNevBufSizeLength in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!; Int_tTKey::fObjlenLength of uncompressed object in bytes; Bool_tTBasket::fOwnsCompressedBuffer! Whether or not we own the compressed buffer.; UShort_tTKey::fPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; TSQLResult**fResultPtr!; TSQLRow**fRowPtr!; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasketSQL(); Default constructor. TBasketSQL(const char* name, const char* title, TBranch* branch, TSQLResult** rs, TString* insert_query, vector<Int_t>* vc, TSQLRow** row); Regular constructor. ~TBasketSQL(); Destructor. void CreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); Create a TSQLBuffer for this basket. void PrepareBasket(Long64_t entry); Prepare the basket for the next entry. Int_t ReadBasketBytes(Long64_t pos, TFile* file); See TBasket::ReadBasketBytes. This is not implemented in TBasketSQL. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); See TBasket::ReadBasketBuffers. This is not implemented in TBasketSQL. void Reset(); See TBasket::Reset. void Update(Int_t offset, Int_t skipped); See TBasket::Update. TBasketSQL(const TBasketSQL& ). TBasketSQL& operator=(const TBasketSQL& ). TSQLResult * GetResultSet(); { return *fResultPtr;}. » Author: Philippe Canal 2005 »",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:3929,Performance,Load,LoadBasketBuffers,3929,"tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; TSQLResult*GetResultSet(); virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tTBasket::LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTBasket::MoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrepareBasket(Long64_t entry); virtual voidTKey::Print(Option_t* option = """") const; virtual Int_tTKey::Read(TObject* obj); virtual Int_tReadBasketBuffers(Long64_t pos, Int_t len, TFile* file)",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:3311,Security,Hash,Hash,3311," virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*TBasket::GetEntryOffset() const; Int_tTBasket::GetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tTBasket::GetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; Int_tTBasket::GetNevBuf() const; Int_tTBasket::GetNevBufSize() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t*TObject::GetOption() const; TSQLResult*GetResultSet(); virtual Long64_tTKey::GetSeekKey() const; virtual Long64_tTKey::GetSeekPdir() const; virtual const char*TKey::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTKey::GetVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTKey::Hash() const; virtual voidTKey::IncrementPidOffset(UShort_t offset); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTKey::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTKey::Keep(); Int_tTBasket::LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file, TTree* tree = 0); virtual voidTKey::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTBasket::MoveEntries(Int_t dentries); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delet",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:6699,Testability,Test,TestBit,6699,"); virtual TObject*TKey::ReadObjWithBuffer(char* bufferRead); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTBasket::SetBranch(TBranch* branch); virtual voidTKey::SetBuffer(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTKey::SetMotherDir(TDirectory* dir); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidTBasket::SetNevBufSize(Int_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTKey::SetParent(const TObject* parent); virtual voidTBasket::SetReadMode(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBasket::SetWriteMode(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTKey::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBasketSQL(); TBasketSQL(const char* name, const char* title, TBranch* branch, TSQLResult** rs, TString* insert_query, vector<Int_t>* vc, TSQLRow** row); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(Int_t offset, Int_t skipped); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tTBasket::WriteBuffer(); virtual Int_tTKey::WriteFile(Int_t cycle = 1, TFile* f = 0).",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:6738,Testability,Test,TestBits,6738,"); virtual TObject*TKey::ReadObjWithBuffer(char* bufferRead); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTBasket::SetBranch(TBranch* branch); virtual voidTKey::SetBuffer(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTKey::SetMotherDir(TDirectory* dir); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidTBasket::SetNevBufSize(Int_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTKey::SetParent(const TObject* parent); virtual voidTBasket::SetReadMode(); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBasket::SetWriteMode(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTKey::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBasketSQL(); TBasketSQL(const char* name, const char* title, TBranch* branch, TSQLResult** rs, TString* insert_query, vector<Int_t>* vc, TSQLRow** row); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(Int_t offset, Int_t skipped); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tTBasket::WriteBuffer(); virtual Int_tTKey::WriteFile(Int_t cycle = 1, TFile* f = 0).",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBasketSQL.html:686,Usability,Clear,Clear,686," virtual~TBasketSQL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBasket::AdjustSize(Int_t newsize); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tTBasket::CopyTo(TFile* to); voidCreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidTBasket::DeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTBasket::DropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj",MatchSource.WIKI,root/html604/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBasketSQL.html
https://root.cern/root/html604/TBenchmark.html:1210,Availability,Error,Error,1210," virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:1339,Availability,error,error,1339," virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:1423,Availability,error,error,1423,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(const char* name); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msg",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:2461,Modifiability,Inherit,InheritsFrom,2461,"t(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(const char* name); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:2527,Modifiability,Inherit,InheritsFrom,2527,"st char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(const char* name); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); vi",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6488,Modifiability,Inherit,Inheritance,6488," static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop bench",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6501,Modifiability,Inherit,Inherited,6501," static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop bench",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:2351,Security,Hash,Hash,2351,"rtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(const char* name); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:339,Testability,benchmark,benchmarking,339,". TBenchmark. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBenchmark. class TBenchmark: public TNamed. TBenchmark. This class is a ROOT utility to help benchmarking applications. Function Members (Methods); public:. virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:4825,Testability,Test,TestBit,4825,"d* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* name = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShow(const char* name); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStart(const char* name); virtual voidStop(const char* name); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidSummary(Float_t& rt, Float_t& cp); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBenchmark(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:4864,Testability,Test,TestBits,4864,"d* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* name = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShow(const char* name); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStart(const char* name); virtual voidStop(const char* name); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidSummary(Float_t& rt, Float_t& cp); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBenchmark(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6271,Testability,benchmark,benchmarks,6271,"mbie(); TBenchmark&operator=(const TBenchmark&); TBenchmark(const TBenchmark&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of th",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6312,Testability,benchmark,benchmarks,6312,"mbie(); TBenchmark&operator=(const TBenchmark&); TBenchmark(const TBenchmark&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of th",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6352,Testability,benchmark,benchmarks,6352,"mbie(); TBenchmark&operator=(const TBenchmark&); TBenchmark(const TBenchmark&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of th",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6579,Testability,Benchmark,Benchmark,6579,"ect::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing bench",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6739,Testability,Benchmark,Benchmark,6739,"t::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. vo",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6818,Testability,Benchmark,Benchmark,6818,"MustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6897,Testability,Benchmark,Benchmark,6897,"ect::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, R",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:6977,Testability,Benchmark,Benchmark,6977,"Canvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generate",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7053,Testability,Benchmark,Benchmark,7053,"mous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7093,Testability,Benchmark,Benchmarks,7093,"ject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7140,Testability,Benchmark,Benchmark,7140,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7212,Testability,Benchmark,Benchmark,7212,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7320,Testability,benchmark,benchmark,7320,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7358,Testability,benchmark,benchmarks,7358,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7371,Testability,Benchmark,Benchmark,7371,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7509,Testability,benchmark,benchmark,7509,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7570,Testability,benchmark,benchmark,7570,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7619,Testability,benchmark,benchmarks,7619,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7709,Testability,Benchmark,Benchmark,7709,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7804,Testability,benchmark,benchmarks,7804,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:667,Usability,Clear,Clear,667," virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBenchmark.html:7593,Usability,resume,resume,7593,"mous)TObject::kZombie. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor. TBenchmark(const TBenchmark& ); Copy constructor. TBenchmark& operator=(const TBenchmark& ); Assignment operator. ~TBenchmark(); Benchmark destructor. Int_t GetBench(const char* name) const; Returns index of Benchmark name. Float_t GetCpuTime(const char* name); Returns Cpu time used by Benchmark name. Float_t GetRealTime(const char* name); Returns Realtime used by Benchmark name. void Print(Option_t* name = """") const; Prints parameters of Benchmark name. void Reset(); Reset all Benchmarks. void Show(const char* name); Stops Benchmark name and Prints results. void Start(const char* name); Starts Benchmark with the specified name. An independent timer (see class TStopwatch) is started.; The name of the benchmark is entered into the list of benchmarks.; Benchmark can be stopped via TBenchmark::Stop().; Results can be printed via TBenchmark::Print().; TBenchmark::Show() can be used to stop benchmark and print results.; If name is an already existing benchmark, timing will resume.; A summary of all benchmarks can be seen via TBenchmark::Summary(). void Stop(const char* name); Terminates Benchmark with specified name. void Summary(Float_t& rt, Float_t& cp); Prints a summary of all benchmarks. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBenchmark.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:631,Availability,avail,available,631,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:777,Availability,error,error,777,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:825,Availability,avail,available,825,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:1437,Availability,avail,available,1437,"ision of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:1549,Availability,error,errors,1549,"ne containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:2860,Availability,reliab,reliable,2860,"is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status == 0) {; // if the fit was successful, display bin-by-bin efficiencies; // as well as the result of the fit; numerator->Sumw2();; TH1* hEff = dynamic_cast<TH1*>(numerator->Clone(""heff""));; hEff->Divide(hEff, denominator, 1.0, 1.0, ""B"");; hEff->Draw(""E"");; eff->Draw(""same"");; }; }. Note that this method cannot be expected to yield reliable results when using; weighted histograms (because the likelihood computation will be incorrect). Function Members (Methods); public:. virtual~TBinomialEfficiencyFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:3822,Availability,Error,Error,3822,,MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:3993,Availability,error,error,3993,,MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:4077,Availability,error,error,4077,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEvaluateFCN(const Double_t* par); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """"); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); ROOT::Fit::Fitter*GetFitter(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const;",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:10691,Availability,error,error,10691,"on); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Double_t& f, const Double_t* par); Compute the likelihood. TBinomialEfficiencyFitter(). Double_t EvaluateFCN(const Double_t* par). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or RO",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:10876,Availability,reliab,reliability,10876,"1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Double_t& f, const Double_t* par); Compute the likelihood. TBinomialEfficiencyFitter(). Double_t EvaluateFCN(const Double_t* par). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:11110,Availability,error,errors,11110,"1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Double_t& f, const Double_t* par); Compute the likelihood. TBinomialEfficiencyFitter(). Double_t EvaluateFCN(const Double_t* par). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:8813,Deployability,integrat,integration,8813,"onst Double_t* par). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. f",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:9720,Deployability,integrat,integration,9720,"er the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:8813,Integrability,integrat,integration,8813,"onst Double_t* par). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. f",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:9720,Integrability,integrat,integration,9720,"er the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:682,Modifiability,variab,variable,682,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:5038,Modifiability,Inherit,InheritsFrom,5038,"ethod, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """"); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); ROOT::Fit::Fitter*GetFitter(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:5104,Modifiability,Inherit,InheritsFrom,5104,"ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """"); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); ROOT::Fit::Fitter*GetFitter(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBinomialEfficiencyFitter&operator=(const TBinomial",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:9099,Modifiability,Inherit,Inheritance,9099,"sBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:9112,Modifiability,Inherit,Inherited,9112,"sBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:4928,Security,Hash,Hash,4928,"Object::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """"); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); ROOT::Fit::Fitter*GetFitter(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:9804,Security,access,access,9804," function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; ROOT::Fit::Fitter*fFitterpointer to the real fitter; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, ",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:7330,Testability,Test,TestBit,7330," voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBinomialEfficiencyFitter&operator=(const TBinomialEfficiencyFitter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(const TH1* numerator, const TH1* denominator); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetPrecision(Double_t epsilon); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBinomialEfficiencyFitter(); TBinomialEfficiencyFitter(const TBinomialEfficiencyFitter&); TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:7369,Testability,Test,TestBits,7369," voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBinomialEfficiencyFitter&operator=(const TBinomialEfficiencyFitter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(const TH1* numerator, const TH1* denominator); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetPrecision(Double_t epsilon); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBinomialEfficiencyFitter(); TBinomialEfficiencyFitter(const TBinomialEfficiencyFitter&); TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:1473,Usability,simpl,simply,1473,"ne containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:3282,Usability,Clear,Clear,3282,,MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBinomialEfficiencyFitter.html:10183,Usability,simpl,simply,10183,"raries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of d",MatchSource.WIKI,root/html604/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html
https://root.cern/root/html604/TBits.html:1607,Availability,Error,Error,1607," virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:1736,Availability,error,error,1736," virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:1820,Availability,error,error,1820,"irtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tFirstNullBit(UInt_t startBit = 0) const; UInt_tFirstSetBit(UInt_t startBit = 0) const; voidGet(Char_t* array) const; voidGet(UChar_t* array) const; voidGet(Short_t* array) const; voidGet(UShort_t* array) const; voidGet(Int_t* array) const; voidGet(UInt_t* array) const; voidGet(Long64_t* array) const; voidGet(ULong64_t* array) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; UInt_tGetNbits() const; UInt_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual ",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:577,Energy Efficiency,reduce,reduce,577,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:8168,Energy Efficiency,Reduce,Reduce,8168,"ject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UChar_t*fAllBits[fNbytes] array of UChars; UInt_tfNbitsHighest bit set + 1; UInt_tfNbytesNumber of UChars in fAllBits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits(UInt_t nbits = 8); TBits constructor. All bits set to 0. TBits(const TBits& ); TBits copy constructor. TBits& operator=(const TBits& ); TBits assignment operator. ~TBits(); TBits destructor. void Clear(Option_t* option = """"); Clear the value. void Compact(); Reduce the storage used by the object to a minimun. UInt_t CountBits(UInt_t startBit = 0) const; Return number of bits set to 1 starting at bit startBit. void DoAndEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoOrEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoXorEqual(const TBits& rhs); Execute (*this) ^= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoFlip(); Execute ~(*this). void DoLeftShift(UInt_t shift); Execute the left shift operation. void DoRightShift(UInt_t shift); Execute the left shift operation. UInt_t FirstNullBit(UInt_t startBit = 0) const; Return position of first null bit (starting from position 0 and up). UInt_t LastNullBit(UInt_t startBit = 999999999) const; Return position of first null bit (starting from position 0 and up). UInt_t FirstSetBit(UInt_t startBit = 0) const; Retur",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:521,Modifiability,extend,extended,521,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:3090,Modifiability,Inherit,InheritsFrom,3090,"; UInt_tFirstNullBit(UInt_t startBit = 0) const; UInt_tFirstSetBit(UInt_t startBit = 0) const; voidGet(Char_t* array) const; voidGet(UChar_t* array) const; voidGet(Short_t* array) const; voidGet(UShort_t* array) const; voidGet(Int_t* array) const; voidGet(UInt_t* array) const; voidGet(Long64_t* array) const; voidGet(ULong64_t* array) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; UInt_tGetNbits() const; UInt_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; UInt_tLastNullBit(UInt_t startBit = 999999999) const; UInt_tLastSetBit(UInt_t startBit = 999999999) const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::opera",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:3156,Modifiability,Inherit,InheritsFrom,3156,"(UInt_t startBit = 0) const; voidGet(Char_t* array) const; voidGet(UChar_t* array) const; voidGet(Short_t* array) const; voidGet(UShort_t* array) const; voidGet(Int_t* array) const; voidGet(UInt_t* array) const; voidGet(Long64_t* array) const; voidGet(ULong64_t* array) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; UInt_tGetNbits() const; UInt_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; UInt_tLastNullBit(UInt_t startBit = 999999999) const; UInt_tLastSetBit(UInt_t startBit = 999999999) const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:7826,Modifiability,Inherit,Inheritance,7826,"st TBits& rhs); voidTObject::MakeZombie(); voidReserveBytes(UInt_t nbytes). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UChar_t*fAllBits[fNbytes] array of UChars; UInt_tfNbitsHighest bit set + 1; UInt_tfNbytesNumber of UChars in fAllBits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits(UInt_t nbits = 8); TBits constructor. All bits set to 0. TBits(const TBits& ); TBits copy constructor. TBits& operator=(const TBits& ); TBits assignment operator. ~TBits(); TBits destructor. void Clear(Option_t* option = """"); Clear the value. void Compact(); Reduce the storage used by the object to a minimun. UInt_t CountBits(UInt_t startBit = 0) const; Return number of bits set to 1 starting at bit startBit. void DoAndEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoOrEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoXorEqual(const TBits& rhs); Execute (*this) ^= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoFlip(); Execute ~(*this). void DoLeftShift(UInt_t shift); Execute the left shift operation. void DoRightShift(UInt_t sh",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:7839,Modifiability,Inherit,Inherited,7839,"st TBits& rhs); voidTObject::MakeZombie(); voidReserveBytes(UInt_t nbytes). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UChar_t*fAllBits[fNbytes] array of UChars; UInt_tfNbitsHighest bit set + 1; UInt_tfNbytesNumber of UChars in fAllBits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits(UInt_t nbits = 8); TBits constructor. All bits set to 0. TBits(const TBits& ); TBits copy constructor. TBits& operator=(const TBits& ); TBits assignment operator. ~TBits(); TBits destructor. void Clear(Option_t* option = """"); Clear the value. void Compact(); Reduce the storage used by the object to a minimun. UInt_t CountBits(UInt_t startBit = 0) const; Return number of bits set to 1 starting at bit startBit. void DoAndEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoOrEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoXorEqual(const TBits& rhs); Execute (*this) ^= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoFlip(); Execute ~(*this). void DoLeftShift(UInt_t shift); Execute the left shift operation. void DoRightShift(UInt_t sh",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:11717,Performance,Optimiz,Optimized,11717,"ompare object. void SetBitNumber(UInt_t bitnumber, Bool_t value = kTRUE); Set bit number 'bitnumber' to be value. Bool_t TestBitNumber(UInt_t bitnumber) const; Return the current value of the bit. void ResetBitNumber(UInt_t bitnumber). Bool_t operator[](UInt_t bitnumber) const. Bool_t operator~(); Flips the bit. TBits::TReference operator[](UInt_t bitnumber); ----- Accessors and operator. { return TReference(*this,bitnumber); }. TBits& operator&=(const TBits& rhs); { DoAndEqual(rhs); return *this; }. TBits& operator|=(const TBits& rhs); { DoOrEqual(rhs); return *this; }. TBits& operator^=(const TBits& rhs); { DoXorEqual(rhs); return *this; }. TBits& operator<<=(UInt_t rhs); { DoLeftShift(rhs); return *this; }. TBits& operator>>=(UInt_t rhs); { DoRightShift(rhs); return *this; }. TBits operator<<(UInt_t rhs); { return TBits(*this)<<= rhs; }. TBits operator>>(UInt_t rhs); { return TBits(*this)>>= rhs; }. void Set(UInt_t nbits, const Char_t* array); ----- Optimized setters; Each of these will replace the contents of the receiver with the bitvector; in the parameter array. The number of bits is changed to nbits. If nbits; is smaller than fNbits, the receiver will NOT be compacted. void Get(Char_t* array) const; ----- Optimized getters; Each of these will replace the contents of the parameter array with the; bits in the receiver. The parameter array must be large enough to hold; all of the bits in the receiver.; Note on semantics: any bits in the parameter array that go beyond the; number of the bits in the receiver will have an unspecified value. For; example, if you call Get(Int*) with an array of one integer and the TBits; object has less than 32 bits, then the remaining bits in the integer will; have an unspecified value. UInt_t GetNbits() const; { return fNbits; }. UInt_t GetNbytes() const; { return fNbytes; }. Bool_t operator!=(const TBits& other) const; { return !(*this==other); }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rad",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:11983,Performance,Optimiz,Optimized,11983,". Bool_t operator[](UInt_t bitnumber) const. Bool_t operator~(); Flips the bit. TBits::TReference operator[](UInt_t bitnumber); ----- Accessors and operator. { return TReference(*this,bitnumber); }. TBits& operator&=(const TBits& rhs); { DoAndEqual(rhs); return *this; }. TBits& operator|=(const TBits& rhs); { DoOrEqual(rhs); return *this; }. TBits& operator^=(const TBits& rhs); { DoXorEqual(rhs); return *this; }. TBits& operator<<=(UInt_t rhs); { DoLeftShift(rhs); return *this; }. TBits& operator>>=(UInt_t rhs); { DoRightShift(rhs); return *this; }. TBits operator<<(UInt_t rhs); { return TBits(*this)<<= rhs; }. TBits operator>>(UInt_t rhs); { return TBits(*this)>>= rhs; }. void Set(UInt_t nbits, const Char_t* array); ----- Optimized setters; Each of these will replace the contents of the receiver with the bitvector; in the parameter array. The number of bits is changed to nbits. If nbits; is smaller than fNbits, the receiver will NOT be compacted. void Get(Char_t* array) const; ----- Optimized getters; Each of these will replace the contents of the parameter array with the; bits in the receiver. The parameter array must be large enough to hold; all of the bits in the receiver.; Note on semantics: any bits in the parameter array that go beyond the; number of the bits in the receiver will have an unspecified value. For; example, if you call Get(Int*) with an array of one integer and the TBits; object has less than 32 bits, then the remaining bits in the integer will; have an unspecified value. UInt_t GetNbits() const; { return fNbits; }. UInt_t GetNbytes() const; { return fNbytes; }. Bool_t operator!=(const TBits& other) const; { return !(*this==other); }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:2980,Security,Hash,Hash,2980,"TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tFirstNullBit(UInt_t startBit = 0) const; UInt_tFirstSetBit(UInt_t startBit = 0) const; voidGet(Char_t* array) const; voidGet(UChar_t* array) const; voidGet(Short_t* array) const; voidGet(UShort_t* array) const; voidGet(Int_t* array) const; voidGet(UInt_t* array) const; voidGet(Long64_t* array) const; voidGet(ULong64_t* array) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; UInt_tGetNbits() const; UInt_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; UInt_tLastNullBit(UInt_t startBit = 999999999) const; UInt_tLastSetBit(UInt_t startBit = 999999999) const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:11118,Security,Access,Accessors,11118,"(Short_t* array) const; Get all the bytes. void Get(Int_t* array) const; Get all the bytes. void Get(Long64_t* array) const; Get all the bytes. void Set(UInt_t nbits, const Short_t* array); make nbytes even so that the loop below is neat. void Set(UInt_t nbits, const Int_t* array); make nbytes a multiple of 4 so that the loop below is neat. void Set(UInt_t nbits, const Long64_t* array); make nbytes a multiple of 8 so that the loop below is neat. void Get(Short_t* array) const; Get all the bytes. void Get(Int_t* array) const; Get all the bytes. void Get(Long64_t* array) const; Get all the bytes. Bool_t operator==(const TBits& other) const; Compare object. void SetBitNumber(UInt_t bitnumber, Bool_t value = kTRUE); Set bit number 'bitnumber' to be value. Bool_t TestBitNumber(UInt_t bitnumber) const; Return the current value of the bit. void ResetBitNumber(UInt_t bitnumber). Bool_t operator[](UInt_t bitnumber) const. Bool_t operator~(); Flips the bit. TBits::TReference operator[](UInt_t bitnumber); ----- Accessors and operator. { return TReference(*this,bitnumber); }. TBits& operator&=(const TBits& rhs); { DoAndEqual(rhs); return *this; }. TBits& operator|=(const TBits& rhs); { DoOrEqual(rhs); return *this; }. TBits& operator^=(const TBits& rhs); { DoXorEqual(rhs); return *this; }. TBits& operator<<=(UInt_t rhs); { DoLeftShift(rhs); return *this; }. TBits& operator>>=(UInt_t rhs); { DoRightShift(rhs); return *this; }. TBits operator<<(UInt_t rhs); { return TBits(*this)<<= rhs; }. TBits operator>>(UInt_t rhs); { return TBits(*this)>>= rhs; }. void Set(UInt_t nbits, const Char_t* array); ----- Optimized setters; Each of these will replace the contents of the receiver with the bitvector; in the parameter array. The number of bits is changed to nbits. If nbits; is smaller than fNbits, the receiver will NOT be compacted. void Get(Char_t* array) const; ----- Optimized getters; Each of these will replace the contents of the parameter array with the; bits in the receiver. The p",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:375,Testability,test,tested,375,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:418,Testability,Test,TestBitNumber,418,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:566,Testability,test,tested,566,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:6171,Testability,Test,TestBit,6171,"onst; TBits&operator^=(const TBits& rhs); TBits&operator|=(const TBits& rhs); TBitsoperator~(); voidOutput(ostream&) const; virtual voidPaint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAllBits(Bool_t value = kFALSE); voidTObject::ResetBit(UInt_t f); voidResetBitNumber(UInt_t bitnumber); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(UInt_t nbits, const Char_t* array); voidSet(UInt_t nbits, const UChar_t* array); voidSet(UInt_t nbits, const Short_t* array); voidSet(UInt_t nbits, const UShort_t* array); voidSet(UInt_t nbits, const Int_t* array); voidSet(UInt_t nbits, const UInt_t* array); voidSet(UInt_t nbits, const Long64_t* array); voidSet(UInt_t nbits, const ULong64_t* array); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBitNumber(UInt_t bitnumber, Bool_t value = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBits(UInt_t nbits = 8); TBits(const TBits&); Bool_tTObject::TestBit(UInt_t f) const; Bool_tTestBitNumber(UInt_t bitnumber) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:6255,Testability,Test,TestBits,6255,"onst; TBits&operator^=(const TBits& rhs); TBits&operator|=(const TBits& rhs); TBitsoperator~(); voidOutput(ostream&) const; virtual voidPaint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAllBits(Bool_t value = kFALSE); voidTObject::ResetBit(UInt_t f); voidResetBitNumber(UInt_t bitnumber); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(UInt_t nbits, const Char_t* array); voidSet(UInt_t nbits, const UChar_t* array); voidSet(UInt_t nbits, const Short_t* array); voidSet(UInt_t nbits, const UShort_t* array); voidSet(UInt_t nbits, const Int_t* array); voidSet(UInt_t nbits, const UInt_t* array); voidSet(UInt_t nbits, const Long64_t* array); voidSet(UInt_t nbits, const ULong64_t* array); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBitNumber(UInt_t bitnumber, Bool_t value = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBits(UInt_t nbits = 8); TBits(const TBits&); Bool_tTObject::TestBit(UInt_t f) const; Bool_tTestBitNumber(UInt_t bitnumber) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:10871,Testability,Test,TestBitNumber,10871," Set(UInt_t nbits, const Short_t* array); Set all the bytes. void Set(UInt_t nbits, const Int_t* array); Set all the bytes. void Set(UInt_t nbits, const Long64_t* array); Set all the bytes. void Get(Short_t* array) const; Get all the bytes. void Get(Int_t* array) const; Get all the bytes. void Get(Long64_t* array) const; Get all the bytes. void Set(UInt_t nbits, const Short_t* array); make nbytes even so that the loop below is neat. void Set(UInt_t nbits, const Int_t* array); make nbytes a multiple of 4 so that the loop below is neat. void Set(UInt_t nbits, const Long64_t* array); make nbytes a multiple of 8 so that the loop below is neat. void Get(Short_t* array) const; Get all the bytes. void Get(Int_t* array) const; Get all the bytes. void Get(Long64_t* array) const; Get all the bytes. Bool_t operator==(const TBits& other) const; Compare object. void SetBitNumber(UInt_t bitnumber, Bool_t value = kTRUE); Set bit number 'bitnumber' to be value. Bool_t TestBitNumber(UInt_t bitnumber) const; Return the current value of the bit. void ResetBitNumber(UInt_t bitnumber). Bool_t operator[](UInt_t bitnumber) const. Bool_t operator~(); Flips the bit. TBits::TReference operator[](UInt_t bitnumber); ----- Accessors and operator. { return TReference(*this,bitnumber); }. TBits& operator&=(const TBits& rhs); { DoAndEqual(rhs); return *this; }. TBits& operator|=(const TBits& rhs); { DoOrEqual(rhs); return *this; }. TBits& operator^=(const TBits& rhs); { DoXorEqual(rhs); return *this; }. TBits& operator<<=(UInt_t rhs); { DoLeftShift(rhs); return *this; }. TBits& operator>>=(UInt_t rhs); { DoRightShift(rhs); return *this; }. TBits operator<<(UInt_t rhs); { return TBits(*this)<<= rhs; }. TBits operator>>(UInt_t rhs); { return TBits(*this)>>= rhs; }. void Set(UInt_t nbits, const Char_t* array); ----- Optimized setters; Each of these will replace the contents of the receiver with the bitvector; in the parameter array. The number of bits is changed to nbits. If nbits; is smaller than fNb",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:324,Usability,simpl,simple,324,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fi",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:8105,Usability,Clear,Clear,8105,"ct::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UChar_t*fAllBits[fNbytes] array of UChars; UInt_tfNbitsHighest bit set + 1; UInt_tfNbytesNumber of UChars in fAllBits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits(UInt_t nbits = 8); TBits constructor. All bits set to 0. TBits(const TBits& ); TBits copy constructor. TBits& operator=(const TBits& ); TBits assignment operator. ~TBits(); TBits destructor. void Clear(Option_t* option = """"); Clear the value. void Compact(); Reduce the storage used by the object to a minimun. UInt_t CountBits(UInt_t startBit = 0) const; Return number of bits set to 1 starting at bit startBit. void DoAndEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoOrEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoXorEqual(const TBits& rhs); Execute (*this) ^= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoFlip(); Execute ~(*this). void DoLeftShift(UInt_t shift); Execute the left shift operation. void DoRightShift(UInt_t shift); Execute the left shift operation. UInt_t FirstNullBit(UInt_t startBit = 0) const; Return position of first null bit (starting from position 0 and up). UInt_t LastNullBit(UInt_t startBit = 999999999) const; Return position of first null bit (starting from position 0 a",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits.html:8135,Usability,Clear,Clear,8135,"ct::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UChar_t*fAllBits[fNbytes] array of UChars; UInt_tfNbitsHighest bit set + 1; UInt_tfNbytesNumber of UChars in fAllBits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits(UInt_t nbits = 8); TBits constructor. All bits set to 0. TBits(const TBits& ); TBits copy constructor. TBits& operator=(const TBits& ); TBits assignment operator. ~TBits(); TBits destructor. void Clear(Option_t* option = """"); Clear the value. void Compact(); Reduce the storage used by the object to a minimun. UInt_t CountBits(UInt_t startBit = 0) const; Return number of bits set to 1 starting at bit startBit. void DoAndEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoOrEqual(const TBits& rhs); Execute (*this) &= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoXorEqual(const TBits& rhs); Execute (*this) ^= rhs;; Extra bits in rhs are ignored; Missing bits in rhs are assumed to be zero. void DoFlip(); Execute ~(*this). void DoLeftShift(UInt_t shift); Execute the left shift operation. void DoRightShift(UInt_t shift); Execute the left shift operation. UInt_t FirstNullBit(UInt_t startBit = 0) const; Return position of first null bit (starting from position 0 and up). UInt_t LastNullBit(UInt_t startBit = 999999999) const; Return position of first null bit (starting from position 0 a",MatchSource.WIKI,root/html604/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits.html
https://root.cern/root/html604/TBits__TReference.html:597,Energy Efficiency,reduce,reduce,597,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBits__TReference.html:541,Modifiability,extend,extended,541,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBits__TReference.html:1153,Modifiability,Inherit,Inheritance,1153,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBits__TReference.html:1166,Modifiability,Inherit,Inherited,1166,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBits__TReference.html:395,Testability,test,tested,395,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBits__TReference.html:438,Testability,Test,TestBitNumber,438,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBits__TReference.html:586,Testability,test,tested,586,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBits__TReference.html:344,Usability,simpl,simple,344,". TBits::TReference. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits::TReference. class TBits::TReference. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. ~TReference(); Bool_toperator bool() const; TBits::TReference&operator=(Bool_t val); TBits::TReference&operator=(const TBits::TReference& rhs); Bool_toperator~() const; TBits::TReferenceTReference(const TBits::TReference&); TBits::TReferenceTReference(TBits& bit, UInt_t pos). private:. TBits::TReferenceTReference(). Data Members; private:. TBits&fBits!; UInt_tfPos!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBits::TReference& operator=(Bool_t val); For b[i] = val. TBits::TReference& operator=(const TBits::TReference& rhs); For b[i] = b[__j]. Bool_t operator~() const; Flips the bit. TReference(). TReference(TBits& bit, UInt_t pos); { }. ~TReference(); { }. » Author: Philippe Canal 05/02/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBits__TReference.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBits__TReference.html
https://root.cern/root/html604/TBox.html:1503,Availability,Error,Error,1503," virtual~TBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangl",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:1632,Availability,error,error,1632,"dTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject:",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:1716,Availability,error,error,1716,"; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:10350,Integrability,depend,depending,10350,"to be drawn, specify option ""l"". TBox * DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this box with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a BOX/WBOX/PAD object is clicked. If the mouse is clicked in one of the 4 corners of the box (pA,pB,pC,pD); the box is resized with the rubber rectangle. If the mouse is clicked inside the box, the box is moved. If the mouse is clicked on the 4 edges (pL,pR,pTop,pBot), the box is; rescaled parallel to this edge (same as Motif window manager). pA pTop pB; +--------------------------------------------+; | |; | |; | |; pL| pINSIDE |pR; | |; | |; | |; | |; +--------------------------------------------+; pD pBot pC. Note that this function is duplicated on purpose by TPad::ExecuteEvent.; If somebody modifies this function, may be similar changes should also; be applied to TPad::ExecuteEvent. void HideToolTip(Int_t event); Hide tool tip depending on the event type. Typically tool tips; are hidden when event is not a kMouseEnter and not a kMouseMotion; event. Int_t IsInside(Double_t x, Double_t y) const; Function which returns 1 if point x,y lies inside the box, 0 otherwise. void ls(Option_t* option = """") const; List this box with its attributes. void Paint(Option_t* option = """"); Paint this box with its current attributes. void PaintBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t* option = """"); Draw this box with new coordinates. void Print(Option_t* option = """") const; Dump this box with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this box. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; text = 0. void Streamer(TBuffer& ); Stream an object of class TBox. Rectangle_t GetBBox(); ",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:3013,Modifiability,Inherit,InheritsFrom,3013,"ual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidHideToolTip(Int_t event); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBeingResized() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Int_tIsInside(Double_t x, Double_t y) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:3079,Modifiability,Inherit,InheritsFrom,3079,"() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidHideToolTip(Int_t event); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBeingResized() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Int_tIsInside(Double_t x, Double_t y) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, v",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:8390,Modifiability,Inherit,Inheritance,8390,"c TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Bool_tfResizing!True if box is being resized; Double_tfX1X of 1st point; Double_tfX2X of 2nd point; Double_tfY1Y of 1st point; Double_tfY2Y of 2nd point. private:. TObject*fTip!tool tip associated with box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBox(); Box default constructor. TBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Box standard constructor. ~TBox(); Box destructor. TBox(const TBox& box); Box copy constructor. TBox& operator=(const TBox& ); Assignment operator. void Copy(TObject& box) const; Copy a Box. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a box. Compute the closest distance of approach from point px,py to the; edges of this box.; The distance is computed in pixels units. In case of a filled box the distance returned is 0 if the point; (px,py) is inside the box, and is huge if the point is outside. void Draw(Option_t* option = """"); Draw this box with its current attributes.; if the box has no fill style (ie fill style=0), the box contour is drawn; if the box has a fill style, the box contour is not drawn by default.; to force the contour to be drawn, specify option ""l"". TBox * DrawBox(Double_t x1, Double_t y1, D",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:8403,Modifiability,Inherit,Inherited,8403,"c TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Bool_tfResizing!True if box is being resized; Double_tfX1X of 1st point; Double_tfX2X of 2nd point; Double_tfY1Y of 1st point; Double_tfY2Y of 2nd point. private:. TObject*fTip!tool tip associated with box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBox(); Box default constructor. TBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Box standard constructor. ~TBox(); Box destructor. TBox(const TBox& box); Box copy constructor. TBox& operator=(const TBox& ); Assignment operator. void Copy(TObject& box) const; Copy a Box. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a box. Compute the closest distance of approach from point px,py to the; edges of this box.; The distance is computed in pixels units. In case of a filled box the distance returned is 0 if the point; (px,py) is inside the box, and is huge if the point is outside. void Draw(Option_t* option = """"); Draw this box with its current attributes.; if the box has no fill style (ie fill style=0), the box contour is drawn; if the box has a fill style, the box contour is not drawn by default.; to force the contour to be drawn, specify option ""l"". TBox * DrawBox(Double_t x1, Double_t y1, D",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:2865,Security,Hash,Hash,2865,"l TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidHideToolTip(Int_t event); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBeingResized() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Int_tIsInside(Double_t x, Double_t y) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTOb",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:6661,Testability,Test,TestBit,6661,"idSavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetBBoxCenter(const TPoint& p); virtual voidSetBBoxCenterX(const Int_t x); virtual voidSetBBoxCenterY(const Int_t y); virtual voidSetBBoxX1(const Int_t x); virtual voidSetBBoxX2(const Int_t x); virtual voidSetBBoxY1(const Int_t y); virtual voidSetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetX1(Double_t x1); virtual voidSetX2(Double_t x2); virtual voidSetY1(Double_t y1); virtual voidSetY2(Double_t y2); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBox(); TBox(const TBox& box); TBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:6700,Testability,Test,TestBits,6700,"idSavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetBBoxCenter(const TPoint& p); virtual voidSetBBoxCenterX(const Int_t x); virtual voidSetBBoxCenterY(const Int_t y); virtual voidSetBBoxX1(const Int_t x); virtual voidSetBBoxX2(const Int_t x); virtual voidSetBBoxY1(const Int_t y); virtual voidSetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetX1(Double_t x1); virtual voidSetX2(Double_t x2); virtual voidSetY1(Double_t y1); virtual voidSetY2(Double_t y2); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBox(); TBox(const TBox& box); TBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBox.html:812,Usability,Clear,Clear,812," virtual~TBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangl",MatchSource.WIKI,root/html604/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBox.html
https://root.cern/root/html604/TBranch.html:1660,Availability,Error,Error,1660,"(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidAddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFlushBaskets(); Int_tFlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*GetBasket(Int_t basket); Int_t*GetBasketBytes() const; Long64_t*GetBasketEntry() const; virtual Long64_tGetBasketSeek(Int_t basket) const; virtual Int_tGetBasketSize() const; virtual TList*GetBrowsables(); virtual const char*GetClass",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:1789,Availability,error,error,1789," virtual voidAddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFlushBaskets(); Int_tFlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*GetBasket(Int_t basket); Int_t*GetBasketBytes() const; Long64_t*GetBasketEntry() const; virtual Long64_tGetBasketSeek(Int_t basket) const; virtual Int_tGetBasketSize() const; virtual TList*GetBrowsables(); virtual const char*GetClassName() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; TDirec",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:1873,Availability,error,error,1873,"on_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFlushBaskets(); Int_tFlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*GetBasket(Int_t basket); Int_t*GetBasketBytes() const; Long64_t*GetBasketEntry() const; virtual Long64_tGetBasketSeek(Int_t basket) const; virtual Int_tGetBasketSize() const; virtual TList*GetBrowsables(); virtual const char*GetClassName() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static L",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:17761,Availability,error,error,17761,"e associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option contains ""all"", drop all baskets including; read- and write-baskets (unless they are not stored individually on disk).; The option ""all"" also lead to DropBaskets being called on the sub-branches. void ExpandBasketArrays(); Increase BasketEntry buffer of a minimum of 10 locations; and a maximum of 50 per cent of current size. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. The function returns the number of bytes committed to the memory basket.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because e.g. the branch is disabled,; the number of bytes returned is 0. Int_t FillEntryBuffer(TBasket* basket, TBuffer* buf, Int_t& lnew); Copy the data from fEntryBuffer into the current basket. TBranch* FindBranch(const char* name); -- Find the immediate sub-branch with passed name. TLeaf* FindLeaf(const char* name); -- Find the leaf corresponding to the name 'searchname'. Int_t FlushBaskets(); Flush to disk all the baskets of this branch and any of subbranches.; Return the number of bytes written or -1 in case of write error. Int_t FlushOneBasket(UInt_t which); If we have a write basket in memory and it contains some entries and; has not yet been written to disk, we write it and delete it from memory.; Return the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:18365,Availability,error,error,18365,"baskets (unless they are not stored individually on disk).; The option ""all"" also lead to DropBaskets being called on the sub-branches. void ExpandBasketArrays(); Increase BasketEntry buffer of a minimum of 10 locations; and a maximum of 50 per cent of current size. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. The function returns the number of bytes committed to the memory basket.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because e.g. the branch is disabled,; the number of bytes returned is 0. Int_t FillEntryBuffer(TBasket* basket, TBuffer* buf, Int_t& lnew); Copy the data from fEntryBuffer into the current basket. TBranch* FindBranch(const char* name); -- Find the immediate sub-branch with passed name. TLeaf* FindLeaf(const char* name); -- Find the leaf corresponding to the name 'searchname'. Int_t FlushBaskets(); Flush to disk all the baskets of this branch and any of subbranches.; Return the number of bytes written or -1 in case of write error. Int_t FlushOneBasket(UInt_t which); If we have a write basket in memory and it contains some entries and; has not yet been written to disk, we write it and delete it from memory.; Return the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry""",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:19728,Availability,error,error,19728,"sket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TFile* GetFile(Int_t mode = 0); Return pointer to the file where branch buffers reside, returns 0; in case branch buffers reside in the same file as tree header.; If mode is 1 the branch buffer file is recreated. TBasket* GetFreshBasket(); Return a fresh basket by either resusing an existing basket that needs; to be drop (according to TTree::MemoryFull) or create a new one. TLeaf* GetLeaf(const char* name) const; Retur",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:20310,Availability,failure,failure,20310,"depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TFile* GetFile(Int_t mode = 0); Return pointer to the file where branch buffers reside, returns 0; in case branch buffers reside in the same file as tree header.; If mode is 1 the branch buffer file is recreated. TBasket* GetFreshBasket(); Return a fresh basket by either resusing an existing basket that needs; to be drop (according to TTree::MemoryFull) or create a new one. TLeaf* GetLeaf(const char* name) const; Return pointer to the 1st Leaf named name in thisBranch. TString GetRealFileName() const. Int_t GetRow(Int_t row); Return all elements of one row unpacked in internal array fValues; [Actually just returns 1 (?)]. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). TBranch* GetMother() const; Get our top-level parent branch in the tree. TB",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:7208,Deployability,update,updateSubBranches,7208,"etAttFill(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); static voidResetCount(); virtual voidResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBufferAddress(TBuffer* entryBuffer); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEntries(Long64_t entries); virtual voidSetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidSetFile(TFile* file = 0); virtual voidSetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset = 0); virtual voidSetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(T",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:24689,Deployability,update,updateSubBranches,24689,"ide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::Ge",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:24718,Deployability,Update,Update,24718,"ide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::Ge",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:24852,Deployability,update,updateExisting,24852,"ide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::Ge",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:24881,Deployability,update,update,24881,"ide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::Ge",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:25850,Deployability,update,update,25850,"pdate all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:26799,Deployability,update,update,26799,"To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& ); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file. void SetFirstEntry(Long64_t entry); set the first entry number (case of TBranchSTL). void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:27668,Deployability,Update,UpdateFile,27668,"led by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& ); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file. void SetFirstEntry(Long64_t entry); set the first entry number (case of TBranchSTL). void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. void SetSkipZip(Bool_t skip = kTRUE); { fSkipZip = skip; }. TBranch(const TBranch& ). TBranch& operator=(const TBranch& ). char * GetAddress() const; {return fAddress;}. Int_t * GetBasketBytes() const; {return fBasketBytes;}. Long64_t * GetBasketEntry() const; {return fBasketEntry;}. Int_t GetBasketSize() const; {return fBasketSize;}. TDirectory * GetDirectory() const; {return fDirectory;}. Int_t GetEntryOffsetLen() const; { return fEntryOffsetLen; }. Int_t GetEvent(Long64_t entry = 0); {return GetEntry(entry);}. const char * GetFileName() const; {return fFileName.Data();}. Int_t GetOffset() const; {return fOffset;}. Int_t GetReadBasket() const; {return fReadBasket;",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:27879,Deployability,update,update,27879,"l_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& ); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file. void SetFirstEntry(Long64_t entry); set the first entry number (case of TBranchSTL). void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. void SetSkipZip(Bool_t skip = kTRUE); { fSkipZip = skip; }. TBranch(const TBranch& ). TBranch& operator=(const TBranch& ). char * GetAddress() const; {return fAddress;}. Int_t * GetBasketBytes() const; {return fBasketBytes;}. Long64_t * GetBasketEntry() const; {return fBasketEntry;}. Int_t GetBasketSize() const; {return fBasketSize;}. TDirectory * GetDirectory() const; {return fDirectory;}. Int_t GetEntryOffsetLen() const; { return fEntryOffsetLen; }. Int_t GetEvent(Long64_t entry = 0); {return GetEntry(entry);}. const char * GetFileName() const; {return fFileName.Data();}. Int_t GetOffset() const; {return fOffset;}. Int_t GetReadBasket() const; {return fReadBasket;}. Long64_t GetReadEntry() const; {return fReadEntry;}. Int_t GetWriteBasket() const; {return fWriteBasket;}. Long64_t GetEntryNumber() const; {return fEntryNumber;}. Long64_t GetFirstEntry() const;",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:29459,Deployability,Update,UpdateAddress,29459,"ree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. void SetSkipZip(Bool_t skip = kTRUE); { fSkipZip = skip; }. TBranch(const TBranch& ). TBranch& operator=(const TBranch& ). char * GetAddress() const; {return fAddress;}. Int_t * GetBasketBytes() const; {return fBasketBytes;}. Long64_t * GetBasketEntry() const; {return fBasketEntry;}. Int_t GetBasketSize() const; {return fBasketSize;}. TDirectory * GetDirectory() const; {return fDirectory;}. Int_t GetEntryOffsetLen() const; { return fEntryOffsetLen; }. Int_t GetEvent(Long64_t entry = 0); {return GetEntry(entry);}. const char * GetFileName() const; {return fFileName.Data();}. Int_t GetOffset() const; {return fOffset;}. Int_t GetReadBasket() const; {return fReadBasket;}. Long64_t GetReadEntry() const; {return fReadEntry;}. Int_t GetWriteBasket() const; {return fWriteBasket;}. Long64_t GetEntryNumber() const; {return fEntryNumber;}. Long64_t GetFirstEntry() const; {return fFirstEntry; }. TObjArray * GetListOfBaskets(); {return &fBaskets;}. TObjArray * GetListOfBranches(); {return &fBranches;}. TObjArray * GetListOfLeaves(); {return &fLeaves;}. Int_t GetMaxBaskets() const; {return fMaxBaskets;}. Int_t GetNleaves() const; {return fNleaves;}. Int_t GetSplitLevel() const; {return fSplitLevel;}. Long64_t GetEntries() const; {return fEntries;}. TTree * GetTree() const; {return fTree;}. void ResetReadEntry(); {fReadEntry = -1;}. void SetOffset(Int_t offset = 0); {fOffset=offset;}. void SetTree(TTree* tree); { fTree = tree;}. void UpdateAddress(); {;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-18 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:16302,Integrability,rout,routine,16302,"ting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option c",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:16625,Integrability,interface,interface,16625," A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option contains ""all"", drop all baskets including; read- and write-baskets (unless they are not stored individually on disk).; The option ""all"" also lead to DropBaskets being called on the sub-branches. void ExpandBasketArrays(); Increase BasketEntry buffer of a minimum of 10 locations; and a maximum of 50 per cent of current size. Int_t Fi",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:19165,Integrability,depend,depending,19165,"me); -- Find the leaf corresponding to the name 'searchname'. Int_t FlushBaskets(); Flush to disk all the baskets of this branch and any of subbranches.; Return the number of bytes written or -1 in case of write error. Int_t FlushOneBasket(UInt_t which); If we have a write basket in memory and it contains some entries and; has not yet been written to disk, we write it and delete it from memory.; Return the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:4589,Modifiability,Inherit,InheritsFrom,4589,"ay*GetListOfLeaves(); virtual Bool_tGetMakeClass() const; Int_tGetMaxBaskets() const; TBranch*GetMother() const; virtual const char*TNamed::GetName() const; Int_tGetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tGetReadBasket() const; Long64_tGetReadEntry() const; virtual Int_tGetRow(Int_t row); Int_tGetSplitLevel() const; TBranch*GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotalSize(Option_t* option = """") const; Long64_tGetTotBytes(Option_t* option = """") const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetWriteBasket() const; Long64_tGetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidKeepCircular(Long64_t maxEntries); virtual Int_tLoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void*",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:4655,Modifiability,Inherit,InheritsFrom,4655,"MaxBaskets() const; TBranch*GetMother() const; virtual const char*TNamed::GetName() const; Int_tGetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tGetReadBasket() const; Long64_tGetReadEntry() const; virtual Int_tGetRow(Int_t row); Int_tGetSplitLevel() const; TBranch*GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotalSize(Option_t* option = """") const; Long64_tGetTotBytes(Option_t* option = """") const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetWriteBasket() const; Long64_tGetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidKeepCircular(Long64_t maxEntries); virtual Int_tLoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operato",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:10507,Modifiability,variab,variable,10507,"ect::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fAddress! Address of 1st leaf (variable or object); Int_t*fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tfBasketSizeInitial Size of Basket Buffer; TObjArrayfBaskets-> List of baskets of this branch; TObjArrayfBranches-> List of Branches of this branch; TList*fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tfCompressCompression level and algorithm; TBasket*fCurrentBasket! Pointer to the current basket.; TDirectory*fDirectory! Pointer to directory where this branch buffers are stored; Long64_tfEntriesNumber of entries; TBuffer*fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tfEntryNumberCurrent entry number (last one filled in this branch); Int_tfEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringfFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tfFillLeaves! Pointer to the FillLeaves implementation to use.; Style_tTAttFill::fFillStylefill area style; Long64_tfFirstBasketEntry! First entry in the current basket.; Long64_tfFirstEntryNumber of ",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:12934,Modifiability,Inherit,Inheritance,12934,"t_tfNBaskets! Number of baskets in memory; TStringTNamed::fNameobject identifier; Long64_tfNextBasketEntry! Next entry that will requires us to go to the next basket; Int_tfNleaves! Number of leaves; Int_tfOffsetOffset of this branch; TBranch*fParent! Pointer to parent branch.; Int_tfReadBasket! Current basket number when reading; Long64_tfReadEntry! Current entry number when reading; TBranch::ReadLeaves_tfReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tfSkipZip! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated ",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:12947,Modifiability,Inherit,Inherited,12947,"t_tfNBaskets! Number of baskets in memory; TStringTNamed::fNameobject identifier; Long64_tfNextBasketEntry! Next entry that will requires us to go to the next basket; Int_tfNleaves! Number of leaves; Int_tfOffsetOffset of this branch; TBranch*fParent! Pointer to parent branch.; Int_tfReadBasket! Current basket number when reading; Long64_tfReadEntry! Current entry number when reading; TBranch::ReadLeaves_tfReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tfSkipZip! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated ",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:13402,Modifiability,variab,variable,13402,"p! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:13466,Modifiability,variab,variable,13466,"p! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:13488,Modifiability,variab,variable,13488,"p! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:13537,Modifiability,variab,variable,13537,"itleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], w",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:13725,Modifiability,variab,variable,13725,"pBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; I",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:13777,Modifiability,variab,variable,13777,"pBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; I",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:13800,Modifiability,variab,variable,13800,"unter; static TBranch::EStatusBitskAutoDelete; static TBranch::EStatusBitskDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integers, then; it is us",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:14629,Modifiability,variab,variable,14629,"acter. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integers, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integers) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is ",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:19549,Performance,Load,LoadTree,19549,"n the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TFile* GetFile(Int_t mode = 0); Return pointer to the file where branch buffers reside, returns 0; in case branch buffers reside in the same file as tree header.; If mode is 1 the branch buffer file is recreated. TBasket* GetFreshBasket()",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:22042,Performance,Load,LoadBaskets,22042,"eClass mode). TBranch* GetMother() const; Get our top-level parent branch in the tree. TBranch* GetSubBranch(const TBranch* br) const; Find the parent branch of child.; Return 0 if child is not in this branch hierarchy. Long64_t GetTotalSize(Option_t* option = """") const; Return total number of bytes in the branch (including current buffer). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Read zero leaves without the overhead of a loop. void ReadLeaves1Impl(TBuffer& b); Read one leaf without the overhead of a loop. void ReadLeaves2Impl(TBuffer& b); Read two leaves without the overhead of a loop. void FillLeavesImpl(TBuffer",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:22503,Performance,Load,LoadBaskets,22503," current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Read zero leaves without the overhead of a loop. void ReadLeaves1Impl(TBuffer& b); Read one leaf without the overhead of a loop. void ReadLeaves2Impl(TBuffer& b); Read two leaves without the overhead of a loop. void FillLeavesImpl(TBuffer& b); Loop on all leaves of this branch to fill Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the ad",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:22518,Performance,load,load,22518," current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Read zero leaves without the overhead of a loop. void ReadLeaves1Impl(TBuffer& b); Read one leaf without the overhead of a loop. void ReadLeaves2Impl(TBuffer& b); Read two leaves without the overhead of a loop. void FillLeavesImpl(TBuffer& b); Loop on all leaves of this branch to fill Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the ad",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:24442,Safety,avoid,avoid,24442,"ergeInfo* ); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; b",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:4479,Security,Hash,Hash,4479,"irtual TLeaf*GetLeaf(const char* name) const; TObjArray*GetListOfBaskets(); TObjArray*GetListOfBranches(); TObjArray*GetListOfLeaves(); virtual Bool_tGetMakeClass() const; Int_tGetMaxBaskets() const; TBranch*GetMother() const; virtual const char*TNamed::GetName() const; Int_tGetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tGetReadBasket() const; Long64_tGetReadEntry() const; virtual Int_tGetRow(Int_t row); Int_tGetSplitLevel() const; TBranch*GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotalSize(Option_t* option = """") const; Long64_tGetTotBytes(Option_t* option = """") const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetWriteBasket() const; Long64_tGetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidKeepCircular(Long64_t maxEntries); virtual Int_tLoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delet",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:15667,Security,access,access,15667,"ize of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integers, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integers) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:22440,Security,access,access,22440,"er). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Read zero leaves without the overhead of a loop. void ReadLeaves1Impl(TBuffer& b); Read one leaf without the overhead of a loop. void ReadLeaves2Impl(TBuffer& b); Read two leaves without the overhead of a loop. void FillLeavesImpl(TBuffer& b); Loop on all leaves of this branch to fill Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Rese",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:25546,Security,access,access,25546,". void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access t",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:26495,Security,access,access,26495,"e can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& ); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file.",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:8642,Testability,Test,TestBit,8642,"ion = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEntries(Long64_t entries); virtual voidSetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidSetFile(TFile* file = 0); virtual voidSetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset = 0); virtual voidSetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranch(); TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:8681,Testability,Test,TestBits,8681,"ion = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEntries(Long64_t entries); virtual voidSetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidSetFile(TFile* file = 0); virtual voidSetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset = 0); virtual voidSetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranch(); TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranch.html:1019,Usability,Clear,Clear,1019," virtual~TBranch(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidAddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpandBasketArrays(); virtual voidTObject::F",MatchSource.WIKI,root/html604/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranch.html
https://root.cern/root/html604/TBranchClones.html:1454,Availability,Error,Error,1454,"t char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:1583,Availability,error,error,1583,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:1667,Availability,error,error,1667,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:7646,Deployability,update,updateSubBranches,7646,"anch::ResetCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& ",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:9305,Deployability,Update,UpdateAddress,9305,"t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchClones(); TBranchClones(const TBranchClones&); TBranchClones(TTree* tree, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:15616,Deployability,Update,UpdateFile,15616,"splitlevel = 1); -- Constructor. TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. void Init(TTree* tree, TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Initialization (non-virtual, to be called from constructor). ~TBranchClones(); -- Destructor. void Browse(TBrowser* b); -- Browse this branch. Int_t Fill(); -- Loop on all branches and fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches and return total number of bytes read. void Print(Option_t* option = """") const; -- Print branch parameters. void Reset(Option_t* option = """"); -- Reset branch. Existing buffers are deleted; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); -- Reset branch after a merge. Existing buffers are deleted; Entries, max and min are reset. void SetAddress(void* add); -- Set address of this branch. void SetBasketSize(Int_t buffsize); -- Reset basket size for all sub-branches. void Streamer(TBuffer& ); -- Serialize/Deserialize from a buffer. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. TBranchClones(). const char* GetClassName() const; { return fClassName; }. Int_t GetN() const; {return fN;}. TClonesArray * GetList() const; {return fList;}. Bool_t IsFolder() const; {return kTRUE;}. void SetTree(TTree* tree); { fTree = tree; fBranchCount->SetTree(tree); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:15827,Deployability,update,update,15827,"splitlevel = 1); -- Constructor. TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. void Init(TTree* tree, TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Initialization (non-virtual, to be called from constructor). ~TBranchClones(); -- Destructor. void Browse(TBrowser* b); -- Browse this branch. Int_t Fill(); -- Loop on all branches and fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches and return total number of bytes read. void Print(Option_t* option = """") const; -- Print branch parameters. void Reset(Option_t* option = """"); -- Reset branch. Existing buffers are deleted; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); -- Reset branch after a merge. Existing buffers are deleted; Entries, max and min are reset. void SetAddress(void* add); -- Set address of this branch. void SetBasketSize(Int_t buffsize); -- Reset basket size for all sub-branches. void Streamer(TBuffer& ); -- Serialize/Deserialize from a buffer. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. TBranchClones(). const char* GetClassName() const; { return fClassName; }. Int_t GetN() const; {return fN;}. TClonesArray * GetList() const; {return fList;}. Bool_t IsFolder() const; {return kTRUE;}. void SetTree(TTree* tree); { fTree = tree; fBranchCount->SetTree(tree); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:4845,Modifiability,Inherit,InheritsFrom,4845,"nst; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operato",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:4911,Modifiability,Inherit,InheritsFrom,4911,"Nleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:11129,Modifiability,variab,variable,11129,"nnotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TBranch*fBranchCountBranch with clones count; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); TStringfClassNamename of the class of the objets in the ClonesArray; Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLe",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:14189,Modifiability,Inherit,Inheritance,14189,"aves! Number of leaves; Int_tTBranch::fOffsetOffset of this branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tfRead!flag = 1 if clonesarray has been read; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchClones(); -- Default and i/o constructor. TBranchClones(TTree* tree, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. void Init(TTree* tree, TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Initialization (non-virtual, to be called from constructor). ~TBranchClones(); -- Destructor. void Browse(TBrowser* b); -- Browse this branch. Int_t Fill(); -- Loop on all branches and fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches and return total number of bytes read. void Print(Option_t* option = """") const; -- Print branch parameters. void Reset(Option_t* option = """"); -- Reset branch. Exi",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:14202,Modifiability,Inherit,Inherited,14202,"aves! Number of leaves; Int_tTBranch::fOffsetOffset of this branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tfRead!flag = 1 if clonesarray has been read; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchClones(); -- Default and i/o constructor. TBranchClones(TTree* tree, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. void Init(TTree* tree, TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Initialization (non-virtual, to be called from constructor). ~TBranchClones(); -- Destructor. void Browse(TBrowser* b); -- Browse this branch. Int_t Fill(); -- Loop on all branches and fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches and return total number of bytes read. void Print(Option_t* option = """") const; -- Print branch parameters. void Reset(Option_t* option = """"); -- Reset branch. Exi",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:5414,Performance,Load,LoadBaskets,5414,") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchClones&operator=(const TBranchClones&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* ",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:4735,Security,Hash,Hash,4735,"MakeClass() const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual Int_tGetN() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:9219,Testability,Test,TestBit,9219,"t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchClones(); TBranchClones(const TBranchClones&); TBranchClones(TTree* tree, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:9258,Testability,Test,TestBits,9258,"t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchClones(); TBranchClones(const TBranchClones&); TBranchClones(TTree* tree, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchClones.html:795,Usability,Clear,Clear,795," virtual~TBranchClones(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch:",MatchSource.WIKI,root/html604/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchClones.html
https://root.cern/root/html604/TBranchElement.html:1447,Availability,Error,Error,1447,"t char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasket",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:1576,Availability,error,error,1576,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; TBranchElement*GetBranchCount() const; TBranchElement*GetBranchCount2() const; Int_t*GetBranchOffset() const; virtu",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:1660,Availability,error,error,1660,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; TBranchElement*GetBranchCount() const; TBranchElement*GetBranchCount2() const; Int_t*GetBranchOffset() const; virtual TList*TBranch::GetBrowsables(); UInt_tGetCheckSum(); virtual TClass*GetClass() co",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:23786,Availability,error,error,23786,"= 32000, Int_t splitlevel = 0, Int_t compress = -1); -- Constructor when the branch object is an STL collection. If splitlevel > 0 this branch in turn is split into sub branches. void Init(TTree* tree, TBranch* parent, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); -- Init when the branch object is an STL collection. If splitlevel > 0 this branch in turn is split into sub branches. ~TBranchElement(); -- Destructor. TStreamerInfo* GetInfoImp() const; -- Get streamer info for the branch class. TStreamerInfo* GetInfo() const; -- Get streamer info for the branch class. void Browse(TBrowser* b); -- Browse the branch content. void BuildTitle(const char* name); -- Set branch and leaf name and title in the case of a container sub-branch. Int_t Fill(); -- Loop on all leaves of this branch to fill the basket buffer. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of; bytes returned is -1. If no data are written, because, e.g.,; the branch is disabled, the number of bytes returned is 0. Note: We not not use any member functions from TLeafElement!. void FillLeavesMakeClass(TBuffer& b); -- Write leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void FillLeavesCollection(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void FillLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void FillLeavesCollectionSplitPtrMember(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void FillLeavesCollectionMember(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void FillLeavesAssociativeCollection",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:27258,Availability,error,error,27258," Get the branch address. If we are *not* owned by a MakeClass() tree:. If we are a top-level branch, return a pointer; to the pointer to our object. If we are *not* a top-level branch, return a pointer; to our object. If we are owned by a MakeClass() tree:. Return a pointer to our object. void InitInfo(); -- Init the streamer info for the branch class, try to compensate for class code unload/reload and schema evolution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. void* GetValuePointer() const; -- Returns pointer to first data element of this branch.;",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:27628,Availability,failure,failure,27628,". If we are owned by a MakeClass() tree:. Return a pointer to our object. void InitInfo(); -- Init the streamer info for the branch class, try to compensate for class code unload/reload and schema evolution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. void* GetValuePointer() const; -- Returns pointer to first data element of this branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a container sub-branch. Note: The offsets ar",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:8630,Deployability,update,updateSubBranches,8630,"::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBranchFolder(); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); virtual voidSetClassName(const char* name); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset); voidSetParentClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:11009,Deployability,Update,UpdateAddress,11009,"ntClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(Int_t btype); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchElement(); TBranchElement(TTree* tree, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:31795,Deployability,Release,ReleaseObject,31795," within a TClonesArray (fType == 31). void ReadLeavesMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObje",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32231,Deployability,Release,Release,32231,"ch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:38479,Deployability,Update,UpdateFile,38479," splitting. Note: The above rules imply that the branch heirarchy increases; in depth only for base classes of cl (unless we are inside; of a TClonesArray or STL container, in which case the depth; does *not* increase, the base class is elided) and for; TClonesArray or STL container data members (which have one; additional level of sub-branches). The only other way the; depth increases is when the top-level branch has a split; class data member, in that case the constructor will create; a sub-branch for it. In other words, the interior nodes of; the branch tree are all either: base class nodes; split; class nodes which are direct sub-branches of top-level nodes; (created by TClass::Bronch usually); or TClonesArray or STL; container master nodes. Note: The exception to the above is for the top-level branches,; Tree::Bronch creates nodes for everything in that case,; except for a TObject base class of a class which has the; can ignore tobject streamer flag set. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. co",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:38690,Deployability,update,update,38690,"oes *not* increase, the base class is elided) and for; TClonesArray or STL container data members (which have one; additional level of sub-branches). The only other way the; depth increases is when the top-level branch has a split; class data member, in that case the constructor will create; a sub-branch for it. In other words, the interior nodes of; the branch tree are all either: base class nodes; split; class nodes which are direct sub-branches of top-level nodes; (created by TClass::Bronch usually); or TClonesArray or STL; container master nodes. Note: The exception to the above is for the top-level branches,; Tree::Bronch creates nodes for everything in that case,; except for a TObject base class of a class which has the; can ignore tobject streamer flag set. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStrea",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:31845,Energy Efficiency,allocate,allocated,31845," within a TClonesArray (fType == 31). void ReadLeavesMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObje",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32184,Energy Efficiency,allocate,allocated,32184,"s into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->S",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32256,Energy Efficiency,allocate,allocated,32256,"ch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32361,Energy Efficiency,allocate,allocated,32361,"counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32588,Energy Efficiency,allocate,allocate,32588,"/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32660,Energy Efficiency,allocate,allocated,32660,"/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32934,Energy Efficiency,allocate,allocate,32934,"xisting i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1-",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:33003,Energy Efficiency,allocate,allocated,33003,"xisting i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1-",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:33042,Energy Efficiency,allocate,allocated,33042,"erge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 =",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:33318,Energy Efficiency,allocate,allocated,33318," added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branc",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:33754,Energy Efficiency,allocate,allocated,33754,"branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate""",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:34115,Energy Efficiency,allocate,allocated,34115,"eeded. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted a",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:34661,Energy Efficiency,allocate,allocated,34661," as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set ",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:16364,Integrability,interface,interface,16364,"cted:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Version_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TClassReffCurrentClass! Reference to current (transient) class definition; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); TStreamerInfoActions::TActionSequence*fFillActionSequence! Set of actions to be executed ",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:27690,Integrability,depend,depending,27690,"volution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. void* GetValuePointer() const; -- Returns pointer to first data element of this branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a container sub-branch. Note: The offsets are zero for data members so that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the add",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:32286,Integrability,interface,interface,32286,"counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:33682,Integrability,rout,routines,33682,"the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An exam",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:5685,Modifiability,Inherit,InheritsFrom,5685,"TBranch* br) const; virtual TClass*GetTargetClass(); virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; Int_tGetType() const; doubleGetTypedValue<double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; long doubleGetTypedValue<long double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; Long64_tGetTypedValue<long long>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidT",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:5751,Modifiability,Inherit,InheritsFrom,5751," char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; Int_tGetType() const; doubleGetTypedValue<double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; long doubleGetTypedValue<long double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; Long64_tGetTypedValue<long long>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:15220,Modifiability,variab,variable,15220,p; static TObject::EStatusBitsTObject::kIsReferenced; static TBranchElement::EBranchElementTypekLeafNode; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TBranchElement::EBranchElementTypekObjectNode; static TObject::(anonymous)TObject::kOverwrite; static TBranchElement::EBranchElementTypekSTLMemberNode; static TBranchElement::EBranchElementTypekSTLNode; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Version_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.;,MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:18089,Modifiability,variab,variable,18089, in same file as Tree header); TStreamerInfoActions::TActionSequence*fFillActionSequence! Set of actions to be executed to write the data to the basket.; Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFirstBasketEntry! First entry in the current basket.; Long64_tTBranch::fFirstEntryNumber of the first entry in this branch; Int_tfIDelement serial number in fInfo; vector<Int_t>fIDs! List of the serial number of all the StreamerInfo to be used.; TStreamerInfo*fInfo! Pointer to StreamerInfo; Bool_tfInit! Initialization flag for branch assignment; Bool_tfInitOffsets! Initialization flag to not endlessly recalculate offsets; TVirtualCollectionIterators*fIterators! holds the iterators when the branch is of fType==4.; TObjArrayTBranch::fLeaves-> List of leaves of this branch; Int_tTBranch::fMaxBasketsMaximum number of Baskets so far; Int_tfMaximumMaximum entries for a TClonesArray or variable array; TBranch*TBranch::fMother! Pointer to top-level parent branch in the tree.; Int_tTBranch::fNBaskets! Number of baskets in memory; TStringTNamed::fNameobject identifier; Int_tfNdata! Number of data in this branch; Long64_tTBranch::fNextBasketEntry! Next entry that will requires us to go to the next basket; Int_tTBranch::fNleaves! Number of leaves; char*fObject! Pointer to object at *fAddress; Int_tTBranch::fOffsetOffset of this branch; TVirtualArray*fOnfileObject! Place holder for the onfile representation of data members.; TBranch*TBranch::fParent! Pointer to parent branch.; TClassReffParentClass! Reference to class definition in fParentName; TStringfParentNameName of parent class; TVirtualCollectionPtrIterators*fPtrIterators! holds the iterators when the branch is of fType==4 and it is a split collection of pointers.; TStreamerInfoActions::TActionSequence*fReadActionSequence! Set of actions to be executed to extract the data from,MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:20504,Modifiability,Inherit,Inheritance,20504,"emory class; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tfTypebranch type; Int_tTBranch::fWriteBasketLast basket number written; TVirtualCollectionIterators*fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranchElement::(anonymous)kAddressSet; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranchElement::(anonymous)kBranchFolder; static TBranchElement::(anonymous)kCache; static TBranchElement::(anonymous)kDecomposedObj; static TBranchElement::(anonymous)kDeleteObject; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchElement::(anonymous)kMakeClass; static TBranchElement::(anonymous)kOwnOnfileObj. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SwitchContainer(TObjArray* ); -- Modify the container type of the branches. TBranchElement(); -- Default and I/O constructor. TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. void Init(TTree* tree, TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Init when the branch objec",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:20517,Modifiability,Inherit,Inherited,20517,"emory class; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tfTypebranch type; Int_tTBranch::fWriteBasketLast basket number written; TVirtualCollectionIterators*fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranchElement::(anonymous)kAddressSet; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranchElement::(anonymous)kBranchFolder; static TBranchElement::(anonymous)kCache; static TBranchElement::(anonymous)kDecomposedObj; static TBranchElement::(anonymous)kDeleteObject; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchElement::(anonymous)kMakeClass; static TBranchElement::(anonymous)kOwnOnfileObj. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SwitchContainer(TObjArray* ); -- Modify the container type of the branches. TBranchElement(); -- Default and I/O constructor. TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. void Init(TTree* tree, TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Init when the branch objec",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:6321,Performance,Load,LoadBaskets,6321,"_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; voidPrintValue(Int_t i) const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voidReset(Opt",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:36348,Performance,load,loaded,36348,"anch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to which the data member represented by this; branch belongs) inside its containing object (if any). void SetReadActionSequence(); Set the sequence of actions needed to read the data out of the buffer. void SetReadLeavesPtr(); Set the ReadLeaves pointer to execute the expected operations. void SetFillActionSequence(); Set the sequence of actions needed to write the data out from the buffer. void SetFillLeavesPtr(); Set the FillLeaves pointer to execute the expected operations. void SetTargetClass(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void SetupAddressesImpl(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& ); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *n",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:29239,Safety,Detect,Detect,29239,"his branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a container sub-branch. Note: The offsets are zero for data members so that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member withi",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:29517,Safety,detect,detect,29517,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionMember(TBuffer& b); -- Read lea",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:5575,Security,Hash,Hash,5575,"nt_t row); Int_tTBranch::GetSplitLevel() const; Int_tGetStreamerType() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual TClass*GetTargetClass(); virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; Int_tGetType() const; doubleGetTypedValue<double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; long doubleGetTypedValue<long double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; Long64_tGetTypedValue<long long>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removed",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:38759,Security,Validat,ValidateAddress,38759,"have one; additional level of sub-branches). The only other way the; depth increases is when the top-level branch has a split; class data member, in that case the constructor will create; a sub-branch for it. In other words, the interior nodes of; the branch tree are all either: base class nodes; split; class nodes which are direct sub-branches of top-level nodes; (created by TClass::Bronch usually); or TClonesArray or STL; container master nodes. Note: The exception to the above is for the top-level branches,; Tree::Bronch creates nodes for everything in that case,; except for a TObject base class of a class which has the; can ignore tobject streamer flag set. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStreamerType; }. TClass * GetTargetClass(); { return fTargetClass; }. Double_t GetValue(Int_t i, Int_t len, Bo",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:10923,Testability,Test,TestBit,10923,"ntClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(Int_t btype); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchElement(); TBranchElement(TTree* tree, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:10962,Testability,Test,TestBits,10962,"ntClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(Int_t btype); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchElement(); TBranchElement(TTree* tree, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:34238,Testability,test,test,34238,"ent = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSiz",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:34777,Testability,test,test,34777,"ocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to whi",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:39978,Testability,Test,TestBit,39978,"nless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStreamerType; }. TClass * GetTargetClass(); { return fTargetClass; }. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; { return GetTypedValue<Double_t>(i, len, subarr); }. Int_t GetClassVersion(); { return fClassVersion; }. Bool_t IsBranchFolder() const; { return TestBit(kBranchFolder); }. Bool_t IsObjectOwner() const; { return TestBit(kDeleteObject); }. Bool_t Notify(). void SetBranchFolder(); { SetBit(kBranchFolder); }. void SetClassName(const char* name); { fClassName = name; }. void SetParentName(const char* name); { fParentName = name; }. void SetType(Int_t btype); { fType = btype; }. » Author: Rene Brun 14/01/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:40044,Testability,Test,TestBit,40044,"nless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStreamerType; }. TClass * GetTargetClass(); { return fTargetClass; }. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; { return GetTypedValue<Double_t>(i, len, subarr); }. Int_t GetClassVersion(); { return fClassVersion; }. Bool_t IsBranchFolder() const; { return TestBit(kBranchFolder); }. Bool_t IsObjectOwner() const; { return TestBit(kDeleteObject); }. Bool_t Notify(). void SetBranchFolder(); { SetBit(kBranchFolder); }. void SetClassName(const char* name); { fClassName = name; }. void SetParentName(const char* name); { fParentName = name; }. void SetType(Int_t btype); { fType = btype; }. » Author: Rene Brun 14/01/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchElement.html:788,Usability,Clear,Clear,788," virtual~TBranchElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* nam",MatchSource.WIKI,root/html604/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchElement.html
https://root.cern/root/html604/TBranchObject.html:1442,Availability,Error,Error,1442,"t char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:1571,Availability,error,error,1571,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:1655,Availability,error,error,1655,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:15379,Availability,error,error,15379,"reate a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() const; Return TRUE if more than one leaf or if fBrowsables, FALSE otherwise. void Print(Option_t* option = """") const; Print TBranch parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new ",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:15715,Availability,failure,failure,15715,"ool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() const; Return TRUE if more than one leaf or if fBrowsables, FALSE otherwise. void Print(Option_t* option = """") const; Print TBranch parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer call",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:7600,Deployability,update,updateSubBranches,7600,"oidTBranch::ResetCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& ",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:9370,Deployability,Update,UpdateFile,9370,"ual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchObject(); TBranchObject(const TBranchObject&); TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:17594,Deployability,Update,UpdateAddress,17594," SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:17611,Deployability,Update,Update,17611," SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:16974,Energy Efficiency,efficient,efficient,16974,"re reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automat",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:14798,Integrability,rout,routine,14798,"nt_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchObject::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() co",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:4805,Modifiability,Inherit,InheritsFrom,4805,"e() const; Int_tTBranch::GetNleaves() const; virtual const char*GetObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operato",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:4871,Modifiability,Inherit,InheritsFrom,4871,"tObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:11181,Modifiability,variab,variable,11181,"TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); TStringfClassNameClass name of referenced object; Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Sty",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:14082,Modifiability,Inherit,Inheritance,14082,"anch::fOffsetOffset of this branch; TObject*fOldObject!Pointer to old object; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchObject::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all b",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:14095,Modifiability,Inherit,Inherited,14095,"anch::fOffsetOffset of this branch; TObject*fOldObject!Pointer to old object; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchObject::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all b",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:5374,Performance,Load,LoadBaskets,5374,") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchObject&operator=(const TBranchObject&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* ",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:4695,Security,Hash,Hash,4695," const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual const char*GetObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:9255,Testability,Test,TestBit,9255,"ual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchObject(); TBranchObject(const TBranchObject&); TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:9294,Testability,Test,TestBits,9294,"ual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchObject(); TBranchObject(const TBranchObject&); TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchObject.html:783,Usability,Clear,Clear,783," virtual~TBranchObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(co",MatchSource.WIKI,root/html604/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchObject.html
https://root.cern/root/html604/TBranchRef.html:2201,Availability,Error,Error,2201," char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:2330,Availability,error,error,2330,"tBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() const",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:2414,Availability,error,error,2414," virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel()",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:8397,Deployability,update,updateSubBranches,8397,"; virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTBranch::SetAddress(void* add); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voi",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:9912,Deployability,Update,UpdateAddress,9912,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:9950,Deployability,Update,UpdateFile,9950,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:5584,Modifiability,Inherit,InheritsFrom,5584,":GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; TRefTable*GetRefTable() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operato",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:5650,Modifiability,Inherit,InheritsFrom,5650,"Object::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; TRefTable*GetRefTable() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:11654,Modifiability,variab,variable,11654,"ject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Style_tTAttFill::fFillStylef",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:14553,Modifiability,Inherit,Inheritance,14553,"nch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:14566,Modifiability,Inherit,Inherited,14566,"nch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:362,Performance,load,loads,362,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() ",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:516,Performance,load,load,516,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() ",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:993,Performance,load,loading,993,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() ",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:6162,Performance,Load,LoadBaskets,6162,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchRef&operator=(const TBranchRef&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voi",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:5474,Security,Hash,Hash,5474,"Class() const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; TRefTable*GetRefTable() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:9826,Testability,Test,TestBit,9826,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:9865,Testability,Test,TestBits,9865,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:14775,Usability,Clear,Clear,14775,"e ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when r",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:14805,Usability,Clear,Clear,14805,"e ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when r",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:15481,Usability,clear,cleared,15481,"anch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TBranchRef(). TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchRef.html:15619,Usability,clear,cleared,15619,"anch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TBranchRef(). TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchRef.html
https://root.cern/root/html604/TBranchSTL.html:1516,Availability,Error,Error,1516,"t char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:1645,Availability,error,error,1645,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:1729,Availability,error,error,1729,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:15455,Availability,failure,failure,15455,"lectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TStreamerInfo* GetInfo() const. Check if we don't have the streamer info. Bool_t IsFolder() const; branch declared folder if at least one entry. void Print(Option_t* ) const; Print the branch parameters. void ReadLeavesImpl(TBuffer& b); TO BE DOCUMENTED. void FillLeavesImpl(TBuffer& b); TO BE DOCUMENTED. void SetAddress(void* addr). We are the top level branch. TBranchSTL(). const char * GetClassName() const; { return fClassName.Data(); }. » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:7691,Deployability,update,updateSubBranches,7691,"tCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addr); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberIn",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:9335,Deployability,Update,UpdateAddress,9335," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:9373,Deployability,Update,UpdateFile,9373," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:4880,Modifiability,Inherit,InheritsFrom,4880,"nst; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operato",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:4946,Modifiability,Inherit,InheritsFrom,4946,"Nleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:11087,Modifiability,variab,variable,11087,"ject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Style_tTAttFill::fFillStylef",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:14487,Modifiability,Inherit,Inheritance,14487,"ree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. TBranchSTL::BranchMap_tfBranchMap! Branch map; vector<TBranchSTL::ElementBranchHelper_t>fBranchVector! Branch vector; UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TStreamerInfo* GetInfo() const. Check if we don't",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:14500,Modifiability,Inherit,Inherited,14500,"ree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. TBranchSTL::BranchMap_tfBranchMap! Branch map; vector<TBranchSTL::ElementBranchHelper_t>fBranchVector! Branch vector; UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TStreamerInfo* GetInfo() const. Check if we don't",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:365,Performance,queue,queues,365,". TBranchSTL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchSTL. class TBranchSTL: public TBranch. TBranchSTL. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode. Function Members (Methods); public:. virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:5449,Performance,Load,LoadBaskets,5449,") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchSTL&operator=(const TBranchSTL&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t*) const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voidTB",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:4770,Security,Hash,Hash,4770," virtual Bool_tTBranch::GetMakeClass() const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:13993,Security,checksum,checksum,13993,"ber when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. TBranchSTL::BranchMap_tfBranchMap! Branch map; vector<TBranchSTL::ElementBranchHelper_t>fBranchVector! Branch vector; UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:9249,Testability,Test,TestBit,9249," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:9288,Testability,Test,TestBits,9288," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBranchSTL.html:857,Usability,Clear,Clear,857," virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch",MatchSource.WIKI,root/html604/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBranchSTL.html
https://root.cern/root/html604/TBRIK.html:1504,Availability,Error,Error,1504," virtual~TBRIK(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObjec",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:1633,Availability,error,error,1633,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_t",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:1717,Availability,error,error,1717,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) c",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:3119,Modifiability,Inherit,InheritsFrom,3119,"ect::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); ",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:3185,Modifiability,Inherit,InheritsFrom,3185,"loat_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator ne",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:8551,Modifiability,Inherit,Inheritance,8551,"TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfDxhalf length in x; Float_tfDyhalf length in y; Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBRIK(); BRIK shape default constructor. TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); BRIK shape normal constructor. ~TBRIK(); BRIK shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a BRIK. Compute the closest distance of approach from point px,py to each corner; point of the BRIK. void SetPoints(Double_t* points) const; Create BRIK points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3D. TBRIK(). Float_t GetDx() const; {return fDx;}. Float_t GetDy() const; {return fDy;}. Float_t GetDz() const; {return fDz;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. F",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:8564,Modifiability,Inherit,Inherited,8564,"TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfDxhalf length in x; Float_tfDyhalf length in y; Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBRIK(); BRIK shape default constructor. TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); BRIK shape normal constructor. ~TBRIK(); BRIK shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a BRIK. Compute the closest distance of approach from point px,py to each corner; point of the BRIK. void SetPoints(Double_t* points) const; Create BRIK points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3D. TBRIK(). Float_t GetDx() const; {return fDx;}. Float_t GetDy() const; {return fDy;}. Float_t GetDz() const; {return fDz;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. F",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:3009,Security,Hash,Hash,3009,"ect(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delet",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:6480,Testability,Test,TestBit,6480,"nt_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBRIK(); TBRIK(const TBRIK&); TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:6519,Testability,Test,TestBits,6519,"nt_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBRIK(); TBRIK(const TBRIK&); TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBRIK.html:863,Usability,Clear,Clear,863," virtual~TBRIK(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObjec",MatchSource.WIKI,root/html604/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBRIK.html
https://root.cern/root/html604/TBrowser.html:1872,Availability,Error,Error,1872," obj, TClass* cl, const char* name = 0, Int_t check = -1); voidAddCheckBox(TObject* obj, Bool_t check = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBrowseObject(TObject* obj); voidCheckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; st",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:2119,Availability,error,error,2119,"heckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTOb",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:2203,Availability,error,error,2203,"const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify()",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:9024,Integrability,depend,depending,9024,"Browser::(anonymous)kNoHidden; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """,MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:3304,Modifiability,Inherit,InheritsFrom,3304,", Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:3370,Modifiability,Inherit,InheritsFrom,3370,"char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); vi",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:8681,Modifiability,Inherit,Inheritance,8681,"Object::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBrowser::(anonymous)kNoHidden; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObjec",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:8694,Modifiability,Inherit,Inherited,8694,"Object::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBrowser::(anonymous)kNoHidden; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObjec",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:3179,Security,Hash,Hash,3179,"Array* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz);",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:6938,Testability,Test,TestBit,6938,"dTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; voidStartEmbedding(Int_t pos, Int_t subpos); voidStopEmbedding(const char* name = """"); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname = """", const char* title = ""ROOT Foreign Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:6977,Testability,Test,TestBits,6977,"dTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; voidStartEmbedding(Int_t pos, Int_t subpos); voidStopEmbedding(const char* name = """"); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname = """", const char* title = ""ROOT Foreign Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowser.html:1265,Usability,Clear,Clear,1265," virtual~TBrowser(); voidTObject::AbstractMethod(const char* method) const; voidAdd(TObject* obj, const char* name = 0, Int_t check = -1); voidAdd(void* obj, TClass* cl, const char* name = 0, Int_t check = -1); voidAddCheckBox(TObject* obj, Bool_t check = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBrowseObject(TObject* obj); voidCheckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cm",MatchSource.WIKI,root/html604/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowser.html
https://root.cern/root/html604/TBrowserImp.html:345,Integrability,protocol,protocol,345,". TBrowserImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBrowserImp. class TBrowserImp. TBrowserImp. ABC describing GUI independent browser implementation protocol. Function Members (Methods); public:. virtual~TBrowserImp(); virtual voidAdd(TObject*, const char*, Int_t); virtual voidAddCheckBox(TObject*, Bool_t = kFALSE); virtual voidBrowseObj(TObject*); TBrowser*Browser() const; virtual voidCheckObjectItem(TObject*, Bool_t = kFALSE); static TClass*Class(); virtual voidCloseTabs(); virtual Long_tExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidExecuteDefaultAction(TObject*); virtual TBrowser*GetBrowser() const; virtual Option_t*GetDrawOption() const; virtual TGMainFrame*GetMainFrame() const; virtual voidIconify(); virtual TClass*IsA() const; virtual voidRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"). protected:. TBrowserImp&operator=(const TBrowserImp& br); TBrowserImp(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Lib",MatchSource.WIKI,root/html604/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserImp.html
https://root.cern/root/html604/TBrowserImp.html:1956,Modifiability,Inherit,Inheritance,1956,"dRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"). protected:. TBrowserImp&operator=(const TBrowserImp& br); TBrowserImp(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDrawOption(Option_t* option = """"); {}. inline TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); { }. inline TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); { }. TBrowserImp(const TBrowserImp& br); { }. TBrowserImp& operator=(const TBrowserImp& br). TBrowserImp(TBrowser* b = 0); { }. virtual ~TBrowserImp(); { }. void Add(TObject* , const char* , Int_t ); { }. void AddCheckBox(TObject* , Bool_t = kFALSE); { }. void CheckObjectItem(TObject* , Bool_t = kFALSE); { }. void RemoveCheckBox(TObject* ); { }. void BrowseObj(TObject* ); { }. void CloseTabs(); { }. void ExecuteDefaultAction(TObject* ); { }. void Iconify(); { }. void RecursiveRemove(TObject* ); { }. void Refresh(Bool_t = kFALSE); { }. void Show(); { }. Option_t * GetDrawOption() const; { return 0; }. Long_t ExecPlugin(const char* , const char* , const char* , Int_t , I",MatchSource.WIKI,root/html604/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserImp.html
https://root.cern/root/html604/TBrowserImp.html:1969,Modifiability,Inherit,Inherited,1969,"dRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"). protected:. TBrowserImp&operator=(const TBrowserImp& br); TBrowserImp(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDrawOption(Option_t* option = """"); {}. inline TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); { }. inline TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); { }. TBrowserImp(const TBrowserImp& br); { }. TBrowserImp& operator=(const TBrowserImp& br). TBrowserImp(TBrowser* b = 0); { }. virtual ~TBrowserImp(); { }. void Add(TObject* , const char* , Int_t ); { }. void AddCheckBox(TObject* , Bool_t = kFALSE); { }. void CheckObjectItem(TObject* , Bool_t = kFALSE); { }. void RemoveCheckBox(TObject* ); { }. void BrowseObj(TObject* ); { }. void CloseTabs(); { }. void ExecuteDefaultAction(TObject* ); { }. void Iconify(); { }. void RecursiveRemove(TObject* ); { }. void Refresh(Bool_t = kFALSE); { }. void Show(); { }. Option_t * GetDrawOption() const; { return 0; }. Long_t ExecPlugin(const char* , const char* , const char* , Int_t , I",MatchSource.WIKI,root/html604/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserImp.html
https://root.cern/root/html604/TBrowserPlugin.html:1487,Availability,avail,available,1487,"= 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual void",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:2455,Availability,Error,Error,2455," virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:2584,Availability,error,error,2584," virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:2668,Availability,error,error,2668,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:584,Modifiability,plugin,plugins,584,". TBrowserPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TBrowserPlugin. class TBrowserPlugin: public TNamed. TRootBrowser. This class creates a ROOT object browser, constitued by three main; tabs. All tabs can 'swallow' frames, thanks to the new method:; ExecPlugin(const char *name = 0, const char *fname = 0,; const char *cmd = 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:684,Modifiability,plugin,plugin,684,". TBrowserPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TBrowserPlugin. class TBrowserPlugin: public TNamed. TRootBrowser. This class creates a ROOT object browser, constitued by three main; tabs. All tabs can 'swallow' frames, thanks to the new method:; ExecPlugin(const char *name = 0, const char *fname = 0,; const char *cmd = 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:1346,Modifiability,plugin,plugins,1346,"reates a ROOT object browser, constitued by three main; tabs. All tabs can 'swallow' frames, thanks to the new method:; ExecPlugin(const char *name = 0, const char *fname = 0,; const char *cmd = 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:3592,Modifiability,Inherit,InheritsFrom,3592,"rtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:3658,Modifiability,Inherit,InheritsFrom,3658,"_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBrowserPlugin&operator=(const TBrowserPlugin&); virt",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:7478,Modifiability,Inherit,Inheritance,7478,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. TStringfCommandCommand to be executed; Int_tfSubTabTab element number; Int_tfTabTab number; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); { }. virtual ~TBrowserPlugin(); {}. void SetTab(Int_t tab); { fTab = tab; }. void SetSubTab(Int_t sub); { fSubTab = sub; }. void SetCommand(const char* cmd); { fCommand = cmd; }. TRootBrowser& operator=(const TBrowserPlugin& ). » Author: Bertrand Bellenot 26/09/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: 7cf312b9bc9940a03d7c0cee95eea0085dc9898c $ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:7491,Modifiability,Inherit,Inherited,7491,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. TStringfCommandCommand to be executed; Int_tfSubTabTab element number; Int_tfTabTab number; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); { }. virtual ~TBrowserPlugin(); {}. void SetTab(Int_t tab); { fTab = tab; }. void SetSubTab(Int_t sub); { fSubTab = sub; }. void SetCommand(const char* cmd); { fCommand = cmd; }. TRootBrowser& operator=(const TBrowserPlugin& ). » Author: Bertrand Bellenot 26/09/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: 7cf312b9bc9940a03d7c0cee95eea0085dc9898c $ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:3482,Security,Hash,Hash,3482,"st char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:6032,Testability,Test,TestBit,6032,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBrowserPlugin&operator=(const TBrowserPlugin&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCommand(const char* cmd); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetSubTab(Int_t sub); voidSetTab(Int_t tab); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowserPlugin(const TBrowserPlugin&); TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:6071,Testability,Test,TestBits,6071,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBrowserPlugin&operator=(const TBrowserPlugin&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCommand(const char* cmd); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetSubTab(Int_t sub); voidSetTab(Int_t tab); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowserPlugin(const TBrowserPlugin&); TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBrowserPlugin.html:1912,Usability,Clear,Clear,1912," virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html604/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBrowserPlugin.html
https://root.cern/root/html604/TBtree.html:9204,Availability,Error,Error,9204,"nt_t idx) const; virtual TObject*Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) cons",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:9333,Availability,error,error,9333,"se(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const;",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:9417,Availability,error,error,9417,"const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() ",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:504,Energy Efficiency,adapt,adapt,504,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:3813,Energy Efficiency,allocate,allocated,3813,"d here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array of pointers and keys is allocated as ORDER+1; pairs of keys and nodes, meaning that one key field (key[0]) is not used; and therefore wasted. Given that the number of interior nodes is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (ea",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:4435,Energy Efficiency,allocate,allocate,4435,"efore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array of pointers and keys is allocated as ORDER+1; pairs of keys and nodes, meaning that one key field (key[0]) is not used; and therefore wasted. Given that the number of interior nodes is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; P",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:315,Modifiability,inherit,inherits,315,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:504,Modifiability,adapt,adapt,504,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:636,Modifiability,enhance,enhancement,636,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:990,Modifiability,enhance,enhancement,990,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Or",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:4908,Modifiability,variab,variable,4908,"des is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element h",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:5037,Modifiability,variab,variable,5037," nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; >; Psize - the physical size: how many elements are contained in the; array in the node",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:10733,Modifiability,Inherit,InheritsFrom,10733,"Collect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTSeqCollection::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTCollection::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*Last() const; Int_tTSeqCollection::LastIndex() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; Long64_tTSeqCollection::Merge(TCollection* list); virtual Bool_tTObject::Not",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:10799,Modifiability,Inherit,InheritsFrom,10799,"ollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTSeqCollection::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTCollection::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*Last() const; Int_tTSeqCollection::LastIndex() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; Long64_tTSeqCollection::Merge(TCollection* list); virtual Bool_tTObject::Notify(); static Int_tTSeqCollection::ObjCompare(TObject* a, TObject*",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:16963,Modifiability,Inherit,Inheritance,16963,"Referenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()). Requires sequential; search of complete tree till object is found. TObject * FindObject(const TObject* obj) const; Find object using the objects Compare() member function. Int_t IdxAdd(const TObj",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:16976,Modifiability,Inherit,Inherited,16976,"Referenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()). Requires sequential; search of complete tree till object is found. TObject * FindObject(const TObject* obj) const; Find object using the objects Compare() member function. Int_t IdxAdd(const TObj",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:5862,Performance,perform,perform,5862,"e of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; >; Psize - the physical size: how many elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - mo",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:2774,Security,access,access,2774,"ains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Order/2); LeafLowWaterMark = Order - 1. If the tree is only filled, then all the nodes will be at least 2/3 full.; They will almost all be exactly 2/3 full if the elements are added to the; tree in order (either increasing or decreasing). [Knuth says McCreight's; experiments showed almost 100% memory utilization. I don't see how that; can be given the algorithms that Knuth gives. McCreight must have used; a different scheme for balancing. [No, he used a different scheme for; splitting: he did a two-way split instead of the three way split as we do; here. Which means that McCreight does better on insertion of ordered data,; but we should do better on insertion of random data.]]. It must also be noted that B-trees were designed for DISK access algorithms,; not necessarily in-memory sorting, as we intend it to be used here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:7205,Security,access,access,7205,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TCla",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:10559,Security,Hash,Hash,10559,"t) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTSeqCollection::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTCollection::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*Last() const; Int_tTSeqCollection::LastIndex() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual ",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:16905,Security,access,access,16905,"lection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()).",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:7198,Testability,log,log,7198,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TCla",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:8156,Testability,Assert,AssertClass,8156,,MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:14545,Testability,Test,TestBit,14545,"ject** b, Int_t first, Int_t last); static voidTSeqCollection::QSort(TObject** a, Int_t nBs, TObject*** b, Int_t first, Int_t last); Int_tRank(const TObject* obj) const; virtual Int_tTObject::Read(const char* name); virtual voidTCollection::RecursiveRemove(TObject* obj); virtual TObject*Remove(TObject* obj); virtual voidTSeqCollection::RemoveAfter(TObject* after); voidTCollection::RemoveAll(); virtual voidTCollection::RemoveAll(TCollection* col); virtual TObject*TSeqCollection::RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTSeqCollection::RemoveLast(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTCollection::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTCollection::SetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBtree(Int_t ordern = 3); TBtree(const TBtree&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:14584,Testability,Test,TestBits,14584,"ject** b, Int_t first, Int_t last); static voidTSeqCollection::QSort(TObject** a, Int_t nBs, TObject*** b, Int_t first, Int_t last); Int_tRank(const TObject* obj) const; virtual Int_tTObject::Read(const char* name); virtual voidTCollection::RecursiveRemove(TObject* obj); virtual TObject*Remove(TObject* obj); virtual voidTSeqCollection::RemoveAfter(TObject* after); voidTCollection::RemoveAll(); virtual voidTCollection::RemoveAll(TCollection* col); virtual TObject*TSeqCollection::RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTSeqCollection::RemoveLast(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTCollection::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTCollection::SetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBtree(Int_t ordern = 3); TBtree(const TBtree&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtree.html:17453,Usability,Clear,Clear,17453,"er of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()). Requires sequential; search of complete tree till object is found. TObject * FindObject(const TObject* obj) const; Find object using the objects Compare() member function. Int_t IdxAdd(const TObject& obj); Add object and return its index in the tree. void Init(Int_t i); Initialize a B-tree. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a B-tree iterator. Int_t Rank(const TObject* obj) const; Returns the rank of the object in the tree. TObject * Remove(TObject* obj); Remove an object from the tree. void RootIsFull(); The root of the tree is full. Create an InnerNode that; points to it, and then inform the InnerNode that it is full. void RootIsEmpty(); If root",MatchSource.WIKI,root/html604/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtree.html
https://root.cern/root/html604/TBtreeIter.html:1450,Modifiability,Inherit,Inheritance,1450,"tatic TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator& aIter) const; Bool_toperator!=(const TBtreeIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TBtreeIter&operator=(const TBtreeIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBtreeIter(const TBtreeIter& iter); TBtreeIter(const TBtree* t, Bool_t dir = kIterForward). private:. TBtreeIter(). Data Members; private:. Int_tfCurCursorcurrent position in btree; Int_tfCursornext position in btree; Bool_tfDirectioniteration direction; const TBtree*fTreebtree being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtreeIter(const TBtree* t, Bool_t dir = kIterForward); Create a B-tree iterator. TBtreeIter(const TBtreeIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. TBtreeIter & operator=(const TBtreeIter& rhs); Overloaded assignment operator. void Reset(); Reset the B-tree iterator. TObject * Next(); Get next object from B-tree. Returns 0 when no more objects in tree. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const TBtreeIter& aIter) const; This operator compares two TBtreeIter objects. TObject* operator*() const; Return current object or nullptr. TBtreeIter(); { }. ~TBtreeIter(); { }. const TCollection * GetCollection() const; { return fTree; }. » Author: Fons Rademakers 10/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 15:38; This page has been",MatchSource.WIKI,root/html604/TBtreeIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtreeIter.html
https://root.cern/root/html604/TBtreeIter.html:1463,Modifiability,Inherit,Inherited,1463,"tatic TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator& aIter) const; Bool_toperator!=(const TBtreeIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TBtreeIter&operator=(const TBtreeIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBtreeIter(const TBtreeIter& iter); TBtreeIter(const TBtree* t, Bool_t dir = kIterForward). private:. TBtreeIter(). Data Members; private:. Int_tfCurCursorcurrent position in btree; Int_tfCursornext position in btree; Bool_tfDirectioniteration direction; const TBtree*fTreebtree being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtreeIter(const TBtree* t, Bool_t dir = kIterForward); Create a B-tree iterator. TBtreeIter(const TBtreeIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. TBtreeIter & operator=(const TBtreeIter& rhs); Overloaded assignment operator. void Reset(); Reset the B-tree iterator. TObject * Next(); Get next object from B-tree. Returns 0 when no more objects in tree. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const TBtreeIter& aIter) const; This operator compares two TBtreeIter objects. TObject* operator*() const; Return current object or nullptr. TBtreeIter(); { }. ~TBtreeIter(); { }. const TCollection * GetCollection() const; { return fTree; }. » Author: Fons Rademakers 10/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 15:38; This page has been",MatchSource.WIKI,root/html604/TBtreeIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBtreeIter.html
https://root.cern/root/html604/TBuffer.html:473,Availability,avail,available,473,". TBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer. class TBuffer: public TObject. TBuffer. Buffer base class used for serializing objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TBuffer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidAutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*Buffer() const; Int_tBufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject:",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:2269,Availability,Error,Error,2269,"ssname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInf",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:2398,Availability,error,error,2398,"c TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObjec",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:2482,Availability,error,error,2482,"dClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetN",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:18644,Availability,error,error,18644,"cCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer ",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:19698,Availability,error,error,19698,"attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass()",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:20088,Availability,down,down,20088,"icy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members.",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:18614,Integrability,rout,routine,18614,"cCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer ",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:19668,Integrability,rout,routine,19668,"attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass()",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:4150,Modifiability,Inherit,InheritsFrom,4150,"c Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tGetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsWriting() const; Bool_tTObject::IsZombie() const; Int_tLength() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:4216,Modifiability,Inherit,InheritsFrom,4216,"nName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tGetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsWriting() const; Bool_tTObject::IsZombie() const; Int_tLength() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp)",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:17682,Modifiability,extend,extending,17682,"ick; static TObject::EStatusBitsTObject::kHasUUID; static TBuffer::(anonymous)kInitialSize; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TBuffer::(anonymous)kIsOwner; static TObject::EStatusBitsTObject::kIsReferenced; static TBuffer::(anonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf arg",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:17755,Modifiability,Inherit,Inheritance,17755,"nonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Auto",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:17768,Modifiability,Inherit,Inherited,17768,"nonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Auto",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:17458,Performance,cache,cache,17458,"ick; static TObject::EStatusBitsTObject::kHasUUID; static TBuffer::(anonymous)kInitialSize; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TBuffer::(anonymous)kIsOwner; static TObject::EStatusBitsTObject::kIsReferenced; static TBuffer::(anonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf arg",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:20959,Performance,cache,cache,20959," out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TBuffer(); Default ctor. {}. TBuffer(const TBuffer& ); TBuffer objects cannot be copied or assigned. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:21115,Performance,cache,cache,21115,"etParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TBuffer(); Default ctor. {}. TBuffer(const TBuffer& ); TBuffer objects cannot be copied or assigned. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() const; { return fBufSize; }. void DetachBuffer(); { f",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:21272,Performance,cache,cache,21272," const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TBuffer(); Default ctor. {}. TBuffer(const TBuffer& ); TBuffer objects cannot be copied or assigned. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() const; { return fBufSize; }. void DetachBuffer(); { fBuffer = 0; }. Int_t Length() const; { return (Int_t)(fBufCur - fBuffer); }. Bool_t CheckObject(const TObject* obj). Bool_t CheckObject(const void* obj, cons",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:18954,Safety,avoid,avoiding,18954,"Buffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:19995,Safety,avoid,avoid,19995,"icy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members.",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:3984,Security,Hash,Hash,3984,"rVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tGetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsWriting() const; Bool_tTObject::IsZombie() const; Int_tLength() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const ch",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:12414,Testability,Test,TestBit,12414," Int_t comp_type); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBuffer(TBuffer::EMode mode); TBuffer(TBuffer::EMode mode, Int_t bufsiz); TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:12453,Testability,Test,TestBits,12453,":SetUniqueID(UInt_t uid); voidSetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBuffer(TBuffer::EMode mode); TBuffer(TBuffer::EMode mode, Int_t bufsiz); TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer.html:1658,Usability,Clear,Clear,1658,"e(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidAutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*Buffer() const; Int_tBufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, cons",MatchSource.WIKI,root/html604/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer.html
https://root.cern/root/html604/TBuffer3D.html:9911,Availability,Error,Error,9911,,MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:10040,Availability,error,error,10040,,MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:10124,Availability,error,error,10124,"t; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearSectionsValid(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static UInt_tDecCSLevel(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classnam",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:10781,Availability,mask,mask,10781,"tual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:12639,Availability,mask,mask,12639,"_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:13158,Availability,mask,mask,13158,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:17777,Availability,mask,mask,17777,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:17823,Availability,mask,mask,17823,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:17867,Availability,mask,mask,17867,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:17911,Availability,mask,mask,17911,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:17920,Availability,mask,mask,17920,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:17956,Availability,mask,mask,17956,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:18000,Availability,mask,mask,18000,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:8261,Energy Efficiency,efficient,efficient,8261,"s required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:464,Integrability,interface,interface,464,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5699,Integrability,interface,interface,5699,"is object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicatin",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:11094,Modifiability,Inherit,InheritsFrom,11094,"bjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObjec",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:11160,Modifiability,Inherit,InheritsFrom,11160,"ent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:16517,Modifiability,Inherit,Inheritance,16517,"::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBuffer3D::ESectionkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer3D::ESectionkRaw; static TBuffer3D::ESectionkRawSizes; static TBuffer3D::ESectionkShapeSpecific; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetC",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:16530,Modifiability,Inherit,Inherited,16530,"::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBuffer3D::ESectionkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer3D::ESectionkRaw; static TBuffer3D::ESectionkRawSizes; static TBuffer3D::ESectionkShapeSpecific; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetC",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:821,Performance,perform,performance,821,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:1627,Performance,perform,performance,1627,"ire a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) AddObject(); will return flags indicating which ones, otherwise it returns kNone. You must; fill the buffer and mark these sections valid, and pass the buffer again. A; typical code snippet would be:; TBuffer3DSphere sphereBuffer;; Fill out kCore...; Fill out kBoundingBox...; Fill out kShapeSpecific for TBuffer3DSphere; Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSections & TBuffer3D::kRawSizes) {",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5315,Performance,cache,cached,5315,"er (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5414,Performance,perform,perform,5414,"n matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5469,Performance,perform,performance,5469,"n matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:6544,Performance,cache,cached,6544,"ly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publish",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:8283,Performance,cache,cache,8283,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:7726,Safety,detect,detect,7726," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); ",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:10959,Security,Hash,Hash,10959,"t; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:1169,Testability,test,test,1169,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:4695,Testability,Log,Logical,4695,"do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocal",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:4884,Testability,log,logical,4884,"tated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For v",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5071,Testability,log,logical,5071,"o provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalM",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5193,Testability,log,logical,5193,"on of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be cap",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5221,Testability,log,logical,5221,"on of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be cap",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5536,Testability,log,logical,5536,"d contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; s",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5907,Testability,log,logical,5907,"re we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:5984,Testability,log,logical,5984,"re we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:7146,Testability,log,logical,7146,"s, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(T",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:8033,Testability,log,logical,8033," viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:8294,Testability,log,logical,8294,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:13617,Testability,Test,TestBit,13617,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:13656,Testability,Test,TestBits,13656,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:1114,Usability,Clear,ClearSectionsValid,1114,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:1178,Usability,clear,clear,1178,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:3422,Usability,clear,clear,3422,"apeSpecific for TBuffer3DSphere; Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSections & TBuffer3D::kRawSizes) {; Fill out kRawSizes...; }; if (reqSections & TBuffer3D::kRaw) {; Fill out kRaw...; }; Add second time to viewer - ignore return cannot do more; viewer->AddObject(buffer);; }; }>; ShapeSpecific: If the viewer can directly display the buffer without; filling of the kRaw/kRawSizes section it will not need to request client side; tessellation.; Currently we provide the following various shape specific classes, which the; OpenGL viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a stand",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:4075,Usability,simpl,simpler,4075,"ge of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively fe",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:6755,Usability,simpl,simply,6755,"you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualVie",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:8005,Usability,simpl,simple,8005," viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:9318,Usability,Clear,Clear,9318,,MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:16886,Usability,Clear,ClearSectionsValid,16886,"bject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBuffer3D.html:16908,Usability,Clear,Clear,16908,"bject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections",MatchSource.WIKI,root/html604/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBuffer3D.html
https://root.cern/root/html604/TBufferFile.html:2233,Availability,Error,Error,2233,"virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGe",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:2362,Availability,error,error,2362,"Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:2446,Availability,error,error,2446,"(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtu",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:20278,Availability,error,error,20278,":fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void TagStreamerInfo(TVirtualStreamerInfo* info); Mark the classindex of the current file as using this TStreamerInfo. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read TString from TBuffer. void WriteTString(const TString& s); Write TString to TBuffer. void ReadStdString(string& s); Read std::string from TBuffer. void WriteStdString(const string& s); Write std::string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, cons",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:39470,Availability,failure,failure,39470,"st); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object of class 'actualClass'. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:28447,Energy Efficiency,allocate,allocated,28447,"its. IMPORTANT NOTEs. --NOTE 1; Lets assume an original variable double x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:28634,Energy Efficiency,allocate,allocated,28634,"ading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:28813,Energy Efficiency,allocate,allocated,28813," (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:28987,Energy Efficiency,allocate,allocated,28987,"d the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for th",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:29164,Energy Efficiency,allocate,allocated,29164,"0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:29354,Energy Efficiency,allocate,allocated,29354,"s from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferF",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:29533,Energy Efficiency,allocate,allocated,29533,"ers from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of ch",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:29716,Energy Efficiency,allocate,allocated,29716,"orts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:29960,Energy Efficiency,allocate,allocated,29960,"ment is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t* i); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t* l); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:30266,Energy Efficiency,allocate,allocated,30266," I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t* i); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t* l); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long64_t* l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. Int_t ReadStaticArray(Float_t* f); Read array of floats from the I/O buffer. Returns the number of floats; read. Int_t ReadStaticArray(Double_t* d); Read array of doubles from the I/O buffer. Returns the number",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:45525,Energy Efficiency,allocate,allocated,45525,"e benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcessID(TRefTable* reftable) const; Return the last TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVir",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:20248,Integrability,rout,routine,20248,":fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void TagStreamerInfo(TVirtualStreamerInfo* info); Mark the classindex of the current file as using this TStreamerInfo. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read TString from TBuffer. void WriteTString(const TString& s); Write TString to TBuffer. void ReadStdString(string& s); Read std::string from TBuffer. void WriteStdString(const string& s); Write std::string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, cons",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:23868,Integrability,depend,depending,23868,"d; see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16(). void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer.; The following cases are supported for streaming a Float16_t type; depending on the range declaration in the comment field of the data member:; A- Float16_t fNormal;; B- Float16_t fTemperature; //[0,100]; C- Float16_t fCharge; //[-1,1,2]; D- Float16_t fVertex[3]; //[-30,30,10]; E- Float16_t fChi2; //[0,0,6]; F- Int_t fNsp;; Float16_t* fPointValue; //[fNsp][0,3]. In case A fNormal is converted from a Float_t to a Float_t with mantissa truncated to 12 bits; In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specifie",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:26158,Integrability,depend,depending,26158,"t the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a float to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Float16_t data type in tutorial double32.C. /*; ; */. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer.; The following cases are supported for streaming a Double32_t type; depending on the range declaration in the comment field of the data member:; A- Double32_t fNormal;; B- Double32_t fTemperature; //[0,100]; C- Double32_t fCharge; //[-1,1,2]; D- Double32_t fVertex[3]; //[-30,30,10]; E- Double32_t fChi2; //[0,0,6]; F- Int_t fNsp;; Double32_t* fPointValue; //[fNsp][0,3]. In case A fNormal is converted from a Double_t to a Float_t; In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbi",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:46947,Integrability,Interface,Interface,46947,"m file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in r",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:47045,Integrability,Interface,Interface,47045,"n the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries. Int_t WriteClassBuffer(const TClass* cl, void* pointer); Function called by ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:4237,Modifiability,Inherit,InheritsFrom,4237,"WriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); v",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:4303,Modifiability,Inherit,InheritsFrom,4303,"tual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator de",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:19223,Modifiability,extend,extending,19223,"onymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the ne",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:19368,Modifiability,Inherit,Inheritance,19368,"store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersio",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:19381,Modifiability,Inherit,Inherited,19381,"store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersio",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:25195,Modifiability,variab,variable,25195," In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbits>16 it is set to 16; if (xmin==0 and xmax==0 and nbits <=14) the float word will have; its mantissa truncated to nbits significative bits. IMPORTANT NOTE. --NOTE 1; Lets assume an original variable float x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a float to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Float16_t data type in tutorial double32.C. /*; ; */. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer.; The following cases are supported for streaming a Double32_t type; depending on the range declaration in the comment field of the data member:; A- Double32_t fNormal;; B",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:27491,Modifiability,variab,variable,27491,"ed to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbits>32 it is set to 32; if (xmin==0 and xmax==0 and nbits <=14) the double word will be converted; to a float and its mantissa truncated to nbits significative bits. IMPORTANT NOTEs. --NOTE 1; Lets assume an original variable double x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns th",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:38153,Modifiability,inherit,inherit,38153,"ent* ele = 0); Write array of n doubles (as float) into the I/O buffer.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Write an array of object starting at the address 'start' and of length 'n'; the objects in the array are assumed to be of class 'cl'. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Write an array of object starting at the address '*start' and of length 'n'; the objects in the array are of class 'cl'; 'isPreAlloc' indicates whether the data member is marked with '->'; Return:; 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TObject * ReadObject(const TClass* cl); Read object from I/O buffer. clReq is NOT used.; The value returned is the address of the actual start in memory of; the object. Note that if the actual class of the object does not; inherit first from TObject, the type of the pointer is NOT 'TObject*'.; [More accurately, the class needs to start with the TObject part, for; the pointer to be a real TObject*].; We recommend using ReadObjectAny instead of ReadObject. void SkipObjectAny(); Skip any kind of object from buffer. void * ReadObjectAny(const TClass* cast); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object o",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:38733,Modifiability,inherit,inheritance,38733,"; 'isPreAlloc' indicates whether the data member is marked with '->'; Return:; 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TObject * ReadObject(const TClass* cl); Read object from I/O buffer. clReq is NOT used.; The value returned is the address of the actual start in memory of; the object. Note that if the actual class of the object does not; inherit first from TObject, the type of the pointer is NOT 'TObject*'.; [More accurately, the class needs to start with the TObject part, for; the pointer to be a real TObject*].; We recommend using ReadObjectAny instead of ReadObject. void SkipObjectAny(); Skip any kind of object from buffer. void * ReadObjectAny(const TClass* cast); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object of class 'actualClass'. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:41319,Modifiability,inherit,inheriting,41319,"(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< kMaxMapCount) when writing. UInt_t CheckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); Check for object in the read map. If the object is 0 it still has to be; read. Try to read it from the buffer starting at location offset. If the; object is -1 then it really does not exist and we return 0. If the object; exists just return the offset. Bool_t CheckObject(const TObject* obj); Check if the specified object is already in the buffer.; Returns kTRUE if object already in the buffer, kFALSE otherwise; (also if obj is 0 or TBuffer not in writing mode). Bool_t CheckObject(const void* obj, const TClass* ptrClass); Check if the specified object of the specified class is already in; the buffer. Returns kTRUE if object already in the buffer,; kFALSE otherwise (also if obj is 0 ). void SetPidOffset(UShort_t offset); This offset is used when a key (or basket) is t",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:18473,Performance,cache,cache,18473," TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBufferFile::(anonymous)kStreamedMemberWise; static TBufferFile::(anonymous)kTextBasedStreaming; static TBufferFile::(anonymous)kUser1; static TBufferFile::(anonymous)kUser2; static TBufferFile::(anonymous)kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:44734,Performance,perform,performance,44734,"erence of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 c",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:44761,Performance,perform,performance,44761," Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcess",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:46677,Performance,optimiz,optimized,46677,"to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcessID(TRefTable* reftable) const; Return the last TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the nu",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:46821,Performance,optimiz,optimized,46821,"ast TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserial",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:49969,Performance,perform,performance,49969," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:49996,Performance,perform,performance,49996,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64(Long64_t& l). void ReadULong64(ULong64_t& l). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t*& c)",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:40500,Safety,safe,safely,40500,"derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< k",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:4071,Security,Hash,Hash,4071,"lass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(c",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:40254,Security,checksum,checksum,40254," WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:44385,Security,hash,hashtable,44385,"1); Add object to the fMap container.; If obj is not 0 add object to the map (in read mode also add 0 objects to; the map). This method may only be called outside this class just before; calling obj->Streamer() to prevent self reference of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:44570,Security,hash,hashtable,44570,"erence of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 c",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:44773,Security,hash,hashsize,44773," Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcess",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:49620,Security,hash,hashtable,49620,"Actions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c)",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:49805,Security,hash,hashtable,49805," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:50008,Security,hash,hashsize,50008,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64(Long64_t& l). void ReadULong64(ULong64_t& l). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t*& c)",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:12687,Testability,Test,TestBit,12687,"rtual voidTObject::SetUniqueID(UInt_t uid); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBufferFile(TBuffer::EMode mode); TBufferFile(TBuffer::EMode mode, Int_t bufsiz); TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:12726,Testability,Test,TestBits,12726,"id); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBufferFile(TBuffer::EMode mode); TBufferFile(TBuffer::EMode mode, Int_t bufsiz); TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferFile.html:1613,Usability,Clear,Clear,1613,"s::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const ",MatchSource.WIKI,root/html604/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferFile.html
https://root.cern/root/html604/TBufferJSON.html:3042,Availability,Error,Error,3042,"e, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo*, Bool_t); virtual voidForceWriteInfoClones(TClonesArray*); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObjec",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:3171,Availability,error,error,3171,"idTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo*, Bool_t); virtual voidForceWriteInfoClones(TClonesArray*); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual In",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:3255,Availability,error,error,3255," = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo*, Bool_t); virtual voidForceWriteInfoClones(TClonesArray*); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const;",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:20198,Availability,recover,recovered,20198,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:40974,Availability,failure,failure,40974,"the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). Int_t WriteClassBuffer(const TClass* cl, void* pointer); Function called by the Streamer functions to serialize object at p; to buffer b. The optional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TStreamerInfo. TBufferJSON(). Version_t ReadVersionNoCheckSum(UInt_t* , UInt_t* ). void TagStreamerInfo(TVirtualStreamerInfo* ); {}. Int_t ReadBuf(void* , Int_t ); abstract virtual methods from TBuffer, which should be redefined. void WriteBuf(const void* , Int_t ). char * ReadString(char* , Int_t ). void WriteString(const char* ). Int_t GetVersionOwner() const. Int_t GetMapCount() const. void GetMappedObject(UInt_t , void*& , TClass*& ) const. void MapObject(const TObject* , UInt_t = 1). void MapObject(const void* , const TClass* , UInt_t = 1). void Reset(). void InitMap(",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:509,Integrability,interface,interface,509,". TBufferJSON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TBufferJSON. class TBufferJSON: public TBuffer. Class for serializing object into JavaScript Object Notation (JSON) format.; It creates such object representation, which can be directly; used in JavaScript ROOT (JSROOT) for drawing. TBufferJSON implements TBuffer interface, therefore most of; ROOT and user classes can be converted into JSON.; There are certain limitations for classes with custom streamers,; which should be equipped specially for this purposes (see TCanvas::Streamer() as example). To perform conversion, one should use TBufferJSON::ConvertToJSON method like:. TH1* h1 = new TH1I(""h1"",""title"",100, 0, 10);; h1->FillRandom(""gaus"",10000);; TString json = TBufferJSON::ConvertToJSON(h1);. Function Members (Methods); public:. virtual~TBufferJSON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClas",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:19346,Integrability,depend,depending,19346,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:20510,Integrability,depend,depending,20510,"e to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0)",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:32708,Integrability,message,message,32708," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:32907,Integrability,message,message,32907,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:35806,Integrability,message,message,35806,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:35980,Integrability,message,message,35980," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:40641,Integrability,Interface,Interface,40641,"ters. void SetFloatFormat(const char* fmt = ""%e""); set printf format for float/double members, default ""%e"". const char * GetFloatFormat(); return current printf format for float/double members, default ""%e"". Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). Int_t WriteClassBuffer(const TClass* cl, void* pointer); Function called by the Streamer functions to serialize object at p; to buffer b. The optional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TStreamerInfo. TBufferJSON(). Version_t ReadVersionNoCheckSum(UInt_t* , UInt_t* ). void TagStreamerInfo(TVirtualStreamerInfo* ); {}. Int_t ReadBuf(void* , Int_t ); abstract virtual methods from TBuffer, which should be redefine",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:4969,Modifiability,Inherit,InheritsFrom,4969,"rOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject*, UInt_t = 1); virtual voidMapObject(const void*, const TClass*, UInt_t = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator dele",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:5035,Modifiability,Inherit,InheritsFrom,5035,"bject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject*, UInt_t = 1); virtual voidMapObject(const void*, const TClass*, UInt_t = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* v",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:20468,Modifiability,extend,extending,20468,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:20811,Modifiability,Inherit,Inheritance,20811,"to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with ",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:20824,Modifiability,Inherit,Inherited,20824,"to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with ",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:21065,Modifiability,inherit,inherited,21065," in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with converted member. Bool_t CheckObject(const TObject* ); Check that object already stored in the buffer. Bool_t CheckObject(const void* , const TClass* ); Check that object already stored in the buffer. void Write",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:25303,Modifiability,inherit,inherited,25303,"TClass* , Version_t = -1); Should be called in the beginning of custom class streamer.; Informs buffer data about class which will be streamed now. ClassBegin(), ClassEnd() and ClassMemeber() should be used in; custom class streamers to specify which kind of data are; now streamed. Such information is used to correctly; convert class data to JSON. Without that functions calls; classes with custom streamers cannot be used with TBufferJSON. void ClassEnd(const TClass* ); Should be called at the end of custom streamer; See TBufferJSON::ClassBegin for more details. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(TJSONStackObj* stack, const TStreamerElement* elem = 0); Function is converts TObject and TString structures to more compact representation. TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const T",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:750,Performance,perform,perform,750,". TBufferJSON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TBufferJSON. class TBufferJSON: public TBuffer. Class for serializing object into JavaScript Object Notation (JSON) format.; It creates such object representation, which can be directly; used in JavaScript ROOT (JSROOT) for drawing. TBufferJSON implements TBuffer interface, therefore most of; ROOT and user classes can be converted into JSON.; There are certain limitations for classes with custom streamers,; which should be equipped specially for this purposes (see TCanvas::Streamer() as example). To perform conversion, one should use TBufferJSON::ConvertToJSON method like:. TH1* h1 = new TH1I(""h1"",""title"",100, 0, 10);; h1->FillRandom(""gaus"",10000);; TString json = TBufferJSON::ConvertToJSON(h1);. Function Members (Methods); public:. virtual~TBufferJSON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClas",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:19632,Performance,cache,cache,19632,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:25942,Performance,Perform,PerformPostProcessing,25942," typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(TJSONStackObj* stack, const TStreamerElement* elem = 0); Function is converts TObject and TString structures to more compact representation. TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Ignored in TBufferJSON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObject",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:27580,Performance,optimiz,optimize,27580,"d SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Ignored in TBufferJSON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStream",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:27850,Performance,optimiz,optimize,27850,"SON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:28145,Performance,optimiz,optimize,28145,"at16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. ",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:28419,Performance,optimiz,optimize,28419,"fer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t Re",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:20198,Safety,recover,recovered,20198,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:22235,Safety,avoid,avoid,22235,"1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with converted member. Bool_t CheckObject(const TObject* ); Check that object already stored in the buffer. Bool_t CheckObject(const void* , const TClass* ); Check that object already stored in the buffer. void WriteObject(const TObject* obj); Convert object into json structures.; !!! Should be used only by TBufferJSON itself.; Use ConvertToJSON() methods to convert object to json; Redefined here to avoid gcc 3.x warning. TJSONStackObj * PushStack(Int_t inclevel = 0); add new level to the structures stack. TJSONStackObj * PopStack(); remove one level from stack. TJSONStackObj * Stack(Int_t depth = 0); return stack object of specified depth. void AppendOutput(const char* line0, const char* line1 = 0); Info(""AppendOutput"","" '%s' '%s'"", line0, line1?line1 : ""---"");. void JsonStartElement(const TStreamerElement* elem, const TClass* base_class = 0). void JsonDisablePostprocessing(). Int_t JsonSpecialClass(const TClass* cl) const; return non-zero value when class has special handling in JSON; it is TCollection (-130), TArray (100), TString (110), std::string (120) and STL containers (1..6). void JsonWriteObject(const void* obj, const TClass* objClass, Bool_t check_map = kTRUE); Write object to buffer; If object was written before, only pointer will be stored; If check_map==kFALSE, object will be stored in any case and pointer will not be registered in the ",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:32694,Safety,avoid,avoid,32694," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:32893,Safety,avoid,avoid,32893,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:35788,Safety,avoid,avoid,35788,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:35962,Safety,avoid,avoid,35962," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:4808,Security,Hash,Hash,4808,"ass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject*, UInt_t = 1); virtual voidMapObject(const void*, const TClass*, UInt_t = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char*",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:13112,Testability,Test,TestBit,13112,"ReadParam(Int_t); voidTBuffer::SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); virtual voidSetStreamerElementNumber(TStreamerElement* elem, Int_t comp_type); virtual voidTObject::SetUniqueID(UInt_t uid); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo*); TBufferJSON(); TBufferJSON(const TBufferJSON&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:13151,Testability,Test,TestBits,13151,"ocFunc(ReAllocCharFun_t reallocfunc = 0); virtual voidSetStreamerElementNumber(TStreamerElement* elem, Int_t comp_type); virtual voidTObject::SetUniqueID(UInt_t uid); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo*); TBufferJSON(); TBufferJSON(const TBufferJSON&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferJSON.html:2185,Usability,Clear,Clear,2185,"nce& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html604/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferJSON.html
https://root.cern/root/html604/TBufferSQL.html:2325,Availability,Error,Error,2325,"ferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static In",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:2454,Availability,error,error,2454,"Class*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:2538,Availability,error,error,2538,"oidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBuffe",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:4498,Modifiability,Inherit,InheritsFrom,4498,":GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:4564,Modifiability,Inherit,InheritsFrom,4564,"able* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:21111,Modifiability,extend,extending,21111,"fMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Operator>>. vo",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:21382,Modifiability,Inherit,Inheritance,21382,"tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Operator>>. void ReadLong(Long_t& l); Operator>>. void ReadDouble(Double_t& d); Operator>>. void WriteBool(Bool_t b); Operator<<. void WriteChar(Char_t c); Operator<<. void WriteShort(Short_t s); Operator<<. void WriteInt(Int_t i); Operator<<. void WriteLong(Long_t l); Operator<<. void WriteFloat(Float_t f); Operator<<. void WriteDoubl",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:21395,Modifiability,Inherit,Inherited,21395,"tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Operator>>. void ReadLong(Long_t& l); Operator>>. void ReadDouble(Double_t& d); Operator>>. void WriteBool(Bool_t b); Operator<<. void WriteChar(Char_t c); Operator<<. void WriteShort(Short_t s); Operator<<. void WriteInt(Int_t i); Operator<<. void WriteLong(Long_t l); Operator<<. void WriteFloat(Float_t f); Operator<<. void WriteDoubl",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:20257,Performance,cache,cache,20257,"fer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBufferFile::(anonymous)TBufferFile::kStreamedMemberWise; static TBufferFile::(anonymous)TBufferFile::kTextBasedStreaming; static TBufferFile::(anonymous)TBufferFile::kUser1; static TBufferFile::(anonymous)TBufferFile::kUser2; static TBufferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_q",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:4319,Security,Hash,Hash,4319,"atic Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virt",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:13959,Testability,Test,TestBit,13959,"(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTBufferFile::StreamObject(TObject* obj); virtual voidTBufferFile::StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL(); TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidTBufferFile::WriteArray(const Bool_t* b, Int_t n); virtual voidTBufferFile::WriteArray(const Char_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const UChar_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const Short_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const UShort_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const Int_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const UInt_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const Long_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Long64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Float_t* f, Int_t n); virtual voidTBufferFile::WriteArray(const Double_t* d, In",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:13998,Testability,Test,TestBits,13998,"eamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTBufferFile::StreamObject(TObject* obj); virtual voidTBufferFile::StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL(); TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidTBufferFile::WriteArray(const Bool_t* b, Int_t n); virtual voidTBufferFile::WriteArray(const Char_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const UChar_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const Short_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const UShort_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const Int_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const UInt_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const Long_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Long64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Float_t* f, Int_t n); virtual voidTBufferFile::WriteArray(const Double_t* d, Int_t n); virtual voidTBufferFile::WriteAr",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL.html:1692,Usability,Clear,Clear,1692,"ionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject:",MatchSource.WIKI,root/html604/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL.html
https://root.cern/root/html604/TBufferSQL2.html:2657,Availability,Error,Error,2657,"; virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetE",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:2786,Availability,error,error,2786,"const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorFlag() const; static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::Get",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:2870,Availability,error,error,2870,"ssMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorFlag() const; static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtua",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:22071,Availability,Error,Error,22071,"ferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of data in database; TSQLObjectData*fCurrentData!; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag! Error id value; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Long64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:4911,Modifiability,Inherit,InheritsFrom,4911,"l TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TSQLStructure*GetStructure() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:4977,Modifiability,Inherit,InheritsFrom,4977,"nst; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TSQLStructure*GetStructure() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:23256,Modifiability,extend,extending,23256,"ong64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be ",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:23693,Modifiability,Inherit,Inheritance,23693,"ferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t ",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:23706,Modifiability,Inherit,Inherited,23706,"ferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t ",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:28290,Modifiability,inherit,inherited,28290,"o correctly; convert class data to/from ""normal"" sql tables with meaningfull names; and correct datatypes. Without that functions data from custom streamer; will be saved as ""raw"" data in special _streamer_ table one value after another; Such MUST be used when object is written with standard ROOT streaming; procedure, but should be read back in custom streamer.; For example, custom streamer of TNamed class may look like:. void ClassEnd(const TClass* ); Method indicates end of streaming of classdata in custom streamer.; See ClassBegin() method for more details. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); Method indicates name and typename of class memeber,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as datamember; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(b);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; For more details see ClassBegin() method description. void WorkWithClass(const char* classname, Version_t classversion); This function is a part of IncrementLevel method.; Also used in StartClass method. void WorkWithElement(TStreamerElement* elem, Int_t comp_type); This function is a part of SetStreamerElementNumber method.; It is introduced for reading of data for specified data memeber of class.; Used also in ReadFastArray met",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:30181,Modifiability,variab,variable,30181,"ent(TStreamerElement* elem, Int_t comp_type); This function is a part of SetStreamerElementNumber method.; It is introduced for reading of data for specified data memeber of class.; Used also in ReadFastArray methods to resolve problem of compressed data,; when several data memebers of the same basic type streamed with single ...FastArray call. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer; actually version is normally defined by table name; and kept in intermediate variable fReadVersionBuffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have b",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:45967,Modifiability,variab,variable,45967,"value from table and convert it to Bool_t value. void SqlReadBasic(UChar_t& value); read current value from table and convert it to UChar_t value. void SqlReadBasic(UShort_t& value); read current value from table and convert it to UShort_t value. void SqlReadBasic(UInt_t& value); read current value from table and convert it to UInt_t value. void SqlReadBasic(ULong_t& value); read current value from table and convert it to ULong_t value. void SqlReadBasic(ULong64_t& value); read current value from table and convert it to ULong64_t value. const char* SqlReadValue(const char* tname); read string value from current stack node. const char* SqlReadCharStarValue(); read CharStar value, if it has special code, request it from large table. TSQLStructure* PushStack(); Push stack with structurual information about streamed object. TSQLStructure* PopStack(); Pop stack. TSQLStructure* Stack(Int_t depth = 0); returns head of stack. void SetFloatFormat(const char* fmt = ""%e""); set printf format for float/double members, default ""%e""; changes global TSQLServer variable. const char* GetFloatFormat(); return current printf format for float/double members, default ""%e""; return format, hold by TSQLServer. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. TBufferSQL2(const TBufferSQL2& ); TBufferSQL2 objects",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:21730,Performance,cache,cache,21730,"ferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of data in database; TSQLObjectData*fCurrentData!; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag! Error id value; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Long64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:31217,Performance,optimiz,optimize,31217,"t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:31485,Performance,optimiz,optimize,31485,"ect from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t ",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:31778,Performance,optimiz,optimize,31778,"y used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& ",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:32050,Performance,optimiz,optimize,32050,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t ReadArray(Double_t*& d); R",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:25575,Safety,avoid,avoid,25575," TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name and version are taken from special objects table. void IncrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and indent new level in data structure.; This call indicates, that TStreamerInfo functions starts streaming; object data of correspondent class. void DecrementLevel(TVirtualStreamerInfo* ); Fun",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:4750,Security,Hash,Hash,4750,"Param(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TSQLStructure*GetStructure() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject:",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:13974,Testability,Test,TestBit,13974,"dSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); void*SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); TSQLStructure*SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, TMemberStreamer* streamer, const TClass* cl, Int_t n = 0, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL2(TBuffer::EMode mode); TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:14013,Testability,Test,TestBits,14013,"on(const TClass* cl = 0); void*SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); TSQLStructure*SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, TMemberStreamer* streamer, const TClass* cl, Int_t n = 0, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL2(TBuffer::EMode mode); TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:417,Usability,simpl,simple,417,". TBufferSQL2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TBufferSQL2. class TBufferSQL2: public TBufferFile. Class for serializing/deserializing object to/from SQL data base.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from TSQLStructure objects.; TBufferSQL2 class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored. There are; limitations for complex objects like TTree, TClonesArray, TDirectory and; few other, which can not be converted to SQL (yet). Function Members (Methods); public:. virtual~TBufferSQL2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::Clas",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:441,Usability,simpl,simple,441,". TBufferSQL2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TBufferSQL2. class TBufferSQL2: public TBufferFile. Class for serializing/deserializing object to/from SQL data base.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from TSQLStructure objects.; TBufferSQL2 class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored. There are; limitations for complex objects like TTree, TClonesArray, TDirectory and; few other, which can not be converted to SQL (yet). Function Members (Methods); public:. virtual~TBufferSQL2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::Clas",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:2037,Usability,Clear,Clear,2037,"ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const ",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferSQL2.html:25132,Usability,simpl,simple,25132,"le.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name a",MatchSource.WIKI,root/html604/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferSQL2.html
https://root.cern/root/html604/TBufferXML.html:3216,Availability,Error,Error,3216,"nst; static TObject*ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static co",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:3345,Availability,error,error,3345,"nvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:3429,Availability,error,error,3429,"l_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:27268,Deployability,configurat,configuration,27268,"nt for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWri",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:27506,Deployability,configurat,configuration,27506,"; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:42543,Integrability,message,message,42543," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:42742,Integrability,message,message,42742,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:45555,Integrability,message,message,45555,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:45729,Integrability,message,message,45729," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:5563,Modifiability,Inherit,InheritsFrom,5563,"le::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; Int_tTXMLSetup::GetNextRefCounter(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TStringTXMLSetup::GetSetupAsString(); virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; TXMLSetup::EXMLLayoutTXMLSetup::GetXmlLayout() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTXMLSetup::IsStoreStreamerInfos() const; Bool_tTXMLSetup::IsUseDtd() const; Bool_tTXMLSetup::IsUseNamespaces() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const ch",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:5629,Modifiability,Inherit,InheritsFrom,5629,"UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; Int_tTXMLSetup::GetNextRefCounter(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TStringTXMLSetup::GetSetupAsString(); virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; TXMLSetup::EXMLLayoutTXMLSetup::GetXmlLayout() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTXMLSetup::IsStoreStreamerInfos() const; Bool_tTXMLSetup::IsUseDtd() const; Bool_tTXMLSetup::IsUseNamespaces() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) con",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:25722,Modifiability,extend,extending,25722,"algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Int_tfIOVersion! indicates format of ROOT xml file; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXML",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:26392,Modifiability,Inherit,Inheritance,26392,"fault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, ",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:26405,Modifiability,Inherit,Inherited,26405,"fault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, ",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:27210,Modifiability,inherit,inherited,27210,"nt for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWri",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:27268,Modifiability,config,configuration,27268,"nt for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWri",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:27506,Modifiability,config,configuration,27506,"; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:27750,Modifiability,inherit,inherit,27750,"ta to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:34473,Modifiability,inherit,inherited,34473,"st TClass* , Version_t = -1); Should be called in the beginning of custom class streamer.; Informs buffer data about class which will be streamed now. ClassBegin(), ClassEnd() and ClassMemeber() should be used in; custom class streamers to specify which kind of data are; now streamed. Such information is used to correctly; convert class data to XML. Without that functions calls; classes with custom streamers cannot be used with TBufferXML. void ClassEnd(const TClass* ); Should be called at the end of custom streamer; See TBufferXML::ClassBegin for more details. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffe",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:24410,Performance,cache,cache,24410,"ile::kUser1; static TBufferFile::(anonymous)TBufferFile::kUser2; static TBufferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfCanUseCompact! flag indicate that basic type (like Int_t) can be placed in the same tag; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Int_tfIOVersion! indicates format of ROOT xml file; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:35112,Performance,Perform,PerformPostProcessing,35112,"; Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); function to read class from buffer, used in old-style streamers. void WriteClass(const TClass* cl); function to write class into buffer, used in old-style streamers. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version fr",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:35226,Performance,Perform,PerformPreProcessing,35226,"ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); function to read class from buffer, used in old-style streamers. void WriteClass(const TClass* cl); function to write class into buffer, used in old-style streamers. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. void CheckVersionBuf(); ch",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:37452,Performance,optimiz,optimize,37452," cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to xml; Version will be written with next I/O operation or; will be added as attribute of class tag, created by IncrementLevel call. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer; Actually skip only one node on current level of xml structure. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElem",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:37720,Performance,optimiz,optimize,37720," from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer; Actually skip only one node on current level of xml structure. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h)",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:38013,Performance,optimiz,optimize,38013,"adFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. In",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:38285,Performance,optimiz,optimize,38285,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t Re",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:28695,Safety,avoid,avoid,28695,"= kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negativ",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:42529,Safety,avoid,avoid,42529," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:42728,Safety,avoid,avoid,42728,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:45537,Safety,avoid,avoid,45537,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:45711,Safety,avoid,avoid,45711," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:51066,Safety,safe,safe,51066,"ue. void XmlReadBasic(Float_t& value); reads string from current xml node and convert it to Float_t value. void XmlReadBasic(Double_t& value); reads string from current xml node and convert it to Double_t value. void XmlReadBasic(Bool_t& value); reads string from current xml node and convert it to Bool_t value. void XmlReadBasic(UChar_t& value); reads string from current xml node and convert it to UChar_t value. void XmlReadBasic(UShort_t& value); reads string from current xml node and convert it to UShort_t value. void XmlReadBasic(UInt_t& value); reads string from current xml node and convert it to UInt_t value. void XmlReadBasic(ULong_t& value); reads string from current xml node and convert it to ULong_t value. void XmlReadBasic(ULong64_t& value); reads string from current xml node and convert it to ULong64_t value. const char* XmlReadValue(const char* name); read string value from current stack node. void SetFloatFormat(const char* fmt = ""%e""); Set printf format for float/double members, default ""%e""; This method is not thread-safe as it changes a global state. const char* GetFloatFormat(); return current printf format for float/double members, default ""%e"". Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. I",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:5402,Security,Hash,Hash,5402,"alStreamerInfo*TBufferFile::GetInfo(); Int_tGetIOVersion() const; virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; Int_tTXMLSetup::GetNextRefCounter(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TStringTXMLSetup::GetSetupAsString(); virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; TXMLSetup::EXMLLayoutTXMLSetup::GetXmlLayout() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTXMLSetup::IsStoreStreamerInfos() const; Bool_tTXMLSetup::IsUseDtd() const; Bool_tTXMLSetup::IsUseNamespaces() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(con",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:27009,Security,access,access,27009,"uf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, pr",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:14862,Testability,Test,TestBit,14862,"es(Bool_t iUseNamespaces = kTRUE); voidTBuffer::SetWriteMode(); virtual voidTBufferFile::SetWriteParam(Int_t mapsize); virtual voidTXMLSetup::SetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferXML(TBuffer::EMode mode); TBufferXML(const TBufferXML&); TBufferXML(TBuffer::EMode mode, TXMLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:14901,Testability,Test,TestBits,14901,"TBuffer::SetWriteMode(); virtual voidTBufferFile::SetWriteParam(Int_t mapsize); virtual voidTXMLSetup::SetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferXML(TBuffer::EMode mode); TBufferXML(const TBufferXML&); TBufferXML(TBuffer::EMode mode, TXMLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:422,Usability,simpl,simple,422,". TBufferXML. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TBufferXML. class TBufferXML: public TBufferFile, public TXMLSetup. Class for serializing/deserializing object to/from xml.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from xml.; Instead of writing a binary data it creates a set of xml structures as; nodes and attributes; TBufferXML class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored to xml. There are; limitations for complex objects like TTree, which can not be yet converted to xml. Function Members (Methods); public:. virtual~TBufferXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsi",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:446,Usability,simpl,simple,446,". TBufferXML. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TBufferXML. class TBufferXML: public TBufferFile, public TXMLSetup. Class for serializing/deserializing object to/from xml.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from xml.; Instead of writing a binary data it creates a set of xml structures as; nodes and attributes; TBufferXML class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored to xml. There are; limitations for complex objects like TTree, which can not be yet converted to xml. Function Members (Methods); public:. virtual~TBufferXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsi",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:2080,Usability,Clear,Clear,2080,"ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TObject*ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:19766,Usability,simpl,simple,19766,":CheckCount(UInt_t offset); UInt_tTBufferFile::CheckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); voidCheckVersionBuf(); voidCreateElemNode(const TStreamerElement* elem); XMLNodePointer_tCreateItemNode(const char* name); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExtractPointer(XMLNodePointer_t node, void*& ptr, TClass*& cl); voidExtractReference(XMLNodePointer_t node, const void* ptr, const TClass* cl); Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; const char*TXMLSetup::GetElItemName(TStreamerElement* el); Bool_tTXMLSetup::IsValidXmlSetup(const char* setupstr); voidTObject::MakeZombie(); voidPerformPostProcessing(); voidPerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); TXMLStackObj*PopStack(); Bool_tProcessPointer(const void* ptr, XMLNodePointer_t node); TXMLStackObj*PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); virtual Int_tTBuffer::Read(const char* name); Bool_tTXMLSetup::ReadSetupFromStr(const char* setupstr); voidRegisterPointer(const void* ptr, XMLNodePointer_t node); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); voidSetXML(TXMLEngine* xml); voidShiftStack(const char* info = 0); TXMLStackObj*Stack(Int_t depth = 0); XMLNodePointer_tStackNode(); TBufferXML(); Bool_tVerifyAttr(XMLNodePointer_t node, const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyElemNode(const TStreamerElement* elem); Bool_tVerifyItemNode(const char* name, const char* errinfo = 0); Bool_tVerifyNode(XMLNodePointer_t node, const char* name, const char* errinfo = 0); Bool_tVerifyStackAttr(const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyStackNode(const char* name, const char* errinfo = 0); voidWorkWithClass(TStreamerInfo* info, const TClass* cl = 0); voidWorkWithElemen",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TBufferXML.html:28775,Usability,simpl,simple,28775,"ct class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates",MatchSource.WIKI,root/html604/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TBufferXML.html
https://root.cern/root/html604/TButton.html:7517,Availability,Error,Error,7517,"const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; vi",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:7684,Availability,error,error,7684,"r* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; vir",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:7768,Availability,error,error,7768,"idTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() const; virtual",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:28276,Availability,down,down,28276,,MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:20098,Deployability,TOGGLE,TOGGLE,20098,"SetAttLinePS(Color_t color, Style_t style, Width_t lwidth); virtual voidTPad::SetAttMarkerPS(Color_t color, Style_t style, Size_t msize); virtual voidTPad::SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); virtual voidTPad::SetBBoxCenter(const TPoint& p); virtual voidTPad::SetBBoxCenterX(const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode); virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGri",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:20353,Deployability,TOGGLE,TOGGLE,20353,"Pad::SetBBoxCenter(const TPoint& p); virtual voidTPad::SetBBoxCenterX(const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode); virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual ",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:20642,Deployability,TOGGLE,TOGGLE,20642,"BoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode); virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t valu",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:21184,Deployability,TOGGLE,TOGGLE,21184,"nt_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t value = 1); virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidSetMethod(const char* method)MENU ; virtual voidSetName(const char* name); virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:21236,Deployability,TOGGLE,TOGGLE,21236,"on_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t value = 1); virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidSetMethod(const char* method)MENU ; virtual voidSetName(const char* name); virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:21696,Deployability,TOGGLE,TOGGLE,21696," voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t value = 1); virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidSetMethod(const char* method)MENU ; virtual voidSetName(const char* name); virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidTPad::SetSelected(TObject* obj); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTex",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:23065,Deployability,TOGGLE,TOGGLE,23065," Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidTPad::SetSelected(TObject* obj); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextColorAlpha(Color_t tcolor, Float_t talpha); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:23117,Deployability,TOGGLE,TOGGLE,23117," voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidTPad::SetSelected(TObject* obj); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextColorAlpha(Color_t tcolor, Float_t talpha); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const ch",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:24284,Deployability,Update,Update,24284,"Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTPad::Update(); virtual voidTPad::UseCurrentStyle()MENU ; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidx3d(Option_t* option = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAbsPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual voidTPad::XYtoPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual Int_tTPad::YtoAbsPixel(Double_t y) const;",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:325,Integrability,interface,interface,325,". TButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TButton. class TButton: public TPad, public TAttText. A TButton object is a user interface object.; A TButton has a name and an associated action.; When the button is clicked with the left mouse button, the corresponding; action is executed.; A TButton can be created by direct invocation of the constructors; or via the graphics editor.; The action can be set via TButton::SetMethod.; The action can be any command. Examples of actions:; ""34+78"" When the button is clicked, the result of addition is printed.; "".x macro.C"" . Clicking the button executes the macro macro.C; The action can be modified at any time via TButton::SetMethod. To modify the layout/size/contents of one or several buttons; in a canvas, you must set the canvas editable via TCanvas::SetEditable.; By default a TCanvas is editable.; By default a TDialogCanvas is not editable.; TButtons are in general placed in a TDialogCanvas. A TButton being a TPad, one can draw graphics primitives in it; when the TCanvas/TDialogCanvas is editable. Example of a macro creating a dialogcanvas with buttons; void but() {; example of a dialogcanvas with a few buttons. TDialogCanvas *dialog = new TDialogCanvas(""dialog"","""",200,300);. Create first button. Clicking on this button will execute 34+56; TButton *but1 = new TButton(""button1"",""34+56"",.05,.8,.45,.88);; but1->Draw();. Create second button. Clicking on this button will create a new canvas; TButton *but2 = new TButton(""canvas"",""c2 = new TCanvas(\""c2\"")"",.55,.8,.95,.88);; but2->Draw();. Create third button. Clicking on this button will invoke the browser; but3 = new TButton(""Browser"",""br = new TBrowser(\""br\"")"",0.25,0.54,0.75,0.64);; but3->SetFillColor(42);; but3->Draw();. Create last button with no name. Instead a graph is draw insi",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:14063,Integrability,Message,Message,14063,"dTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTPad::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tTPad::OpaqueMoving() const; virtual Bool_tTPad::OpaqueResizing() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static TVirtualPad*&TVirtualPad::Pad(); virtual Bool_tTVirtualPad::PadInHighlightMode() const; virtual Bool_tTVirtualPad::PadInSelectionMode() const; virtual Double_tTPad::PadtoX(Double_t x) const; vi",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:13152,Modifiability,Inherit,InheritsFrom,13152,"h() const; virtual Double_tTPad::GetWNDC() const; virtual UInt_tTPad::GetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTPad::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voi",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:13218,Modifiability,Inherit,InheritsFrom,13218,"ad::GetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTPad::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); virtual Int_",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:33425,Modifiability,Inherit,Inheritance,33425,"fXtoAbsPixelkConversion coefficient for X World to absolute pixel; Double_tTPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. private:. Bool_tfFocusedIf cursor is in...; Bool_tfFramingTrue if you want a frame to be painted when pressed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TButton(); Button default constructor. TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Button normal constructor. Note that the button coordinates x1,y1,x2,y2 are always in the range [0,1]. ~TButton(); Button default destructor. void Draw(Option_t* option = """"); Draw this button with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a Button object is clicked. void Paint(Option_t* option = """"); Paint this button with its current attributes. void PaintModified(); Paint is modified. void Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Set world coordinate system for the pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetFraming(Bool_t f = 1); if framing is set, button will be highlighted. void Di",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:33438,Modifiability,Inherit,Inherited,33438,"fXtoAbsPixelkConversion coefficient for X World to absolute pixel; Double_tTPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. private:. Bool_tfFocusedIf cursor is in...; Bool_tfFramingTrue if you want a frame to be painted when pressed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TButton(); Button default constructor. TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Button normal constructor. Note that the button coordinates x1,y1,x2,y2 are always in the range [0,1]. ~TButton(); Button default destructor. void Draw(Option_t* option = """"); Draw this button with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a Button object is clicked. void Paint(Option_t* option = """"); Paint this button with its current attributes. void PaintModified(); Paint is modified. void Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Set world coordinate system for the pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetFraming(Bool_t f = 1); if framing is set, button will be highlighted. void Di",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:12844,Security,Hash,Hash,12844,"tUxmin() const; virtual Double_tTPad::GetUymax() const; virtual Double_tTPad::GetUymin() const; virtual TView*TPad::GetView() const; virtual TObject*TPad::GetView3D() const; virtual TVirtualViewer3D*TPad::GetViewer3D(Option_t* type = """"); virtual TVirtualPad*TPad::GetVirtCanvas() const; virtual UInt_tTPad::GetWh() const; virtual Double_tTPad::GetWNDC() const; virtual UInt_tTPad::GetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() c",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:24201,Testability,Test,TestBit,24201,"pText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTPad::Update(); virtual voidTPad::UseCurrentStyle()MENU ; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidx3d(Option_t* option = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAbsPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual voidTPad::XYtoPixel(Double_t x, Double_t y, Int",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:24240,Testability,Test,TestBits,24240,"= 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTPad::Update(); virtual voidTPad::UseCurrentStyle()MENU ; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidx3d(Option_t* option = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAbsPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual voidTPad::XYtoPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtua",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:29856,Testability,log,log,29856,"e if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarg",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:29913,Testability,log,log,29913,"2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:29970,Testability,log,log,29970,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Short_tTAttText::fTextAlignT",MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TButton.html:3647,Usability,Clear,Clear,3647,,MatchSource.WIKI,root/html604/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TButton.html
https://root.cern/root/html604/TCanvas.html:1862,Availability,avail,available,1862,"*************** *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * Pad 1 * * Pad 2 * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * ************************************ ************************* *; * *; ***********************************************************************. This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be; moved, grown, shrinked using the normal rules of the Display manager. The image below shows a canvas with 4 pads:. Once objects have been drawn in a canvas, they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, in interactive mode, the canvas size defines the size of the; canvas window (including the window manager's decoration). To define precisely; the graphics area size of a canvas, the following four lines of code should be; used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. in batch mode simply do:. c->SetCanvasSize(w,h);. . Function Members (Methods); public:. virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(Int_t px); virtual voidTPad::AbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tTPad::AbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidTPad::AddExec(const char* name, con",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:7917,Availability,Error,Error,7917,"nal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tT",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:8084,Availability,error,error,8084,"ar* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_t",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:8168,Availability,error,error,8168,"oidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; TVirtualPadPainter*Get",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:30442,Availability,down,down,30442,,MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:39719,Availability,failure,failure,39719,"itle, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of th",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:42376,Availability,down,down,42376,"anvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Res",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:21393,Deployability,TOGGLE,TOGGLE,21393,"e_t msize); virtual voidTPad::SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); virtual voidSetBatch(Bool_t batch = kTRUE); virtual voidTPad::SetBBoxCenter(const TPoint& p); virtual voidTPad::SetBBoxCenterX(const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidSetCanvasSize(UInt_t ww, UInt_t wh)MENU ; voidSetClickSelected(TObject* obj); voidSetClickSelectedPad(TPad* pad); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:21636,Deployability,TOGGLE,TOGGLE,21636,"const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidSetCanvasSize(UInt_t ww, UInt_t wh)MENU ; voidSetClickSelected(TObject* obj); voidSetClickSelectedPad(TPad* pad); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAt",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:21919,Deployability,TOGGLE,TOGGLE,21919,"::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidSetCanvasSize(UInt_t ww, UInt_t wh)MENU ; voidSetClickSelected(TObject* obj); voidSetClickSelectedPad(TPad* pad); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttL",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:22406,Deployability,TOGGLE,TOGGLE,22406," voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual void",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:22528,Deployability,TOGGLE,TOGGLE,22528,"ion = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const c",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:22580,Deployability,TOGGLE,TOGGLE,22580,"); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t x",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:23000,Deployability,TOGGLE,TOGGLE,23000,"ode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:23051,Deployability,TOGGLE,TOGGLE,23051,"e(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey ",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:23102,Deployability,TOGGLE,TOGGLE,23102,"(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TO",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:24104,Deployability,TOGGLE,TOGGLE,24104,"E ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidSetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); voidSetWindowPosition(Int_t x, Int_t y); voidSetWindowSize(UInt_t ww, UInt_t wh); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voi",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:24156,Deployability,TOGGLE,TOGGLE,24156,"at_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidSetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); voidSetWindowPosition(Int_t x, Int_t y); voidSetWindowSize(UInt_t ww, UInt_t wh); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& C",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:44426,Deployability,Toggle,Toggle,44426,"rameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use this function to zoom in a canvas and naviguate via; the scroll bars. void SetCursor(ECursor cursor); Set cursor. void SetDoubleBuffer(Int_t mode = 1); Set Double Buffer On/Off. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix canvas aspect ratio to current value if fixed is true. void SetFolder(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the p",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46124,Deployability,Toggle,ToggleAutoExec,46124,"owsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); asser",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46142,Deployability,Toggle,Toggle,46142,"owsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); asser",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46192,Deployability,Toggle,ToggleEventStatus,46192,"s. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). T",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46213,Deployability,Toggle,Toggle,46213,"s. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). T",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46242,Deployability,Toggle,ToggleToolBar,46242,"t canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46259,Deployability,Toggle,Toggle,46259,"t canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46280,Deployability,Toggle,ToggleEditor,46280,"zeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46296,Deployability,Toggle,Toggle,46296,"zeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46316,Deployability,Toggle,ToggleToolTips,46316,"he canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCan",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46334,Deployability,Toggle,Toggle,46334,"he canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCan",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46449,Deployability,Update,Update,46449,"ters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {retu",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46459,Deployability,Update,Update,46459,"ters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {retu",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46034,Energy Efficiency,allocate,allocated,46034,"r(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirt",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:14979,Integrability,Message,Message,14979,"thod, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; static TCanvas*MakeDefCanvas(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); voidMoveOpaque(Int_t set = 1); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpaqueMoving() const; virtual Bool_tOpaqueResizing() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static TVirtualPad*&TVirtualPad::Pad(); virtual Bool_tTVirtualPad::PadInHighlightMode() const; virtual Bool_tTVirtualPad::PadInSelectionMode() const; virtual Double_tTPad::PadtoX(Do",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:41476,Integrability,depend,depending,41476,":; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = ",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:14039,Modifiability,Inherit,InheritsFrom,14039,"GetXlowNDC() const; Size_tGetXsizeReal() const; Size_tGetXsizeUser() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Size_tGetYsizeReal() const; Size_tGetYsizeUser() const; Float_tTAttPad::GetYstat() const; virtual voidHandleInput(EEventType button, Int_t x, Int_t y); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; Bool_tHasMenuBar() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; static TCanvas*MakeDefCanvas(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t ",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:14105,Modifiability,Inherit,InheritsFrom,14105,"() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Size_tGetYsizeReal() const; Size_tGetYsizeUser() const; Float_tTAttPad::GetYstat() const; virtual voidHandleInput(EEventType button, Int_t x, Int_t y); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; Bool_tHasMenuBar() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; static TCanvas*MakeDefCanvas(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); voidMoveOpaque(I",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:36928,Modifiability,Inherit,Inheritance,36928,"TPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Size_tfYsizeRealCurrent size of canvas along Y in CM; Size_tfYsizeUserUser specified size of canvas along Y in CM; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tfgIsFolderIndicates if canvas can be browsed as a folder; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCanvas(Bool_t build = kTRUE); Canvas default constructor. void Constructor(); Canvas default constructor. TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); Create an embedded canvas, i.e. a canvas that is in a TGCanvas widget; which is placed in a TGFrame. This ctor is only called via the; TRootEmbeddedCanvas class. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. TCanvas(const char* name, const char* title = """", Int_t form = 1); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. form = 1 700x500 at 10,10 (set by TStyle::SetCanvasDefH,W,X,Y); form = 2 500x500 at 20,20; form = 3 500x500 at 30,30; form = 4 500x500 at 40,40; form = 5 500x500 at 50,50. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t form); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. ",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:36941,Modifiability,Inherit,Inherited,36941,"TPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Size_tfYsizeRealCurrent size of canvas along Y in CM; Size_tfYsizeUserUser specified size of canvas along Y in CM; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tfgIsFolderIndicates if canvas can be browsed as a folder; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCanvas(Bool_t build = kTRUE); Canvas default constructor. void Constructor(); Canvas default constructor. TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); Create an embedded canvas, i.e. a canvas that is in a TGCanvas widget; which is placed in a TGFrame. This ctor is only called via the; TRootEmbeddedCanvas class. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. TCanvas(const char* name, const char* title = """", Int_t form = 1); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. form = 1 700x500 at 10,10 (set by TStyle::SetCanvasDefH,W,X,Y); form = 2 500x500 at 20,20; form = 3 500x500 at 30,30; form = 4 500x500 at 40,40; form = 5 500x500 at 50,50. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t form); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. ",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:44356,Modifiability,variab,variable,44356,"cessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use this function to zoom in a canvas and naviguate via; the scroll bars. void SetCursor(ECursor cursor); Set cursor. void SetDoubleBuffer(Int_t mode = 1); Set Double Buffer On/Off. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix canvas aspect ratio to current value if fixed is true. void SetFolder(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canv",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46991,Modifiability,plugin,plugin,46991,"caling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {retur",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:42861,Performance,response time,response time,42861,"dle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. v",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:43757,Performance,response time,response time,43757,"s drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:46971,Performance,load,loaded,46971,"caling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {retur",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:13690,Security,Hash,Hash,13690,"tVirtCanvas() const; virtual UInt_tGetWh() const; UInt_tGetWindowHeight() const; Int_tGetWindowTopX(); Int_tGetWindowTopY(); UInt_tGetWindowWidth() const; virtual Double_tTPad::GetWNDC() const; virtual UInt_tGetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Size_tGetXsizeReal() const; Size_tGetXsizeUser() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Size_tGetYsizeReal() const; Size_tGetYsizeUser() const; Float_tTAttPad::GetYstat() const; virtual voidHandleInput(EEventType button, Int_t x, Int_t y); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; Bool_tHasMenuBar() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsV",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:47072,Security,Access,Access,47072," Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:25626,Testability,Test,TestBit,25626," voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static Bool_tSupportAlpha(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCanvas(Bool_t build = kTRUE); TCanvas(const char* name, const char* title = """", Int_t form = 1); TCanvas(const char* name, const char* title, Int_t ww, Int_t wh); TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); TCanvas(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleAutoExec(); virtual voidToggleEditor(); virtual voidToggleEventStatus(); virtual voidToggleToolBar(); virtual voidToggleToolTips(); virtual voidUpdate(); virtual voidUseCurrentStyle()MENU ; Bool_tUseGL() const; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTPad::x3d(Option_t* type = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Dou",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:25665,Testability,Test,TestBits,25665,"virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static Bool_tSupportAlpha(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCanvas(Bool_t build = kTRUE); TCanvas(const char* name, const char* title = """", Int_t form = 1); TCanvas(const char* name, const char* title, Int_t ww, Int_t wh); TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); TCanvas(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleAutoExec(); virtual voidToggleEditor(); virtual voidToggleEventStatus(); virtual voidToggleToolBar(); virtual voidToggleToolTips(); virtual voidUpdate(); virtual voidUseCurrentStyle()MENU ; Bool_tUseGL() const; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTPad::x3d(Option_t* type = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAb",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:32719,Testability,log,log,32719,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:32776,Testability,log,log,32776,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:32833,Testability,log,log,32833,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:47147,Testability,assert,assert,47147,"e pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() co",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:48297,Testability,Test,TestBit,48297,"se(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuB",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:48367,Testability,Test,TestBit,48367," const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() c",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:48432,Testability,Test,TestBit,48432,"textMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRe",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:48498,Testability,Test,TestBit,48498,"etDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaq",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:48562,Testability,Test,TestBit,48562,") const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeO",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:49275,Testability,Test,TestBit,49275,"EventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeOpaque); }. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); { return TPad::Pick(px, py, pickobj); }. void RaiseWindow(); { fCanvasImp->RaiseWindow(); }. void SetWindowPosition(Int_t x, Int_t y); { fCanvasImp->SetWindowPosition(x, y); }. void SetWindowSize(UInt_t ww, UInt_t wh); { fCanvasImp->SetWindowSize(ww, wh); }. void SetHighLightColor(Color_t col); { fHighLightColor = col; }. void SetClickSelected(TObject* obj); { fClickSelected = obj; }. void SetSelectedPad(TPad* pad); { fSelectedPad = pad; }. void SetClickSelectedPad(TPad* pad); { fClickSelectedPad = pad; }. void Show(); { fCanvasImp->Show(); }. void SetPadSave(TPad* pad); {fPadSave = pad;}. void SetRetained(Bool_t retained = kTRUE); { fRetain",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:49473,Testability,Test,TestBit,49473,"etShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeOpaque); }. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); { return TPad::Pick(px, py, pickobj); }. void RaiseWindow(); { fCanvasImp->RaiseWindow(); }. void SetWindowPosition(Int_t x, Int_t y); { fCanvasImp->SetWindowPosition(x, y); }. void SetWindowSize(UInt_t ww, UInt_t wh); { fCanvasImp->SetWindowSize(ww, wh); }. void SetHighLightColor(Color_t col); { fHighLightColor = col; }. void SetClickSelected(TObject* obj); { fClickSelected = obj; }. void SetSelectedPad(TPad* pad); { fSelectedPad = pad; }. void SetClickSelectedPad(TPad* pad); { fClickSelectedPad = pad; }. void Show(); { fCanvasImp->Show(); }. void SetPadSave(TPad* pad); {fPadSave = pad;}. void SetRetained(Bool_t retained = kTRUE); { fRetained=retained;}. Bool_t UseGL() const; { return fUseGL; }. void SetSupportGL(Bool_t support); {fUseGL = support;}. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:49538,Testability,Test,TestBit,49538,"t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeOpaque); }. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); { return TPad::Pick(px, py, pickobj); }. void RaiseWindow(); { fCanvasImp->RaiseWindow(); }. void SetWindowPosition(Int_t x, Int_t y); { fCanvasImp->SetWindowPosition(x, y); }. void SetWindowSize(UInt_t ww, UInt_t wh); { fCanvasImp->SetWindowSize(ww, wh); }. void SetHighLightColor(Color_t col); { fHighLightColor = col; }. void SetClickSelected(TObject* obj); { fClickSelected = obj; }. void SetSelectedPad(TPad* pad); { fSelectedPad = pad; }. void SetClickSelectedPad(TPad* pad); { fClickSelectedPad = pad; }. void Show(); { fCanvasImp->Show(); }. void SetPadSave(TPad* pad); {fPadSave = pad;}. void SetRetained(Bool_t retained = kTRUE); { fRetained=retained;}. Bool_t UseGL() const; { return fUseGL; }. void SetSupportGL(Bool_t support); {fUseGL = support;}. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-06-02 1",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:2469,Usability,simpl,simply,2469,"they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, in interactive mode, the canvas size defines the size of the; canvas window (including the window manager's decoration). To define precisely; the graphics area size of a canvas, the following four lines of code should be; used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. in batch mode simply do:. c->SetCanvasSize(w,h);. . Function Members (Methods); public:. virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(Int_t px); virtual voidTPad::AbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tTPad::AbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidTPad::AddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTPad::AutoExec(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); virtual TLegend*TPad::BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """")MENU ; virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:39786,Usability,Clear,Clear,39786," top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse ",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:39903,Usability,clear,cleared,39903," ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu i",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:40005,Usability,Clear,Cleared,40005,"ive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected)",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:40041,Usability,Clear,Cleared,40041,"ive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected)",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:41930,Usability,Feedback,FeedbackMode,41930,"id DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TOb",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:41972,Usability,feedback,feedback,41972,"id DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TOb",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvas.html:47800,Usability,Clear,ClearPadSave,47800,"a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const",MatchSource.WIKI,root/html604/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvas.html
https://root.cern/root/html604/TCanvasImp.html:2006,Modifiability,Inherit,Inheritance,2006,"indowPosition(Int_t x, Int_t y); virtual voidSetWindowSize(UInt_t w, UInt_t h); virtual voidSetWindowTitle(const char* newTitle); virtual voidShow(); virtual voidShowEditor(Bool_t show = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowMenuBar(Bool_t show = kTRUE); virtual voidShowStatusBar(Bool_t show = kTRUE); virtual voidShowToolBar(Bool_t show = kTRUE); virtual voidShowToolTips(Bool_t show = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TCanvasImp(TCanvas* c = 0); TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height). protected:. virtual Bool_tIsLocked(); virtual voidLock(); TCanvasImp&operator=(const TCanvasImp& ci); TCanvasImp(const TCanvasImp& ci); virtual voidUnlock(). Data Members; protected:. TCanvas*fCanvasTCanvas associated with this implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); { }. inline TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height); { }. UInt_t GetWindowGeometry(Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); { x = y = 0; w = h = 0; return 0;}. void SetStatusText(const char* text = 0, Int_t partidx = 0); { }. void SetWindowPosition(Int_t x, Int_t y); { }. void SetWindowSize(UInt_t w, UInt_t h); { }. void SetWindowTitle(const char* newTitle); { }. void SetCanvasSize(UInt_t w, UInt_t h); { }. void ShowMenuBar(Bool_t show = kTRUE); { }. void ShowStatusBar(Bool_t show = kTRUE); { }. void RaiseWindow(); { }. void ReallyDelete(); { }. void ShowEditor(Bool_t show = kTRUE); { }. void ShowToolBar(Bool_t show = kTRUE); { }. void ShowToolTips(Bool_t show = kTRUE); { }. TCanvasImp(const TCanvasImp& ci); { }. TCanvasImp& operator=(const TCanvasImp& ci); {if(this!=&ci) fCanvas=ci.fCanvas; return *this;}. vo",MatchSource.WIKI,root/html604/TCanvasImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvasImp.html
https://root.cern/root/html604/TCanvasImp.html:2019,Modifiability,Inherit,Inherited,2019,"indowPosition(Int_t x, Int_t y); virtual voidSetWindowSize(UInt_t w, UInt_t h); virtual voidSetWindowTitle(const char* newTitle); virtual voidShow(); virtual voidShowEditor(Bool_t show = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowMenuBar(Bool_t show = kTRUE); virtual voidShowStatusBar(Bool_t show = kTRUE); virtual voidShowToolBar(Bool_t show = kTRUE); virtual voidShowToolTips(Bool_t show = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TCanvasImp(TCanvas* c = 0); TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height). protected:. virtual Bool_tIsLocked(); virtual voidLock(); TCanvasImp&operator=(const TCanvasImp& ci); TCanvasImp(const TCanvasImp& ci); virtual voidUnlock(). Data Members; protected:. TCanvas*fCanvasTCanvas associated with this implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); { }. inline TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height); { }. UInt_t GetWindowGeometry(Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); { x = y = 0; w = h = 0; return 0;}. void SetStatusText(const char* text = 0, Int_t partidx = 0); { }. void SetWindowPosition(Int_t x, Int_t y); { }. void SetWindowSize(UInt_t w, UInt_t h); { }. void SetWindowTitle(const char* newTitle); { }. void SetCanvasSize(UInt_t w, UInt_t h); { }. void ShowMenuBar(Bool_t show = kTRUE); { }. void ShowStatusBar(Bool_t show = kTRUE); { }. void RaiseWindow(); { }. void ReallyDelete(); { }. void ShowEditor(Bool_t show = kTRUE); { }. void ShowToolBar(Bool_t show = kTRUE); { }. void ShowToolTips(Bool_t show = kTRUE); { }. TCanvasImp(const TCanvasImp& ci); { }. TCanvasImp& operator=(const TCanvasImp& ci); {if(this!=&ci) fCanvas=ci.fCanvas; return *this;}. vo",MatchSource.WIKI,root/html604/TCanvasImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCanvasImp.html
https://root.cern/root/html604/TChain.html:5174,Availability,Error,Error,5174,"n_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:5303,Availability,error,error,5303,", Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const;",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:5387,Availability,error,error,5387,"ve(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tGetBranchStatus(const char* branchname) const; static Int_tTTree::Get",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:39707,Availability,error,error,39707," closing a file during the chain processing, the file; may be closed with option ""R"" if flag is set to kTRUE.; by default flag is kTRUE.; When closing a file with option ""R"", all TProcessIDs referenced by this; file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator ",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:40144,Availability,error,error,40144,"being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the of",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:41410,Availability,failure,failure,41410,"t; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the curren",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:42590,Availability,failure,failure,42590,"try list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all b",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:43933,Availability,error,error,43933,"branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:51111,Availability,error,error,51111,"presses the search for the url fragment; identifier and limits the query identifier search to cases; where the tree name is given as a trailing slash-separated; string at the end of the file name.; Outpus:; filename - the url or filename to be opened or matched; treename - the treename, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be empty.; suffix - the portion of name which was removed to form filename. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If var",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:51394,Availability,error,error,51394,"ame, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be empty.; suffix - the portion of name which was removed to form filename. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; ",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:52700,Availability,error,error,52700,"tion_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. Int_t SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize.; Returns 0 cache state ok (exists or not, as appropriate); -1 on error. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; d",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:54613,Availability,error,error,54613,"c of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); -- Set branch status to Process or DoNotProcess. bname is the name of a branch. if bname=""*"", apply to all branches.; status = 1 branch will be processed; = 0 branch will not be processed; See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of ent",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:55744,Availability,error,error,55744,"irectory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() functi",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:16818,Deployability,update,updateExisting,16818,"= 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tSetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLin",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:58382,Deployability,Release,ReleaseChainProof,58382,"E the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used with; care because it may take a long time to execute. void SetWeight(Double_t w = 1, Option_t* option = """"); -- Set chain weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram.; For example the equivalent of; chain.Draw(""x"",""w""); is; chain.SetWeight(w,""global"");; chain.Draw(""x"");. By default the weight used will be the weight; of each Tree in the TChain. However, one can force the individual; weights to be ignored by specifying the option ""global"".; In this case, the TChain global weight will be used for all Trees. void Streamer(TBuffer& ); -- Stream a class object. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); -- Dummy function kept for back compatibility.; The cache is now activated automatically when processing TTrees/TChain. TChain(const TChain& ). TChain& operator=(const TChain& ). void ReleaseChainProof(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0). Int_t Fill(); { MayNotUse(""Fill()""); return -1; }. Long64_t GetCacheSize() const; { return fTree ? fTree->GetCacheSize() : fCacheSize; }. Int_t GetNtrees() const; { return fNtrees; }. Long64_t GetEntries() const. TObjArray * GetListOfFiles() const; Warning, GetListOfFiles returns the list of TChainElements (not the list of files); see TChain::AddFile to see how to get the corresponding TFile objects. {return fFiles;}. TList * GetStatus() const; { return fStatus; }. TTree * GetTree() const; { return fTree; }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Long64_t * GetTreeOffset() const; { return fTreeOffset; }. Int_t GetTreeOffsetLen() const; { return fTreeOffsetLen; }. void SetMakeClass(Int_t make); { TTree::SetMakeClass(make); if (fTree) fTree->SetMakeClass(make);}. » Author: Rene Brun 03/02/97 » Copyright (C) 1995-2000, Rene ",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:26629,Energy Efficiency,allocate,allocated,26629,"entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); TFile*fFile! Pointer to current file (We own the file).; Int_tTTree::fFileNumber! current file number (if file extensions); TObjArray*fFiles-> List of file names containing the trees (TChainElement, owned); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; In",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:32596,Energy Efficiency,efficient,efficient,32596,"an contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be connected to read an entry.; This option is the default and very efficient if one process; the chain sequentially. Note that in case TChain::GetEntry(entry); is called and entry refers to an entry in the 3rd file, for example,; this forces the Tree headers in the first and second file; to be read to find the number of entries in these files.; Note that if one calls TChain::GetEntriesFast() after having created; a chain with this default, GetEntriesFast will return kBigNumber!; TChain::GetEntries will force of the Tree headers in the chain to be; read to read the number of entries in each Tree. D- The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:35298,Energy Efficiency,efficient,efficient,35298,"l fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. Note that if one calls GetEntriesFast() after having created; a chain with this default, GetEntriesFast() will return kBigNumber!; Using the GetEntries() function instead will force all of the tree; headers in the chain to be read to read the number of entries in; each tree. D. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. The function returns 1 if the file is successfully",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:31524,Integrability,depend,depending,31524,")) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file name, eg. specifying ""xxx*.root"" adds; all files starting with xxx in the current file system directory. Alternatively name may have the format of a url, eg.; root://machine/path/file_name.root; or root://machine/path/file_name.root/tree_name; or root://machine/path/file_name.root/tree_name?query. where ""query"" is to be interpreted by the remote server. Wildcards may be; supported in urls, depending on the protocol plugin and the remote server.; http or https urls can contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be co",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:31541,Integrability,protocol,protocol,31541,")) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file name, eg. specifying ""xxx*.root"" adds; all files starting with xxx in the current file system directory. Alternatively name may have the format of a url, eg.; root://machine/path/file_name.root; or root://machine/path/file_name.root/tree_name; or root://machine/path/file_name.root/tree_name?query. where ""query"" is to be interpreted by the remote server. Wildcards may be; supported in urls, depending on the protocol plugin and the remote server.; http or https urls can contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be co",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:42534,Integrability,rout,routine,42534,"set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); --",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:44307,Integrability,rout,routine,44307,"ning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will have not subdirectory. To recreate; the directory structure do:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.M",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:45055,Integrability,rout,routine,45055,"e requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will have not subdirectory. To recreate; the directory structure do:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. Long64_t Merge(TCollection* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is s",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:46550,Integrability,rout,routine,46550,"nfo); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _l",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:49601,Integrability,depend,depends,49601,"fast mode, the check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in general the automatic file overflow described; above may happen during the merge.; If only the current file is produced (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void ParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; -- Get the tree url or filename and other information from the name. A treename and a url's query section is split off from name. The; splitting depends on whether the resulting filename is to be; subsequently treated for wildcards or not, since the question mark is; both the url query identifier and a wildcard. Wildcard matching is not; done in this method itself. /a/path/file.root[/treename]; xxx://a/path/file.root[/treename][?query]; xxx://a/path/file.root[?query[#treename]]. Inputs:; name - is the original name; wildcards - indicates if the resulting filename will be treated for; wildcards. For backwards compatibility, with most protocols; this flag suppresses the search for the url fragment; identifier and limits the query identifier search to cases; where the tree name is given as a trailing slash-separated; string at the end of the file name.; Outpus:; filename - the url or filename to be opened or matched; treename - the treename, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be e",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:50097,Integrability,protocol,protocols,50097,"en merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void ParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; -- Get the tree url or filename and other information from the name. A treename and a url's query section is split off from name. The; splitting depends on whether the resulting filename is to be; subsequently treated for wildcards or not, since the question mark is; both the url query identifier and a wildcard. Wildcard matching is not; done in this method itself. /a/path/file.root[/treename]; xxx://a/path/file.root[/treename][?query]; xxx://a/path/file.root[?query[#treename]]. Inputs:; name - is the original name; wildcards - indicates if the resulting filename will be treated for; wildcards. For backwards compatibility, with most protocols; this flag suppresses the search for the url fragment; identifier and limits the query identifier search to cases; where the tree name is given as a trailing slash-separated; string at the end of the file name.; Outpus:; filename - the url or filename to be opened or matched; treename - the treename, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be empty.; suffix - the portion of name which was removed to form filename. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:54619,Integrability,message,message,54619,"c of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); -- Set branch status to Process or DoNotProcess. bname is the name of a branch. if bname=""*"", apply to all branches.; status = 1 branch will be processed; = 0 branch will not be processed; See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of ent",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:10847,Modifiability,Inherit,InheritsFrom,10847,"t size); virtual TTree*GetTree() const; virtual TVirtualIndex*TTree::GetTreeIndex() const; virtual Int_tGetTreeNumber() const; Long64_t*GetTreeOffset() const; Int_tGetTreeOffsetLen() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofil",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:10913,Modifiability,Inherit,InheritsFrom,10913,"e::GetTreeIndex() const; virtual Int_tGetTreeNumber() const; Long64_t*GetTreeOffset() const; Int_tGetTreeOffsetLen() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, In",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:28270,Modifiability,variab,variables,28270,"er interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTreeNumber! Current Tree number in fTreeOffset table; Long64_t*fTreeOffset[fTreeOffsetLen] Array of variables; Int_tfTreeOffsetLenCurrent size of fTreeOffset array; Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new elem",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:29386,Modifiability,Inherit,Inheritance,29386,"nter to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(""f3.root"");; ch.Draw(""x"");; The Draw function above will process the variable ""x"" in Tree ""T""; reading sequentially the 3 files in the chain ch. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileEle",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:29399,Modifiability,Inherit,Inherited,29399,"nter to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(""f3.root"");; ch.Draw(""x"");; The Draw function above will process the variable ""x"" in Tree ""T""; reading sequentially the 3 files in the chain ch. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileEle",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:30120,Modifiability,variab,variable,30120,"tatic TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(""f3.root"");; ch.Draw(""x"");; The Draw function above will process the variable ""x"" in Tree ""T""; reading sequentially the 3 files in the chain ch. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file ",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:31550,Modifiability,plugin,plugin,31550,")) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file name, eg. specifying ""xxx*.root"" adds; all files starting with xxx in the current file system directory. Alternatively name may have the format of a url, eg.; root://machine/path/file_name.root; or root://machine/path/file_name.root/tree_name; or root://machine/path/file_name.root/tree_name?query. where ""query"" is to be interpreted by the remote server. Wildcards may be; supported in urls, depending on the protocol plugin and the remote server.; http or https urls can contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be co",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:37395,Modifiability,variab,variable,37395," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:37626,Modifiability,variab,variable,37626,"dElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the c",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:37675,Modifiability,variab,variable,37675,"dElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the c",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:37785,Modifiability,variab,variable,37785,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:37825,Modifiability,variab,variable,37825,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:37857,Modifiability,variab,variable,37857,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:11419,Performance,Load,LoadTreeFriend,11419,"Var2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tMerge(const char* name, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, TFileMergeInfo* info); virtual Long64_tMerge(TFile* file, Int_t basketsize, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:12980,Performance,Optimiz,OptimizeBaskets,12980,") const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tMerge(const char* name, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, TFileMergeInfo* info); virtual Long64_tMerge(TFile* file, Int_t basketsize, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:16530,Performance,cache,cacheSize,16530,"const char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tSetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTA",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:22000,Performance,cache,cacheSize,22000,"ar* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidInvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TChain&operator=(const TChain&); voidParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; TChain(const TChain&). Data ",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:24453,Performance,cache,cache,24453,"ect::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TChain::(anonymous)kProofLite; static TChain::(anonymous)kProofUptodate; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Bool_tfCanDeleteRefs! If true, TProcessIDs are deleted when closing a file; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:24597,Performance,cache,cache,24597,"ect::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TChain::(anonymous)kProofLite; static TChain::(anonymous)kProofUptodate; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Bool_tfCanDeleteRefs! If true, TProcessIDs are deleted when closing a file; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:27114,Performance,load,loading,27114,"h_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TList*fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTreeNumber! Current Tree number in fTreeOffset table; Long64_t*fTreeOffset[fTreeOffsetLen] Array of variables; Int_tfTreeOffsetLenCurrent size of fTreeOffset array; Int_tTT",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:34464,Performance,load,load,34464,"El=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. Filename formats are similar to TChain::Add. Wildcards are not; applied. urls may also contain query and fragment identifiers; where the tree name can be specified in the url fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in th",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:34541,Performance,load,load,34541,"ng the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. Filename formats are similar to TChain::Add. Wildcards are not; applied. urls may also contain query and fragment identifiers; where the tree name can be specified in the url fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. N",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:41640,Performance,load,loads,41640," branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 o",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:42169,Performance,load,loaded,42169,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. ",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:43496,Performance,Load,LoadBaskets,43496,"TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTR",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:43577,Performance,load,load,43577,"s 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """"",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:43670,Performance,Load,LoadBasket,43670,"f leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentrie",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:43714,Performance,Load,LoadTree,43714,"r* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:43940,Performance,Load,LoadTree,43940,"branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:46343,Performance,Load,Load,46343,"ion* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. th",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:47646,Performance,optimiz,optimize,47646,"ure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only don",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:47842,Performance,perform,performance,47842,"'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in genera",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:52353,Performance,Load,LoadTree,52353," case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. Int_t SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize.; Returns 0 cache state ok (exists or not, as appropriate); -1 on error. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bnam",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:52362,Performance,load,loads,52362," case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. Int_t SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize.; Returns 0 cache state ok (exists or not, as appropriate); -1 on error. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bnam",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:52548,Performance,cache,cacheSize,52548,"his TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. Int_t SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize.; Returns 0 cache state ok (exists or not, as appropriate); -1 on error. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the seman",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:52573,Performance,cache,cache,52573,"his TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. Int_t SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize.; Returns 0 cache state ok (exists or not, as appropriate); -1 on error. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the seman",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:52646,Performance,cache,cache,52646,"tion_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. Int_t SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize.; Returns 0 cache state ok (exists or not, as appropriate); -1 on error. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; d",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:55620,Performance,load,loads,55620,"nown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned b",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:55819,Performance,load,loaded,55819,"irectory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() functi",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:56438,Performance,load,loads,56438,"to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() function is called, the TEntryList is not owned by the chain; any more and will not be deleted with it. void SetPacketSize(Int_t size = 100); -- Set number of entries per packet for parallel root. void SetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); Enable/Disable PROOF processing on the current default Proof (gProof). ""Draw"" and ""Processed"" commands will be handled by PROOF.; The refresh and gettreeheader are meaningfull only if on == kTRUE.; If refresh is kTRUE the underlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used wit",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:58250,Performance,cache,cache,58250,"underlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used with; care because it may take a long time to execute. void SetWeight(Double_t w = 1, Option_t* option = """"); -- Set chain weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram.; For example the equivalent of; chain.Draw(""x"",""w""); is; chain.SetWeight(w,""global"");; chain.Draw(""x"");. By default the weight used will be the weight; of each Tree in the TChain. However, one can force the individual; weights to be ignored by specifying the option ""global"".; In this case, the TChain global weight will be used for all Trees. void Streamer(TBuffer& ); -- Stream a class object. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); -- Dummy function kept for back compatibility.; The cache is now activated automatically when processing TTrees/TChain. TChain(const TChain& ). TChain& operator=(const TChain& ). void ReleaseChainProof(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0). Int_t Fill(); { MayNotUse(""Fill()""); return -1; }. Long64_t GetCacheSize() const; { return fTree ? fTree->GetCacheSize() : fCacheSize; }. Int_t GetNtrees() const; { return fNtrees; }. Long64_t GetEntries() const. TObjArray * GetListOfFiles() const; Warning, GetListOfFiles returns the list of TChainElements (not the list of files); see TChain::AddFile to see how to get the corresponding TFile objects. {return fFiles;}. TList * GetStatus() const; { return fStatus; }. TTree * GetTree() const; { return fTree; }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Long64_t * GetTreeOffset() const; { return fTreeOffset; }. Int_t GetTreeOffsetLen() const; { return fTreeOffsetLen; }. void SetMakeClass(Int_t make); { TTree::SetMakeClass(",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:10681,Security,Hash,Hash,10681,"tual Int_tTTree::GetTimerInterval() const; virtual const char*TNamed::GetTitle() const; virtual Long64_tTTree::GetTotBytes() const; TBuffer*TTree::GetTransientBuffer(Int_t size); virtual TTree*GetTree() const; virtual TVirtualIndex*TTree::GetTreeIndex() const; virtual Int_tGetTreeNumber() const; Long64_t*GetTreeOffset() const; Int_tGetTreeOffsetLen() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:37381,Security,access,access,37381," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:19812,Testability,Test,TestBit,19812,"(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTree::SetNotify(TObject* obj); virtual voidTTree::SetObject(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidTTree::SetParallelUnzip(Bool_t opt = kTRUE, Float_t RelSize = -1); virtual voidTTree::SetPerfStats(TVirtualPerfStats* perf); virtual voidSetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); virtual voidTTree::SetScanField(Int_t n = 50)MENU ; virtual voidTTree::SetTimerInterval(Int_t msec = 333); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTTree::SetTreeIndex(TVirtualIndex* index); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTTree::SetUpdate(Int_t freq = 0); virtual voidSetWeight(Double_t w = 1, Option_t* option = """"); virtual voidTTree::Show(Long64_t entry = -1, Int_t lenmax = 20); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTTree::StartViewer()MENU ; virtual Int_tTTree::StopCacheLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChain(); TChain(const char* name, const char* title = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidUseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); virtual voidTTree::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:19851,Testability,Test,TestBits,19851,"(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTree::SetNotify(TObject* obj); virtual voidTTree::SetObject(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidTTree::SetParallelUnzip(Bool_t opt = kTRUE, Float_t RelSize = -1); virtual voidTTree::SetPerfStats(TVirtualPerfStats* perf); virtual voidSetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); virtual voidTTree::SetScanField(Int_t n = 50)MENU ; virtual voidTTree::SetTimerInterval(Int_t msec = 333); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTTree::SetTreeIndex(TVirtualIndex* index); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTTree::SetUpdate(Int_t freq = 0); virtual voidSetWeight(Double_t w = 1, Option_t* option = """"); virtual voidTTree::Show(Long64_t entry = -1, Int_t lenmax = 20); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTTree::StartViewer()MENU ; virtual Int_tTTree::StopCacheLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChain(); TChain(const char* name, const char* title = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidUseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); virtual voidTTree::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:46291,Testability,test,test,46291,"E"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. Long64_t Merge(TCollection* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are wri",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:3473,Usability,Clear,Clear,3473,"ddobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const ch",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChain.html:3797,Usability,undo,undo,3797,"nchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root/html604/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChain.html
https://root.cern/root/html604/TChainElement.html:1226,Availability,Error,Error,1226," virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:1355,Availability,error,error,1355," virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:1439,Availability,error,error,1439,"nst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const ",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:7025,Deployability,update,updated,7025,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:2734,Modifiability,Inherit,InheritsFrom,2734,"st TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tHasBeenLookedUp(); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* ",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:2800,Modifiability,Inherit,InheritsFrom,2800,"const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tHasBeenLookedUp(); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainElement&operator=(const TChainElement&); virtual voidTO",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:7461,Modifiability,Inherit,Inheritance,7461,"BitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassName() const; { return fBaddressClassName; }. Bool_t GetBaddressIsPtr() const; { return fBaddressIsPtr; }. UInt_t GetBaddressType() const; { return fBaddressType; }. TBranch ** GetBranchPtr() const; { return fBranchPtr; }. Long64_t GetEntries() const; {return fEntries;}. char * GetPackets() const; {return fPackets;}. Int_t GetPacketSize() const; {return fPacketSize;}. Int_t ",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:7474,Modifiability,Inherit,Inherited,7474,"BitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassName() const; { return fBaddressClassName; }. Bool_t GetBaddressIsPtr() const; { return fBaddressIsPtr; }. UInt_t GetBaddressType() const; { return fBaddressType; }. TBranch ** GetBranchPtr() const; { return fBranchPtr; }. Long64_t GetEntries() const; {return fEntries;}. char * GetPackets() const; {return fPackets;}. Int_t GetPacketSize() const; {return fPacketSize;}. Int_t ",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:7038,Performance,load,loading,7038,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:2624,Security,Hash,Hash,2624,"ar*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tHasBeenLookedUp(); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:5450,Testability,Test,TestBit,5450,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetBaddress(void* add); virtual voidSetBaddressClassName(const char* clname); virtual voidSetBaddressIsPtr(Bool_t isptr); virtual voidSetBaddressType(UInt_t type); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBranchPtr(TBranch** ptr); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLookedUp(Bool_t y = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberEntries(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidSetStatus(Int_t status); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainElement(); TChainElement(const TChainElement&); TChainElement(const char* title, const char* filename); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:5489,Testability,Test,TestBits,5489,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetBaddress(void* add); virtual voidSetBaddressClassName(const char* clname); virtual voidSetBaddressIsPtr(Bool_t isptr); virtual voidSetBaddressType(UInt_t type); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBranchPtr(TBranch** ptr); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLookedUp(Bool_t y = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberEntries(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidSetStatus(Int_t status); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainElement(); TChainElement(const TChainElement&); TChainElement(const char* title, const char* filename); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:8560,Testability,Test,TestBit,8560,"ch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassName() const; { return fBaddressClassName; }. Bool_t GetBaddressIsPtr() const; { return fBaddressIsPtr; }. UInt_t GetBaddressType() const; { return fBaddressType; }. TBranch ** GetBranchPtr() const; { return fBranchPtr; }. Long64_t GetEntries() const; {return fEntries;}. char * GetPackets() const; {return fPackets;}. Int_t GetPacketSize() const; {return fPacketSize;}. Int_t GetStatus() const; {return fStatus;}. Bool_t HasBeenLookedUp(); { return TestBit(kHasBeenLookedUp); }. void SetBaddress(void* add); {fBaddress = add;}. void SetBaddressClassName(const char* clname); { fBaddressClassName = clname; }. void SetBaddressIsPtr(Bool_t isptr); { fBaddressIsPtr = isptr; }. void SetBaddressType(UInt_t type); { fBaddressType = type; }. void SetBranchPtr(TBranch** ptr); { fBranchPtr = ptr; }. void SetNumberEntries(Long64_t n); {fEntries=n;}. void SetStatus(Int_t status); {fStatus = status;}. » Author: Rene Brun 11/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainElement.html:654,Usability,Clear,Clear,654," virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root/html604/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainElement.html
https://root.cern/root/html604/TChainIndex.html:1235,Availability,Error,Error,1235," virtual~TChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; ",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:1364,Availability,error,error,1364,"ChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() con",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:1448,Availability,error,error,1448,"end(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:8462,Deployability,release,released,8462,"ex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaL",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:8477,Deployability,Release,ReleaseSubTreeIndex,8477,"ex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaL",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:8506,Deployability,Release,ReleaseSubTreeIndex,8506,"in.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the p",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:8569,Deployability,Release,Releases,8569,"in.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the p",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:9451,Deployability,Update,UpdateFormulaLeaves,9451,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:9493,Deployability,Update,Updates,9493,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:2881,Modifiability,Inherit,InheritsFrom,2881,"erFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:2947,Modifiability,Inherit,InheritsFrom,2947,"estIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainIndex&operator=(const TChainIndex&); virtual vo",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:7228,Modifiability,Inherit,Inheritance,7228," static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. vector<TChainIndex::TChainIndexEntry>fEntriesdescriptions of indices of trees in the chain.; TTreeFormula*fMajorFormulaParent! Pointer to major TreeFormula in Parent tree (if any); TStringfMajorNameIndex major name; TTreeFormula*fMinorFormulaParent! Pointer to minor TreeFormula in Parent tree (if any); TStringfMinorNameIndex minor name; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*TVirtualIndex::fTree! pointer to Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainIndex(); Default constructor for TChainIndex. TChainIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TChainIndex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a ",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:7241,Modifiability,Inherit,Inherited,7241," static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. vector<TChainIndex::TChainIndexEntry>fEntriesdescriptions of indices of trees in the chain.; TTreeFormula*fMajorFormulaParent! Pointer to major TreeFormula in Parent tree (if any); TStringfMajorNameIndex major name; TTreeFormula*fMinorFormulaParent! Pointer to minor TreeFormula in Parent tree (if any); TStringfMinorNameIndex minor name; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*TVirtualIndex::fTree! pointer to Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainIndex(); Default constructor for TChainIndex. TChainIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TChainIndex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a ",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:9541,Performance,Load,LoadTree,9541,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:2771,Security,Hash,Hash,2771,"virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:5267,Testability,Test,TestBit,5267,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainIndex&operator=(const TChainIndex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainIndex(); TChainIndex(const TChainIndex&); TChainIndex(const TTree* T, const char* majorname, const char* minorname); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:5306,Testability,Test,TestBits,5306,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainIndex&operator=(const TChainIndex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainIndex(); TChainIndex(const TChainIndex&); TChainIndex(const TTree* T, const char* majorname, const char* minorname); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex.html:692,Usability,Clear,Clear,692," virtual~TChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; ",MatchSource.WIKI,root/html604/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex.html
https://root.cern/root/html604/TChainIndex__TChainIndexEntry.html:1362,Modifiability,Inherit,Inheritance,1362,"h. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TChainIndex::TChainIndexEntry. class TChainIndex::TChainIndexEntry. A Chain Index. Function Members (Methods); public:. ~TChainIndexEntry(); TChainIndex::TChainIndexEntry::IndexValPair_tGetMaxIndexValPair() const; TChainIndex::TChainIndexEntry::IndexValPair_tGetMinIndexValPair() const; TChainIndex::TChainIndexEntry&operator=(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntry&operator=(TChainIndex::TChainIndexEntry&&); voidSetMinMaxFrom(const TTreeIndex* index); TChainIndex::TChainIndexEntryTChainIndexEntry(); TChainIndex::TChainIndexEntryTChainIndexEntry(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntryTChainIndexEntry(TChainIndex::TChainIndexEntry&&). Data Members; public:. Long64_tfMaxIndexValMinorthe maximum value of the index (lower bits); Long64_tfMaxIndexValuethe maximum value of the index (upper bits); Long64_tfMinIndexValMinorthe minimum value of the index (lower bits); Long64_tfMinIndexValuethe minimum value of the index (upper bits); TVirtualIndex*fTreeIndexthe tree index in case it was created in the constructor,. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetMinMaxFrom(const TTreeIndex* index). TChainIndexEntry(); holds a description of indices of trees in the chain. {}. IndexValPair_t GetMinIndexValPair() const; { return IndexValPair_t(fMinIndexValue, fMinIndexValMinor); }. IndexValPair_t GetMaxIndexValPair() const; { return IndexValPair_t(fMaxIndexValue, fMaxIndexValMinor); }. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChainIndex__TChainIndexEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex__TChainIndexEntry.html
https://root.cern/root/html604/TChainIndex__TChainIndexEntry.html:1375,Modifiability,Inherit,Inherited,1375,"h. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TChainIndex::TChainIndexEntry. class TChainIndex::TChainIndexEntry. A Chain Index. Function Members (Methods); public:. ~TChainIndexEntry(); TChainIndex::TChainIndexEntry::IndexValPair_tGetMaxIndexValPair() const; TChainIndex::TChainIndexEntry::IndexValPair_tGetMinIndexValPair() const; TChainIndex::TChainIndexEntry&operator=(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntry&operator=(TChainIndex::TChainIndexEntry&&); voidSetMinMaxFrom(const TTreeIndex* index); TChainIndex::TChainIndexEntryTChainIndexEntry(); TChainIndex::TChainIndexEntryTChainIndexEntry(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntryTChainIndexEntry(TChainIndex::TChainIndexEntry&&). Data Members; public:. Long64_tfMaxIndexValMinorthe maximum value of the index (lower bits); Long64_tfMaxIndexValuethe maximum value of the index (upper bits); Long64_tfMinIndexValMinorthe minimum value of the index (lower bits); Long64_tfMinIndexValuethe minimum value of the index (upper bits); TVirtualIndex*fTreeIndexthe tree index in case it was created in the constructor,. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetMinMaxFrom(const TTreeIndex* index). TChainIndexEntry(); holds a description of indices of trees in the chain. {}. IndexValPair_t GetMinIndexValPair() const; { return IndexValPair_t(fMinIndexValue, fMinIndexValMinor); }. IndexValPair_t GetMaxIndexValPair() const; { return IndexValPair_t(fMaxIndexValue, fMaxIndexValMinor); }. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChainIndex__TChainIndexEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChainIndex__TChainIndexEntry.html
https://root.cern/root/html604/TChair.html:1956,Availability,Error,Error,1956," virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Opti",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:2085,Availability,error,error,2085,"(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*GetArray() const; v",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:2169,Availability,error,error,2169,"onst; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::Get",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:14830,Deployability,Update,Update,14830,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}. » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:14857,Deployability,Update,Update,14857,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}. » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:14874,Deployability,Update,Update,14874,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}. » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:14930,Deployability,Update,Update,14930,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}. » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:327,Integrability,interface,interface,327,". TChair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TChair. class TChair: public TDataSet. TChair. It is a base class to create a custom interface for TTable objects. Function Members (Methods); public:. virtual~TChair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual voidAddAt(TDataSet* dataset, Int_t idx); virtual voidAddAt(const void* c, Int_t i); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:4287,Modifiability,Inherit,InheritsFrom,4287,":GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainSet(); TObject*TDataSet::GetMother() const; virtual const char*TNamed::GetName() const; virtual Long_tGetNRows() const; TObjArray*TDataSet::GetObjArray() const; virtual TObject*TDataSet::GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TDataSet*TDataSet::GetParent() const; virtual TClass*GetRowClass() const; virtual TTableDescriptor*GetRowDescriptors() const; virtual Long_tGetRowSize() const; virtual Long_tGetTableSize() const; virtual const char*TNamed::GetTitle() const; virtual const Char_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Long_tHasData() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual TDataSet*TDataSet::Instance() const; static TDataSet*TDataSet::instance(); voidTDataSet::InvertAllMarks()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTDataSet::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tTDataSet::IsMarked() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDataSet::IsThisDir(const char* dirname, int len = -1, int ignorecase = 0) const; Bool_tTObject::IsZombie() const; virtual TDataSet*TDataSet::Last() const; virtual voidls(Option_t* option = """") const; virtual voidls(Int_t deep) const; virtual Char_t*MakeExpression(const Char_t*[] expressions, Int_t nExpressions); voidTDataSet::Mark()MENU ; voidTDataSet::Mark(UInt_t flag, TDataSet::EBitOpt reset = kSet); voidTData",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:4353,Modifiability,Inherit,InheritsFrom,4353,"ic TDataSet*TDataSet::GetMainSet(); TObject*TDataSet::GetMother() const; virtual const char*TNamed::GetName() const; virtual Long_tGetNRows() const; TObjArray*TDataSet::GetObjArray() const; virtual TObject*TDataSet::GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TDataSet*TDataSet::GetParent() const; virtual TClass*GetRowClass() const; virtual TTableDescriptor*GetRowDescriptors() const; virtual Long_tGetRowSize() const; virtual Long_tGetTableSize() const; virtual const char*TNamed::GetTitle() const; virtual const Char_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Long_tHasData() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual TDataSet*TDataSet::Instance() const; static TDataSet*TDataSet::instance(); voidTDataSet::InvertAllMarks()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTDataSet::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tTDataSet::IsMarked() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDataSet::IsThisDir(const char* dirname, int len = -1, int ignorecase = 0) const; Bool_tTObject::IsZombie() const; virtual TDataSet*TDataSet::Last() const; virtual voidls(Option_t* option = """") const; virtual voidls(Int_t deep) const; virtual Char_t*MakeExpression(const Char_t*[] expressions, Int_t nExpressions); voidTDataSet::Mark()MENU ; voidTDataSet::Mark(UInt_t flag, TDataSet::EBitOpt reset = kSet); voidTDataSet::MarkAll()MENU ; voidTObject::MayNotUse(const char* method) co",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:11253,Modifiability,Inherit,Inheritance,11253,"t::kOverwrite; static TDataSet::EDataSetPassTDataSet::kPrune; static TDataSet::EDataSetPassTDataSet::kRefs; static TDataSet::EBitOptTDataSet::kReset; static TDataSet::EBitOptTDataSet::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDataSet::EDataSetPassTDataSet::kStop; static TDataSet::EDataSetPassTDataSet::kStruct; static TDataSet::EDataSetPassTDataSet::kUp; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tfLastIndxindex pof the last used table row;; void*fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0,",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:11266,Modifiability,Inherit,Inherited,11266,"t::kOverwrite; static TDataSet::EDataSetPassTDataSet::kPrune; static TDataSet::EDataSetPassTDataSet::kRefs; static TDataSet::EBitOptTDataSet::kReset; static TDataSet::EBitOptTDataSet::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDataSet::EDataSetPassTDataSet::kStop; static TDataSet::EDataSetPassTDataSet::kStruct; static TDataSet::EDataSetPassTDataSet::kUp; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tfLastIndxindex pof the last used table row;; void*fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0,",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:4177,Security,Hash,Hash,4177,"ion() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainSet(); TObject*TDataSet::GetMother() const; virtual const char*TNamed::GetName() const; virtual Long_tGetNRows() const; TObjArray*TDataSet::GetObjArray() const; virtual TObject*TDataSet::GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TDataSet*TDataSet::GetParent() const; virtual TClass*GetRowClass() const; virtual TTableDescriptor*GetRowDescriptors() const; virtual Long_tGetRowSize() const; virtual Long_tGetTableSize() const; virtual const char*TNamed::GetTitle() const; virtual const Char_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Long_tHasData() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual TDataSet*TDataSet::Instance() const; static TDataSet*TDataSet::instance(); voidTDataSet::InvertAllMarks()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTDataSet::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tTDataSet::IsMarked() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDataSet::IsThisDir(const char* dirname, int len = -1, int ignorecase = 0) const; Bool_tTObject::IsZombie() const; virtual TDataSet*TDataSet::Last() const; virtual voidls(Option_t* option = """") const; virtual voidls(Int_t deep) const; virtual Char_t*MakeExpression(const Char_t*[] expressions, Int_t nE",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:8403,Testability,Test,TestBit,8403,"obj); virtual voidTDataSet::Remove(TDataSet* set); virtual TDataSet*TDataSet::RemoveAt(Int_t idx); virtual voidReset(Int_t c = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidSet(Int_t n); virtual voidSet(Int_t n, Char_t* array); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTDataSet::SetMother(TDataSet* parent = 0); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNRows(Int_t n); virtual voidTDataSet::SetObject(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTDataSet::SetParent(TDataSet* parent = 0); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDataSet::SetWrite(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTDataSet::Shunt(TDataSet* newParent = 0); virtual Int_tTNamed::Sizeof() const; virtual voidTDataSet::Sort(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const TTable*Table() const; TChair(TTable* table); TChair(const TChair& org); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidUpdate(); virtual voidUpdate(TDataSet* set, UInt_t opt = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:8442,Testability,Test,TestBits,8442,"obj); virtual voidTDataSet::Remove(TDataSet* set); virtual TDataSet*TDataSet::RemoveAt(Int_t idx); virtual voidReset(Int_t c = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidSet(Int_t n); virtual voidSet(Int_t n, Char_t* array); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTDataSet::SetMother(TDataSet* parent = 0); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNRows(Int_t n); virtual voidTDataSet::SetObject(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTDataSet::SetParent(TDataSet* parent = 0); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDataSet::SetWrite(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTDataSet::Shunt(TDataSet* newParent = 0); virtual Int_tTNamed::Sizeof() const; virtual voidTDataSet::Sort(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const TTable*Table() const; TChair(TTable* table); TChair(const TChair& org); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidUpdate(); virtual voidUpdate(TDataSet* set, UInt_t opt = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:11848,Testability,assert,assert,11848,"ointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() c",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:11874,Testability,assert,assert,11874,"fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() const; {return (Char_t *)GetThisTable()->GetArray();}",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TChair.html:1027,Usability,Clear,Clear,1027," virtual~TChair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual voidAddAt(TDataSet* dataset, Int_t idx); virtual voidAddAt(const void* c, Int_t i); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html604/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TChair.html
https://root.cern/root/html604/TCivetweb.html:2039,Availability,Error,Error,2039," virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:2168,Availability,error,error,2168," virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:2252,Availability,error,error,2252,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:963,Integrability,rout,routine,963,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:3251,Modifiability,Inherit,InheritsFrom,3251," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsDebugMode() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObjec",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:3317,Modifiability,Inherit,InheritsFrom,3317,"t_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsDebugMode() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCivetweb&operator=(const ",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:7175,Modifiability,Inherit,Inheritance,7175,"; voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; Bool_tfDebug! debug mode; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const. Bool_t IsDebugMode() const; indicates that. » Last changed: Tue Sep 8 17:43:13 2015 » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:7188,Modifiability,Inherit,Inherited,7188,"; voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; Bool_tfDebug! debug mode; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const. Bool_t IsDebugMode() const; indicates that. » Last changed: Tue Sep 8 17:43:13 2015 » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:7585,Modifiability,config,configure,7585,"; voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; Bool_tfDebug! debug mode; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const. Bool_t IsDebugMode() const; indicates that. » Last changed: Tue Sep 8 17:43:13 2015 » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:604,Security,authenticat,authentication,604,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:661,Security,authenticat,authentication,661,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:736,Security,Authenticat,Authentication,736,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:810,Security,access,access,810,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:875,Security,authenticat,authentication,875,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:933,Security,authenticat,authentication,933,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:3141,Security,Hash,Hash,3141,"nst char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsDebugMode() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:7654,Security,authenticat,authentication,7654,"; voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; Bool_tfDebug! debug mode; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const. Bool_t IsDebugMode() const; indicates that. » Last changed: Tue Sep 8 17:43:13 2015 » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:7732,Security,authenticat,authentication,7732,"; voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; Bool_tfDebug! debug mode; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const. Bool_t IsDebugMode() const; indicates that. » Last changed: Tue Sep 8 17:43:13 2015 » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:5542,Testability,Test,TestBit,5542,"r* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCivetweb&operator=(const TCivetweb&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCivetweb(); TCivetweb(const TCivetweb&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:5581,Testability,Test,TestBits,5581,"r* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCivetweb&operator=(const TCivetweb&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCivetweb(); TCivetweb(const TCivetweb&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCivetweb.html:1456,Usability,Clear,Clear,1456," virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html604/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCivetweb.html
https://root.cern/root/html604/TCL.html:945,Integrability,interface,interface,945,". TCL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TCL. class TCL. The set of methods to work with the plain matrix / vector; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f110/top.html; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f112/top.html. Revision 1.7 2006/05/21 18:05:26 brun; Fix more coding conventions violations. Revision 1.6 2006/05/20 14:06:09 brun; Fix a VERY long list of coding conventions violations. Revision 1.5 2003/09/30 09:52:49 brun; Add references to the original CERNLIB packages. Revision 1.4 2003/05/28 15:17:03 brun; From Valeri Fine. A new version of the table package.; It fixes a couple of memory leaks:; class TTableDescriptorm; class TVolumePosition; and provides some clean up; for the TCL class interface. Revision 1.3 2003/04/03 17:39:39 fine; Make merge with ROOT 3.05.03 and add TR package; 122; Revision 1.2 2003/02/04 23:35:20 fine; Clean up. Revision 1.1 2002/04/15 20:23:39 fine; NEw naming schema for RootKErnel classes and a set of classes to back geometry OO. Revision 1.2 2001/05/29 19:08:08 brun; New version of some STAR classes from Valery. Revision 1.2 2001/05/27 02:38:14 fine; New method trsedu to solev Ax=B from Victor. Revision 1.1.1.1 2000/11/27 22:57:14 fisyak. Revision 1.1.1.1 2000/05/16 17:00:48 rdm; Initial import of ROOT into CVS. Function Members (Methods); public:. virtual~TCL(); static TClass*Class(); virtual TClass*IsA() const; static float*mxmad(const float* a, const float* b, float* c, int i, int j, int k); static double*mxmad(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad1(const float* a, const float* b, float* c, int i, int j, int k); static double*mxmad1(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad2(const float* a, const float",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:9646,Modifiability,Inherit,Inheritance,9646,"*vlinco(const double* a, double fa, const double* b, double fb, double* x, int n); static float*vmatl(const float* g, const float* c, float* x, int n = 3, int m = 3); static double*vmatl(const double* g, const double* c, double* x, int n = 3, int m = 3); static float*vmatr(const float* c, const float* g, float* x, int n = 3, int m = 3); static double*vmatr(const double* c, const double* g, double* x, int n = 3, int m = 3); static float*vscale(const float* a, float scale, float* b, int n); static double*vscale(const double* a, double scale, double* b, int n); static float*vsub(const float* a, const float* b, float* x, int n); static double*vsub(const double* a, const double* b, double* x, int n); static float*vsub(const float* b, const double* c, float* a, int n); static double*vsub(const double* b, const float* c, double* a, int n); static float*vzero(float* a, int n2); static double*vzero(double* a, int n2); static void**vzero(void** a, int n2). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; float * mxmad_0_(int n, const float* a, const float* b, float* c, int i, int j, int k). double * mxmad_0_(int n, const double* a, const double* b, double* c, int i, int j, int k). float * mxmlrt_0_(int n__, const float* a, const float* b, float* c, int ni, int nj); Matrix Multiplication; CERN PROGLIB# F110 MXMLRT .VERSION KERNFOR 2.00 720707; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxmlrt_0_(int n__, const double* a, const double* b, double* c, int ni, int nj); Matrix Multiplication (double precision). float * mxtrp(const float* a, float* b, int i, int j). Matrix Transposition; CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxtrp(const double* a, double* b, int i, int j); Matrix Transposition (double precision); CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original docum",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:9659,Modifiability,Inherit,Inherited,9659,"*vlinco(const double* a, double fa, const double* b, double fb, double* x, int n); static float*vmatl(const float* g, const float* c, float* x, int n = 3, int m = 3); static double*vmatl(const double* g, const double* c, double* x, int n = 3, int m = 3); static float*vmatr(const float* c, const float* g, float* x, int n = 3, int m = 3); static double*vmatr(const double* c, const double* g, double* x, int n = 3, int m = 3); static float*vscale(const float* a, float scale, float* b, int n); static double*vscale(const double* a, double scale, double* b, int n); static float*vsub(const float* a, const float* b, float* x, int n); static double*vsub(const double* a, const double* b, double* x, int n); static float*vsub(const float* b, const double* c, float* a, int n); static double*vsub(const double* b, const float* c, double* a, int n); static float*vzero(float* a, int n2); static double*vzero(double* a, int n2); static void**vzero(void** a, int n2). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; float * mxmad_0_(int n, const float* a, const float* b, float* c, int i, int j, int k). double * mxmad_0_(int n, const double* a, const double* b, double* c, int i, int j, int k). float * mxmlrt_0_(int n__, const float* a, const float* b, float* c, int ni, int nj); Matrix Multiplication; CERN PROGLIB# F110 MXMLRT .VERSION KERNFOR 2.00 720707; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxmlrt_0_(int n__, const double* a, const double* b, double* c, int ni, int nj); Matrix Multiplication (double precision). float * mxtrp(const float* a, float* b, int i, int j). Matrix Transposition; CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxtrp(const double* a, double* b, int i, int j); Matrix Transposition (double precision); CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original docum",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:14268,Modifiability,variab,variables,14268,"inal documentation of CERNLIB package F112. double * trasat(const double* a, const double* s, double* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trasat(const double* a, const float* s, float* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trata(const float* a, float* r, int m, int n); trata.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRATA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .V",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:14388,Modifiability,variab,variables,14388,"Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trasat(const double* a, const float* s, float* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trata(const float* a, float* r, int m, int n); trata.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRATA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(cons",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:15131,Modifiability,variab,variables,15131,"112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation ",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:15618,Modifiability,variab,variables,15618,"age F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see origina",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:15791,Modifiability,variab,variables,15791,"1204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROG",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:15914,Modifiability,variab,variables,15914,"* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. L",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TCL.html:16921,Modifiability,variab,variables,16921,"s. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. double * trsat(const double* s, const double* a, double* b, int m, int n); trsat.F -- translated by f2c (version 19970219); CERN PROGLIB# F112 TRSAT .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. float * trsequ(float* smx, int m = 3, float* b = 0, int n = 1); Linear Equations, Matrix Inversion; trsequ solves the matrix equation. SMX*x = B. which represents a system of m simultaneous linear equations with n right-hand sides:; SMX is an unpacked symmetric matrix (all elements) (m x m); B is an unpacked matrix of right-hand sides (n x m). double * trsequ(double* smx, int m = 3, double* b = 0, int n = 1); Linear Equations, Matrix Inversion; trsequ solves the matrix equation. SMX*x = B. which represents a system of m simultaneous linear equations with n right-hand sides:; SMX is an unpacked symmetric matrix (all elements) (m x m); B is an unpacked matrix of right-hand sides (n x m). float * mxmad(const float* a, const float* b",MatchSource.WIKI,root/html604/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TCL.html
https://root.cern/root/html604/TClass.html:3490,Availability,Error,Error,3490,"TObject::ClassName() const; Long_tClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetA",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:3661,Availability,error,error,3661,"nt_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:3745,Availability,error,error,3745,"ed) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:20808,Availability,avail,available,20808,"ject::kOverwrite; static TClass::ENewTypekRealNew; static TClass::ECheckSumkReflex; static TClass::ECheckSumkReflexNoComment; static TDictionary::ESTLTypeTDictionary::kSet; static TObject::(anonymous)TObject::kSingleKey; static TClass::(anonymous)kStartWithTObject; static TClass::(anonymous)kUnloaded; static TDictionary::ESTLTypeTDictionary::kUnorderedMap; static TDictionary::ESTLTypeTDictionary::kUnorderedMultimap; static TDictionary::ESTLTypeTDictionary::kUnorderedMultiset; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TClass::(anonymous)kWarned; static TClass::ECheckSumkWithTypeDef; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TViewPubDataMembers*fAllPubDataall public data members (including from base classes); TViewPubFunctions*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; atomic<Bool_t>fCanLoadClassInfo!Indicates whether the ClassInfo is supposed to be available.; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Long_tfClassProperty!C++ Property of the class (is abstract, has virtual table, etc.); Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; ClassConvStreamerFunc_tfConvStreamerFuncWrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaratio",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:28313,Availability,error,error,28313,"char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:40644,Availability,avail,available,40644,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:49261,Availability,down,down,49261,"is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; t",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:49408,Availability,down,down,49408,"called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:49588,Availability,down,down,49588,"er();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:49735,Availability,down,down,49735,"must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyCla",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:50036,Availability,Error,Error,50036,"e that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClas",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:16013,Deployability,Update,UpdateInterpreterStateMarker,16013,"l = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; voidGetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Class",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:29483,Deployability,update,updated,29483,"or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:56279,Deployability,install,installs,56279,") const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written b",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:59576,Deployability,Install,Install,59576,"of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBuffer(TBuffer& b, void* pointer, Int_t version, UInt_t start, UInt_t count); Function called by the Streamer functions to deserialize information; from buffer b into object at p.; This function assumes that the class version and the byte count information; have been read.; version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadBuffer(TBuffer& b, void* pointer); Function called by the Streamer functions to deserialize information; from buffer b into object at p. Int_t WriteBuffer(TBuffer& b, void* pointer, const char* info = """"); Function called by the Streamer functions to serialize object at p; to buffer b. The optional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TV",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62386,Deployability,Install,Install,62386,"This, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find th",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62488,Deployability,Install,Install,62488,"brary. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * Fin",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62574,Deployability,Install,Install,62574," onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the St",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62661,Deployability,Install,Install,62661,"ign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreame",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62744,Deployability,Install,Install,62744,"mulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerI",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62840,Deployability,Install,Install,62840," TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtual",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62934,Deployability,Install,Install,62934," or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a C",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:63040,Deployability,Install,Install,63040,"ject. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64733,Deployability,Update,Update,64733,"rom the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTO",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:49856,Energy Efficiency,allocate,allocated,49856,"herits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:50918,Energy Efficiency,allocate,allocated,50918,"class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0:",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:51168,Energy Efficiency,allocate,allocated,51168,"ed by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassT",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:51442,Energy Efficiency,allocate,allocated,51442,"otIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should us",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:55247,Energy Efficiency,efficient,efficiently,55247,"ng data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:21232,Integrability,interface,interface,21232,"lass::(anonymous)kWarned; static TClass::ECheckSumkWithTypeDef; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TViewPubDataMembers*fAllPubDataall public data members (including from base classes); TViewPubFunctions*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; atomic<Bool_t>fCanLoadClassInfo!Indicates whether the ClassInfo is supposed to be available.; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Long_tfClassProperty!C++ Property of the class (is abstract, has virtual table, etc.); Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; ClassConvStreamerFunc_tfConvStreamerFuncWrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; ROOT::DelFunc_tfDeletepointer to a function deleting one object.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApoint",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:25784,Integrability,interface,interface,25784,"dStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:26715,Integrability,interface,interface,26715,"to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. This copies the ClassInfo (i.e. does *not* take ownership of it). TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:35820,Integrability,wrap,wrapper,35820,"oBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method retu",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:35958,Integrability,wrap,wrapper,35958,"but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shar",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:38523,Integrability,depend,depends,38523,"fo& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:44895,Integrability,interface,interface,44895,"TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); Look for a method in this class that has the name and matches the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; Returns 0 in case method is not found.; See TClass::GetMethod to also search the base classes. TMethod * GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:50024,Integrability,message,message,50024,"e that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClas",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:52077,Integrability,interface,interface,52077,"wType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dic",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:55894,Integrability,rout,routine,55894,"om; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the valu",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62147,Integrability,wrap,wrapper,62147,"o not have the library defining the class. void StreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature voi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62270,Integrability,wrap,wrapper,62270,"ass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from i",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62400,Integrability,wrap,wrapper,62400,"This, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find th",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62502,Integrability,wrap,wrapper,62502,"brary. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * Fin",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62588,Integrability,wrap,wrapper,62588," onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the St",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62675,Integrability,wrap,wrapper,62675,"ign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreame",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62758,Integrability,wrap,wrapper,62758,"mulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerI",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62854,Integrability,wrap,wrapper,62854," TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtual",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62948,Integrability,wrap,wrapper,62948," or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a C",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:63054,Integrability,wrap,wrapper,63054,"ject. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64903,Integrability,wrap,wrapper,64903,"file_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { re",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64992,Integrability,wrap,wrapper,64992,"represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMem",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:65057,Integrability,wrap,wrapper,65057,"merInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { ret",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:65140,Integrability,wrap,wrapper,65140,"sum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fV",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:65218,Integrability,wrap,wrapper,65218,"ayout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:65305,Integrability,wrap,wrapper,65305,"versionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:65391,Integrability,wrap,wrapper,65391,"ion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() cons",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:65481,Integrability,wrap,wrapper,65481,"his class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:25043,Modifiability,Inherit,Inheritance,25043,"Streamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dict",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:25056,Modifiability,Inherit,Inherited,25056,"Streamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dict",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:30391,Modifiability,inherit,inherited,30391,"dtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Boo",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:30434,Modifiability,inherit,inheritance,30434,"e names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) c",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:32508,Modifiability,inherit,inheritance,32508," of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; interpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. Long_t ClassProperty() const; Return the C++ property of this class, eg. is abstract, has virtual base; class, see EClassProperty in TDictionary.h. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option = """"); Draw detailed class inheritance structure.; If a class B inherits from a class A, the description of B is drawn; on the right side of the description of A.; Member functions overridden by B are shown in class A with a blue line; erasing the corresponding member function. void Dump(const void* obj, Bool_t noAddr = kFALSE) const; Dump contents of object on stdout.; Using the information in the object dictionary; each data member is interpreted.; If a data member is a pointer, the pointer value is printed; 'obj' is assume to point to an object of the class describe by this TClass. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; f",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:32545,Modifiability,inherit,inherits,32545,"bject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; interpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. Long_t ClassProperty() const; Return the C++ property of this class, eg. is abstract, has virtual base; class, see EClassProperty in TDictionary.h. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option = """"); Draw detailed class inheritance structure.; If a class B inherits from a class A, the description of B is drawn; on the right side of the description of A.; Member functions overridden by B are shown in class A with a blue line; erasing the corresponding member function. void Dump(const void* obj, Bool_t noAddr = kFALSE) const; Dump contents of object on stdout.; Using the information in the object dictionary; each data member is interpreted.; If a data member is a pointer, the pointer value is printed; 'obj' is assume to point to an object of the class describe by this TClass. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. If noAddr is true, printout of all pointer values is skipped. c",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:34610,Modifiability,inherit,inheritance,34610,"(const char* text) const; Introduce an escape character (@) in front of a special chars.; You need to use the result immediately before it is being overwritten. TClass * GetActualClass(const void* object) const; Return a pointer the the real class of the object.; This is equivalent to object->IsA() when the class has a ClassDef.; It is REQUIRED that object is coming from a proper pointer to the; class represented by 'this'.; Example: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollec",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:34773,Modifiability,inherit,inheritance,34773,"lass * GetActualClass(const void* object) const; Return a pointer the the real class of the object.; This is equivalent to object->IsA() when the class has a ClassDef.; It is REQUIRED that object is coming from a proper pointer to the; class represented by 'this'.; Example: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any)",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:35048,Modifiability,inherit,inheritance,35048," Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member funct",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:35277,Modifiability,inherit,inheritance,35277,"s would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46597,Modifiability,variab,variable,46597,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46647,Modifiability,variab,variable,46647,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47322,Modifiability,variab,variable,47322,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47372,Modifiability,variab,variable,47372,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47880,Modifiability,variab,variable,47880,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47930,Modifiability,variab,variable,47930,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:48749,Modifiability,Inherit,InheritsFrom,48749,"o, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, B",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:48812,Modifiability,inherit,inherits,48812,"o, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, B",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:48941,Modifiability,Inherit,InheritsFrom,48941,"d IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCal",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:49006,Modifiability,inherit,inherits,49006,"d IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCal",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:54587,Modifiability,inherit,inherits,54587,"bers). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class i",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:54892,Modifiability,inherit,inherit,54892,"to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmu",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:54975,Modifiability,inherit,inherits,54975,"used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType.",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:55398,Modifiability,inherit,inherits,55398,"nd if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:55478,Modifiability,inherit,inheritance,55478,"nd if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:55604,Modifiability,inherit,inherits,55604,"nd if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:644,Performance,load,load,644,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. The name of the class as registered in the TClass object and in the; list of class is the ""normalized name"" and is defined as:. The name of the type as accessible from the global scope to which; a 'using namespace std;' has been applied to and with:; - all typedefs desugared except for Double32_t, Float16_t,; Long64_t, ULong64_t and std::string.; - default template parameters removed for STL collections and; added for any other class templates instances.; - Fully qualified both for the class name itself and all of its; component, except that, at least for moment, all 'std::' are; stripped. Function Members (Methods); public:. virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); static voidAddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAuto",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:5043,Performance,load,load,5043,"t; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataM",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:5139,Performance,load,load,5139,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membern",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:5227,Performance,load,load,5227,"::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::De",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:7077,Performance,load,load,7077,"atamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetN",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:7137,Performance,load,load,7137,"ername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::G",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:7210,Performance,load,load,7210,"() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:7253,Performance,load,load,7253," ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption()",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:7308,Performance,load,load,7308,"c_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*const*GetPersistentRef() const; TRealDat",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:7415,Performance,load,load,7415," type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*const*GetPersistentRef() const; TRealData*GetRealData(const char* name) const; TVirtualRefProxy*GetReferenceProxy() const; ROOT::ResetAfterMergeFun",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:10208,Performance,Load,Load,10208,"Bool_tHasDictionarySelection(const char* clname); virtual ULong_tTNamed::Hash() const; Bool_tHasInterpreterInfo() const; Bool_tHasInterpreterInfoInMemory() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t silent); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); voi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:10240,Performance,Load,LoadClass,10240,"char* clname); virtual ULong_tTNamed::Hash() const; Bool_tHasInterpreterInfo() const; Bool_tHasInterpreterInfoInMemory() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t silent); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz,",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:16768,Performance,Load,LoadClassCustom,16768," visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); static TClass*LoadClassCustom(const char* requestedname, Bool_t silent); static TClass*LoadClassDefault(const char* requestedname, Bool_t silent); voidLoadClassInfo() const; TClass&operator=(const TClass&); voidSetClassSize(Int_t sizof); voidSetClassVersion(Version_t version); voidSetStreamerImpl(); static voidStreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerExternal(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObject(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectEmulated(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectInitialized(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TClass(const TClass& tc). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TDictionary::ESTLTypeTDictionary::k",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:16841,Performance,Load,LoadClassDefault,16841," visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); static TClass*LoadClassCustom(const char* requestedname, Bool_t silent); static TClass*LoadClassDefault(const char* requestedname, Bool_t silent); voidLoadClassInfo() const; TClass&operator=(const TClass&); voidSetClassSize(Int_t sizof); voidSetClassVersion(Version_t version); voidSetStreamerImpl(); static voidStreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerExternal(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObject(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectEmulated(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectInitialized(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TClass(const TClass& tc). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TDictionary::ESTLTypeTDictionary::k",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:21539,Performance,cache,cached,21539,"embers*fAllPubDataall public data members (including from base classes); TViewPubFunctions*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; atomic<Bool_t>fCanLoadClassInfo!Indicates whether the ClassInfo is supposed to be available.; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Long_tfClassProperty!C++ Property of the class (is abstract, has virtual table, etc.); Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; ClassConvStreamerFunc_tfConvStreamerFuncWrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; ROOT::DelFunc_tfDeletepointer to a function deleting one object.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:22340,Performance,load,loaded,22340,Wrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; ROOT::DelFunc_tfDeletepointer to a function deleting one object.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; atomic<TMethodCall*>fIsAMethod!saved info to call a IsA member function; atomic<Bool_t>fIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; atomic<TVirtualStreamerInfo*>fLastReadInfo!cached streamer info used in the last read.; ROOT::MergeFunc_tfMergepointer to a function implementing Merging objects of this class.; atomic<TListOfFunctions*>fMethodlinked list for methods; ROOT::NewFunc_tfNewpointer to a function newing one object.; ROOT::NewArrFunc_tfNewArraypointer to a function newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances o,MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:22786,Performance,cache,cached,22786,bject.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; atomic<TMethodCall*>fIsAMethod!saved info to call a IsA member function; atomic<Bool_t>fIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; atomic<TVirtualStreamerInfo*>fLastReadInfo!cached streamer info used in the last read.; ROOT::MergeFunc_tfMergepointer to a function implementing Merging objects of this class.; atomic<TListOfFunctions*>fMethodlinked list for methods; ROOT::NewFunc_tfNewpointer to a function newing one object.; ROOT::NewArrFunc_tfNewArraypointer to a function newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; atomic<TClass**>fPersistentRef!Persistent address of pointer to this TClass object and its successors.; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! S,MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:24043,Performance,Load,Loaded,24043,"ction newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; atomic<TClass**>fPersistentRef!Persistent address of pointer to this TClass object and its successors.; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClass::EStatefState!Current 'state' of the class (Emulated,Interpreted,Loaded); TClassStreamer*fStreamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:24425,Performance,cache,cached,24425,"; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClass::EStatefState!Current 'state' of the class (Emulated,Interpreted,Loaded); TClassStreamer*fStreamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:28282,Performance,load,loaded,28282,"ersion_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; s",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:36183,Performance,load,load,36183," -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOr",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:36297,Performance,load,load,36297,"to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cna",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:36352,Performance,load,loading,36352,"to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cna",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:36658,Performance,load,load,36658,"f any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""d",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:36776,Performance,load,load,36776,"const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:36889,Performance,load,load,36889,"t; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealDat",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:36944,Performance,load,loading,36944,"t; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealDat",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:37398,Performance,load,loading,37398,"ared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:37520,Performance,load,loading,37520,"(typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:38690,Performance,load,load,38690,"et(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not al",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:38787,Performance,load,load,38787,"e class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:38896,Performance,load,load,38896," emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRU",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:38989,Performance,load,load,38989,"const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subs",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:39056,Performance,load,load,39056,"elf,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). v",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:39329,Performance,load,load,39329,"et the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:39894,Performance,load,load,39894," list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& v",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:40370,Performance,load,loading,40370,"load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the se",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:40494,Performance,load,load,40494,"hods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool rec",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:40594,Performance,load,loaded,40594,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:40705,Performance,load,loaded,40705,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:42420,Performance,cache,caches,42420,"ngDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; the class itself, all base classes, direct data members,; and for collection proxies the container's; elements without iterating over the element's data members;; With recurse = true the classes checked for missing dictionaries are:; the class itself, all base classes, recursing on the data members,; and for the collection proxies recursiong on the elements of the; collection and iterating over the element's data members. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void ReplaceWith(TClass* newcl) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetClassInfo(); Make sure that the current ClassInfo is up to date. void ResetCaches(); To clean out all caches. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList()",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:43612,Performance,load,loads,43612,"s verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:43811,Performance,load,loading,43811,"menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClas",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:45998,Performance,load,load,45998,"that has the name and matches the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; Returns 0 in case method is not found.; See TClass::GetMethod to also search the base classes. TMethod * GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two spe",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46072,Performance,load,loaded,46072,"that has the name and matches the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; Returns 0 in case method is not found.; See TClass::GetMethod to also search the base classes. TMethod * GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two spe",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46399,Performance,load,loaded,46399,"EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable proper",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46450,Performance,load,loaded,46450,"method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindS",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46544,Performance,optimiz,optimizes,46544,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46682,Performance,Optimiz,Optimize,46682,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:46981,Performance,load,loaded,46981,"eturn the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is c",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47124,Performance,load,loaded,47124,"s(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Stre",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47175,Performance,load,loaded,47175,"Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47269,Performance,optimiz,optimizes,47269,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47407,Performance,Optimiz,Optimize,47407,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47705,Performance,load,loaded,47705,"ed externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Cl",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47827,Performance,optimiz,optimizes,47827,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47965,Performance,Optimiz,Optimize,47965,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:52737,Performance,Load,Load,52737,". void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetC",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:52755,Performance,Load,Load,52755,". void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetC",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:52828,Performance,Load,LoadClass,52828,"lation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:52952,Performance,load,load,52952,"n. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are use",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:53259,Performance,Load,LoadClassDefault,53259,"ent; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; R",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:53390,Performance,load,load,53390,"m to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:53678,Performance,Load,LoadClassCustom,53678,"ss. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the foll",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:53808,Performance,load,load,53808,"* LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TO",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:54080,Performance,Load,LoadClassInfo,54080," class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initial",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:54110,Performance,load,load,54110," class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initial",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:54177,Performance,load,loading,54177," class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initial",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:55325,Performance,cache,cache,55325,"rn true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:66431,Performance,Load,LoadClassInfo,66431,e destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const;,MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:67910,Performance,perform,performance,67910,"return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsVersioned() const; { return !( GetClassVersion()<=1 && IsForeign() ); }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:56880,Safety,safe,safe,56880,"pl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code);",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:936,Security,access,accessible,936,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. The name of the class as registered in the TClass object and in the; list of class is the ""normalized name"" and is defined as:. The name of the type as accessible from the global scope to which; a 'using namespace std;' has been applied to and with:; - all typedefs desugared except for Double32_t, Float16_t,; Long64_t, ULong64_t and std::string.; - default template parameters removed for STL collections and; added for any other class templates instances.; - Fully qualified both for the class name itself and all of its; component, except that, at least for moment, all 'std::' are; stripped. Function Members (Methods); public:. virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); static voidAddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj,",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:4031,Security,checksum,checksum,4031,"ject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:4128,Security,checksum,checksum,4128,"oidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, B",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:4314,Security,checksum,checksum,4314,"t; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMet",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:4392,Security,checksum,checksum,4392,"oid*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMet",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:9283,Security,Hash,Hash,9283,"stentRef() const; TRealData*GetRealData(const char* name) const; TVirtualRefProxy*GetReferenceProxy() const; ROOT::ResetAfterMergeFunc_tGetResetAfterMerge() const; const ROOT::TSchemaRuleSet*GetSchemaRules() const; ROOT::TSchemaRuleSet*GetSchemaRules(Bool_t create = kFALSE); const char*GetSharedLibs(); ShowMembersFunc_tGetShowMembersWrapper() const; TClass::EStateGetState() const; TClassStreamer*GetStreamer() const; ClassStreamerFunc_tGetStreamerFunc() const; TVirtualStreamerInfo*GetStreamerInfo(Int_t version = 0) const; TVirtualStreamerInfo*GetStreamerInfoAbstractEmulated(Int_t version = 0) const; const TObjArray*GetStreamerInfos() const; virtual const char*TNamed::GetTitle() const; const type_info*GetTypeInfo() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasDataMemberInfo() const; Bool_tHasDefaultConstructor() const; Bool_tHasDictionary(); static Bool_tHasDictionarySelection(const char* clname); virtual ULong_tTNamed::Hash() const; Bool_tHasInterpreterInfo() const; Bool_tHasInterpreterInfoInMemory() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t si",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:10394,Security,checksum,checksum,10394,"(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t silent); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """");",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:15553,Security,checksum,checksum,15553,"l = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; voidGetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Class",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:25893,Security,access,access,25893,"::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. This copies the ",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:26824,Security,access,access,26824," Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. This copies the ClassInfo (i.e. does *not* take ownership of it). TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. T",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:28521,Security,checksum,checksum,28521,"ad(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separat",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:28764,Security,checksum,checksum,28764,"sInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimite",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:29743,Security,checksum,checksum,29743,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTra",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:29782,Security,checksum,checksums,29782,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTra",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:31289,Security,access,access,31289,"ame, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; interpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. Long_t ClassProperty() const; Return the C++ property of this class, eg. is abstract, has virtual base; class, see EClassProperty in TDictionary.h. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the sam",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:35828,Security,access,accessor,35828,"oBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method retu",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:35966,Security,access,accessor,35966,"but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shar",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:40170,Security,access,accessible,40170,"nction template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pai",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:42894,Security,access,accessible,42894,"sing on the data members,; and for the collection proxies recursiong on the elements of the; collection and iterating over the element's data members. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void ReplaceWith(TClass* newcl) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetClassInfo(); Make sure that the current ClassInfo is up to date. void ResetCaches(); To clean out all caches. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * Get",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:47482,Security,checksum,checksum,47482,"ed externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Cl",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:52407,Security,checksum,checksum,52407,":IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedn",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:57737,Security,checksum,checksum,57737,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:57773,Security,checksum,checksum,57773,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:57815,Security,checksum,checksum,57815,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:57853,Security,checksum,checksum,57853,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:58228,Security,checksum,checksum,58228,"= """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefP",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:58601,Security,checksum,checksum,58601,"e user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBu",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:58632,Security,checksum,checksum,58632,"e user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBu",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62155,Security,access,accessor,62155,"o not have the library defining the class. void StreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature voi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:62278,Security,access,accessor,62278,"ass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from i",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:63358,Security,checksum,checksum,63358,"nc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:63443,Security,checksum,checksum,63443,"nc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:63516,Security,checksum,checksum,63516,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStre",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:63601,Security,checksum,checksum,63601,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStre",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64124,Security,checksum,checksum,64124,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper ar",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64232,Security,checksum,checksum,64232,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper ar",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64347,Security,checksum,checksum,64347,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64460,Security,checksum,checksum,64460,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:64823,Security,access,access,64823," class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. v",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:14951,Testability,Test,TestBit,14951,"::SetNameTitle(const char* name, const char* title); voidSetNew(ROOT::NewFunc_t newFunc); voidSetNewArray(ROOT::NewArrFunc_t newArrayFunc); static voidTObject::SetObjectStat(Bool_t stat); voidSetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); voidSetStreamerFunc(ClassStreamerFunc_t strm); TVirtualStreamerInfo*SetStreamerInfo(Int_t version, const char* info = """"); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUnloaded(); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSize() const; virtual Int_tTNamed::Sizeof() const; voidStore(TBuffer& b) const; virtual voidStreamer(TBuffer&); voidStreamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """").",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:14990,Testability,Test,TestBits,14990,"::SetNameTitle(const char* name, const char* title); voidSetNew(ROOT::NewFunc_t newFunc); voidSetNewArray(ROOT::NewArrFunc_t newArrayFunc); static voidTObject::SetObjectStat(Bool_t stat); voidSetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); voidSetStreamerFunc(ClassStreamerFunc_t strm); TVirtualStreamerInfo*SetStreamerInfo(Int_t version, const char* info = """"); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUnloaded(); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSize() const; virtual Int_tTNamed::Sizeof() const; voidStore(TBuffer& b) const; virtual voidStreamer(TBuffer&); voidStreamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """").",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:56660,Testability,test,test,56660," a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchL",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:65772,Testability,Test,TestBit,65772,_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealDa,MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:66412,Testability,Test,TestBit,66412,e destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const;,MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClass.html:2570,Usability,Clear,Clear,2570,"d_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCalculateStreamerOffset() const; Bool_tCallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Bool_tCanIgnoreTObjectStreamer(); Bool_tCanSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; Long_tClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* t",MatchSource.WIKI,root/html604/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClass.html
https://root.cern/root/html604/TClassDocInfo.html:1265,Availability,Error,Error,1265," virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:1394,Availability,error,error,1394," virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:1478,Availability,error,error,1478,"ocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTime",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:2643,Modifiability,Inherit,InheritsFrom,2643,"Object::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; Bool_tHaveSource() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsSelected() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::opera",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:2709,Modifiability,Inherit,InheritsFrom,2709,"t::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; Bool_tHaveSource() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsSelected() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassDocInfo&operator=(const TCla",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:7026,Modifiability,Inherit,Inheritance,7026,"ect::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFil",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:7039,Modifiability,Inherit,Inherited,7039,"ect::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFil",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:292,Performance,Cache,Caches,292,". TClassDocInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TClassDocInfo. class TClassDocInfo: public TObject. Caches class documentation information, like which module it belongs to,; and whether THtml should generate documentation for the class. Function Members (Methods); public:. virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:7204,Security,Hash,Hash,7204,"static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFileSysName; }. const char* GetImplFileSysName() const; { return fImplFileSysName; }. void SetModule(TModuleDocInfo* module); { fModule = module; }. TModuleDocInfo* GetModule() const; { retur",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:7237,Security,Hash,Hash,7237,"static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFileSysName; }. const char* GetImplFileSysName() const; { return fImplFileSysName; }. void SetModule(TModuleDocInfo* module); { fModule = module; }. TModuleDocInfo* GetModule() const; { retur",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:5301,Testability,Test,TestBit,5301,"ze_t sz, void* vp); TClassDocInfo&operator=(const TClassDocInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDeclFileName(const char* name); voidSetDeclFileSysName(const char* fsname); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHtmlFileName(const char* name); voidSetImplFileName(const char* name); voidSetImplFileSysName(const char* fsname); voidSetModule(TModuleDocInfo* module); static voidTObject::SetObjectStat(Bool_t stat); voidSetSelected(Bool_t sel = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassDocInfo(const TClassDocInfo&); TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:5340,Testability,Test,TestBits,5340,"ze_t sz, void* vp); TClassDocInfo&operator=(const TClassDocInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDeclFileName(const char* name); voidSetDeclFileSysName(const char* fsname); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHtmlFileName(const char* name); voidSetImplFileName(const char* name); voidSetImplFileSysName(const char* fsname); voidSetModule(TModuleDocInfo* module); static voidTObject::SetObjectStat(Bool_t stat); voidSetSelected(Bool_t sel = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassDocInfo(const TClassDocInfo&); TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocInfo.html:734,Usability,Clear,Clear,734," virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html604/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocInfo.html
https://root.cern/root/html604/TClassDocOutput.html:2620,Availability,Error,Error,2620,"Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:2749,Availability,error,error,2749,"erarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:2833,Availability,error,error,2833,"ndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:12409,Availability,down,down,12409,"ludes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the h",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:15433,Deployability,update,updates,15433,"d in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeOneLiner (set if the func consists of only one line; of code, immediately surrounded by ""{"",""}""). Also updates fMethodNames's; count of method names. TClassDocOutput(THtml& html, TClass* cl, TList* typedefs). » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:751,Integrability,interface,interfaces,751,". TClassDocOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TClassDocOutput. class TClassDocOutput: public TDocOutput. Write the documentation for a class or namespace. The documentation is; parsed by TDocParser and then passed to TClassDocOutput to generate; the class doc header, the class description, members overview, and method; documentation. All generic output functionality is in TDocOutput; it is; re-used in this derived class. You usually do not use this class yourself; it is invoked indirectly by; THtml. Customization of the output should happen via the interfaces defined; by THtml. Function Members (Methods); public:. virtual~TClassDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDocOutput::AdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); voidClass2Html(Bool_t force = kFALSE); Bool_tClassDotCharts(ostream& out); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTDocOutput::Convert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:12007,Integrability,depend,dependencies,12007,"utput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:12038,Integrability,depend,dependency,12038,"utput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:13010,Integrability,depend,dependency,13010,"clude dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxL",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:13183,Integrability,depend,dependency,13183,"int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:14293,Integrability,rout,routine,14293," char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeO",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:3852,Modifiability,Inherit,InheritsFrom,3852,"Object::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTDocOutput::IsModified(TClass* classPtr, TDocOutput::EFileType type); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeTree(Bool_t force = kFALSE); voidTObject::MayNotUse(const char* method) const; virtual voidTDocOutput::NameSpace2FileName(TString& name); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* p",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:3918,Modifiability,Inherit,InheritsFrom,3918,"dTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTDocOutput::IsModified(TClass* classPtr, TDocOutput::EFileType type); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeTree(Bool_t force = kFALSE); voidTObject::MayNotUse(const char* method) const; virtual voidTDocOutput::NameSpace2FileName(TString& name); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
https://root.cern/root/html604/TClassDocOutput.html:11328,Modifiability,Inherit,Inheritance,11328,"Object::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TDocOutput::EFileTypeTDocOutput::kSource; static TDocOutput::EFileTypeTDocOutput::kTree; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fCurrentClassclass to generate output for; TList*fCurrentClassesTypedefstypedefs to the current class; Int_tfHierarchyLinescounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use; static TClassDocOutput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - point",MatchSource.WIKI,root/html604/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TClassDocOutput.html
