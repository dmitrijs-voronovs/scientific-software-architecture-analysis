id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:30610,Performance,optimiz,optimize,30610," H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Lss, optimize=True). # Save best R/L vectors and eigenvalues; best_R = _best_vectors(engine, Rss[:, :nk], vecs); best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['val'][k] = w[k]. # augment the guess space for non-converged roots; if (iter_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:30681,Performance,optimiz,optimize,30681,"2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Lss, optimize=True). # Save best R/L vectors and eigenvalues; best_R = _best_vectors(engine, Rss[:, :nk], vecs); best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['val'][k] = w[k]. # augment the guess space for non-converged roots; if (iter_info['res_norm'][k] > r_convergence):; iter_info['done'] = False; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:17294,Safety,safe,safe,17294," its own use should be optional. Returns; -------; X : singlet `vector`; This should be a new vector object with the correct dimensions,; assumed to be zeroed out; """"""; pass. [docs] def vector_dot(X, Y) -> float:; """"""Compute a dot product between two `vectors`. Parameters; ----------; X : single `vector`; Y : single `vector`. Returns; -------; a : float; The dot product (X x Y); """"""; pass. # cython doesn't like static+ decorators https://github.com/cython/cython/issues/1434#issuecomment-608975116; vector_dot = staticmethod(abstractmethod(vector_dot)). [docs] @abstractmethod; def vector_axpy(a: float, X, Y):; """"""Compute scaled `vector` addition operation `a*X + Y`. Parameters; ----------; a; The scale factor applied to `X`; X : singlet `vector`; The `vector` which will be scaled and added to `Y`; Y : single `vector`; The `vector` which the result of `a*X` is added to. Returns; -------; Y : single `vector`; The solver assumes that Y is updated, and returned. So it is safe to; avoid a copy of Y if possible; """"""; pass. [docs] @abstractmethod; def vector_scale(a: float, X):; """"""Scale a vector by some factor. Parameters; ----------; a; The scale facor; X : single `vector`; The vector that will be scaled. Returns; -------; X : single `vector`; The solver assumes that the passed vector is modifed. So it is save; to avoid a copy of X if possible.; """"""; pass. [docs] @abstractmethod; def vector_copy(X):; """"""Make a copy of a `vector`. Parameters; ----------; X : single `vector`; The `vector` to copy. Returns; -------; X' : single `vector`; A copy of `X` should be distinct object that can be modified; independently of the passed object, Has the same data when returned.; """"""; pass. [docs] @abstractmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired transition property.; prefactor; Optional float scaling factor. Returns; ------",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:17303,Safety,avoid,avoid,17303," its own use should be optional. Returns; -------; X : singlet `vector`; This should be a new vector object with the correct dimensions,; assumed to be zeroed out; """"""; pass. [docs] def vector_dot(X, Y) -> float:; """"""Compute a dot product between two `vectors`. Parameters; ----------; X : single `vector`; Y : single `vector`. Returns; -------; a : float; The dot product (X x Y); """"""; pass. # cython doesn't like static+ decorators https://github.com/cython/cython/issues/1434#issuecomment-608975116; vector_dot = staticmethod(abstractmethod(vector_dot)). [docs] @abstractmethod; def vector_axpy(a: float, X, Y):; """"""Compute scaled `vector` addition operation `a*X + Y`. Parameters; ----------; a; The scale factor applied to `X`; X : singlet `vector`; The `vector` which will be scaled and added to `Y`; Y : single `vector`; The `vector` which the result of `a*X` is added to. Returns; -------; Y : single `vector`; The solver assumes that Y is updated, and returned. So it is safe to; avoid a copy of Y if possible; """"""; pass. [docs] @abstractmethod; def vector_scale(a: float, X):; """"""Scale a vector by some factor. Parameters; ----------; a; The scale facor; X : single `vector`; The vector that will be scaled. Returns; -------; X : single `vector`; The solver assumes that the passed vector is modifed. So it is save; to avoid a copy of X if possible.; """"""; pass. [docs] @abstractmethod; def vector_copy(X):; """"""Make a copy of a `vector`. Parameters; ----------; X : single `vector`; The `vector` to copy. Returns; -------; X' : single `vector`; A copy of `X` should be distinct object that can be modified; independently of the passed object, Has the same data when returned.; """"""; pass. [docs] @abstractmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired transition property.; prefactor; Optional float scaling factor. Returns; ------",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:17643,Safety,avoid,avoid,17643,"s; -------; a : float; The dot product (X x Y); """"""; pass. # cython doesn't like static+ decorators https://github.com/cython/cython/issues/1434#issuecomment-608975116; vector_dot = staticmethod(abstractmethod(vector_dot)). [docs] @abstractmethod; def vector_axpy(a: float, X, Y):; """"""Compute scaled `vector` addition operation `a*X + Y`. Parameters; ----------; a; The scale factor applied to `X`; X : singlet `vector`; The `vector` which will be scaled and added to `Y`; Y : single `vector`; The `vector` which the result of `a*X` is added to. Returns; -------; Y : single `vector`; The solver assumes that Y is updated, and returned. So it is safe to; avoid a copy of Y if possible; """"""; pass. [docs] @abstractmethod; def vector_scale(a: float, X):; """"""Scale a vector by some factor. Parameters; ----------; a; The scale facor; X : single `vector`; The vector that will be scaled. Returns; -------; X : single `vector`; The solver assumes that the passed vector is modifed. So it is save; to avoid a copy of X if possible.; """"""; pass. [docs] @abstractmethod; def vector_copy(X):; """"""Make a copy of a `vector`. Parameters; ----------; X : single `vector`; The `vector` to copy. Returns; -------; X' : single `vector`; A copy of `X` should be distinct object that can be modified; independently of the passed object, Has the same data when returned.; """"""; pass. [docs] @abstractmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired transition property.; prefactor; Optional float scaling factor. Returns; -------; residue : Any; The transition property.; """"""; pass. [docs]def davidson_solver(; engine: Type[SolverEngine],; guess: List,; *,; nroot: int,; r_convergence: float = 1.0E-4,; max_ss_size: int = 100,; maxiter: int = 60,; verbose: int = 1,; nonneg_only: bool = False) -> Dict[str, Any]:; """"""Solves for the lowest few eigenvalues and eige",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:1391,Security,Validat,ValidationError,1391,"ponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""cg_solver"",; ""davidson_solver"",; ""DIIS"",; ""hamiltonian_solver"",; ""SolverEngine"",; ]. import time; from abc import ABC, abstractmethod; from typing import Any, Callable, Dict, List, Optional, Type. import numpy as np. from psi4 import core. from .exceptions import ValidationError. """"""; Generalized iterative solvers for Psi4. """""". [docs]def cg_solver(; rhs_vec: List[core.Matrix],; hx_function: Callable,; preconditioner: Callable,; guess: Optional[List[core.Matrix]] = None,; printer: Optional[Callable] = None,; printlvl: int = 1,; maxiter: int = 20,; rcond: float = 1.e-6) -> List[core.Matrix]:; """"""; Solves the :math:`Ax = b` linear equations via Conjugate Gradient. The `A` matrix must be a hermitian, positive definite matrix. Parameters; ----------; rhs_vec; The RHS vector in the Ax=b equation.; hx_function; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the preconditioned value.; guess; Starting vectors. If None, use a preconditioner (rhs) guess; printer; Takes in a list of current x and residual vectors and provides a print function. This function can also; re",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:3700,Security,Validat,ValidationError,3700," vectors. Notes; -----; This is a generalized cg solver that can also take advantage of solving multiple RHS's simultaneously when; it is advantageous to do so. """""". tstart = time.time(); if printlvl:; core.print_out(""\n -----------------------------------------------------\n""); core.print_out("" "" + ""Generalized CG Solver"".center(52) + ""\n""); core.print_out("" "" + ""by Daniel. G. A. Smith"".center(52) + ""\n""); core.print_out("" -----------------------------------------------------\n""); core.print_out("" Maxiter = %11d\n"" % maxiter); core.print_out("" Convergence = %11.3E\n"" % rcond); core.print_out("" Number of equations = %11ld\n\n"" % len(rhs_vec)); core.print_out("" %4s %14s %12s %6s %6s\n"" % (""Iter"", ""Residual RMS"", ""Max RMS"", ""Remain"", ""Time [s]"")); core.print_out("" -----------------------------------------------------\n""). nrhs = len(rhs_vec); active_mask = [True for x in range(nrhs)]. # Start function; if guess is None:; x_vec = preconditioner(rhs_vec, active_mask); else:; if len(guess) != len(rhs_vec):; raise ValidationError(""CG Solver: Guess vector length does not match RHS vector length.""); x_vec = [x.clone() for x in guess]. Ax_vec = hx_function(x_vec, active_mask). # Set it up; r_vec = [] # Residual vectors; for x in range(nrhs):; tmp_r = rhs_vec[x].clone(); tmp_r.axpy(-1.0, Ax_vec[x]); r_vec.append(tmp_r). z_vec = preconditioner(r_vec, active_mask); p_vec = [x.clone() for x in z_vec]. # First RMS; grad_dot = [x.sum_of_squares() for x in rhs_vec]. resid = [(r_vec[x].sum_of_squares() / grad_dot[x])**0.5 for x in range(nrhs)]. if printer:; resid = printer(0, x_vec, r_vec); elif printlvl:; # core.print_out(' CG Iteration Guess: Rel. RMS = %1.5e\n' % np.mean(resid)); core.print_out("" %5s %14.3e %12.3e %7d %9d\n"" %; (""Guess"", np.mean(resid), np.max(resid), len(z_vec), time.time() - tstart)). rms = np.mean(resid); rz_old = [0.0 for x in range(nrhs)]; alpha = [0.0 for x in range(nrhs)]; active = np.where(active_mask)[0]. # CG iterations; for rot_iter in range(maxiter):.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:6600,Security,Validat,ValidationError,6600,"[0]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs] def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs] def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del sel",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:7360,Security,Validat,ValidationError,7360,"f __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs] def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs] def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:19745,Testability,log,logging,19745,"d only; a small number of roots, `k` are desired this algorithm is preferable to; standard methods as uses on the order of `N * k` memory. One only needs to; have the ability to compute the product of a times a vector. For non-hermitan `A` the basis of the algorithm breaks down. However in; practice, for strongly diagonally-dominant `A` such as the; similarity-transformed Hamiltonian in EOM-CC this algorithm is commonly still; used. Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:25868,Testability,log,logging,25868,"d :math:`(A-B)`; (H2) in to the subspace defined by the trial vectors.; The subspace analog of the NxN hermitian EVP is diagonalized and left :math:`(X-Y)`; and right :math:`(X+Y)` eigenvectors of the NxN non-hermitian EVP are approximated.; Residual vectors are formed for both and the guess space is augmented with; two correction vectors per iteration. The advantages and properties of this; algorithm are described in the literature [stratmann:1998]_ . Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:13130,Deployability,update,updated,13130,"au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x); y = prefactor * x * np.sum([transform_residue(r) * shape.lineshape(p) for p, r in zip(poles, residues)], axis=0). # Generate sticks; sticks = prefactor * np.array([p * transform_residue(r) * shape.maximum(p) for p, r in zip(poles, residues)]). return {""convolution"": {""x"": x, ""y"": y}, ""sticks"": {""poles"": poles, ""residues"": sticks}}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.spectrum. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:4939,Energy Efficiency,charge,charge,4939,"ameters; ----------; x_0; Center of the Lorentzian, i.e. its maximum. """"""; return 2.0 / (np.pi * self.gamma(x_0)). [docs]def prefactor_opa() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:6084,Energy Efficiency,charge,charge,6084,"og(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon absorption (OPA) or electronic circular dichroism (ECD); spectra with phenomenological line broadening. This function gives arrays of values ready to be plotted as OPA spectrum:. .. math::. \varepsilon(\omega) =; \frac{4\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}; \sum_{i \rightarrow",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:8703,Energy Efficiency,energy,energy,8703,"of the response function, i.e. the excitation energies.; These are **expected** in atomic units of angular frequency.; residues; Residues of the linear response functions, i.e. transition dipole moments (OPA) and rotatory strengths (ECD).; These are **expected** in atomic units.; kind; {""opa"", ""ecd""}; Which kind of spectrum to generate, one-photon absorption (""opa"") or electronic circular dichroism (""ecd"").; Default is `opa`.; lineshape; {""gaussian"", ""lorentzian""}; The lineshape function to use in the fitting. Default is `gaussian`.; gamma; Full width at half maximum of the lineshape function.; Default is 0.2 au of angular frequency.; This value is **expected** in atomic units of angular frequency.; npoints; How many points to generate for the x axis. Default is 5000.; out_units; Units for the output array `x`, the x axis of the spectrum plot.; Default is wavelengths in nanometers.; Valid (and case-insensitive) values for the units are:. - `au` atomic units of angular frequency; - `Eh` atomic units of energy; - `eV`; - `nm`; - `THz`. Returns; -------; spectrum : Dict[str, numpy.ndarray]; The fitted electronic absorption spectrum, with units for the x axis specified by the `out_units` parameter.; This is a dictionary containing the convoluted (key: `convolution`) and the infinitely narrow spectra (key: `sticks`). .. code-block:: python. {""convolution"": {""x"": np.ndarray, ""y"": np.ndarray},; ""sticks"": {""poles"": np.ndarray, ""residues"": np.ndarray}}. Notes; -----; * Conversion of the broadening parameter :math:`\gamma`.; The lineshape functions are formulated as functions of the angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:9649,Energy Efficiency,Energy,Energy,9649,"se-insensitive) values for the units are:. - `au` atomic units of angular frequency; - `Eh` atomic units of energy; - `eV`; - `nm`; - `THz`. Returns; -------; spectrum : Dict[str, numpy.ndarray]; The fitted electronic absorption spectrum, with units for the x axis specified by the `out_units` parameter.; This is a dictionary containing the convoluted (key: `convolution`) and the infinitely narrow spectra (key: `sticks`). .. code-block:: python. {""convolution"": {""x"": np.ndarray, ""y"": np.ndarray},; ""sticks"": {""poles"": np.ndarray, ""residues"": np.ndarray}}. Notes; -----; * Conversion of the broadening parameter :math:`\gamma`.; The lineshape functions are formulated as functions of the angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\omega}\hbar`. References; ----------; A. Rizzo, S. Coriani, K. Ruud, ""Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy"". In Computational Strategies for Spectroscopy.; https://doi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_unit",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10903,Energy Efficiency,energy,energy,10903,"oi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on e",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11055,Energy Efficiency,energy,energy,11055,"s, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # V",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11164,Energy Efficiency,Energy,Energy,11164,"idues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Linesh",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11220,Energy Efficiency,Energy,Energy,11220,"idues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Linesh",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11603,Energy Efficiency,Energy,Energy,11603,"ror(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x);",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11665,Energy Efficiency,Energy,Energy,11665,"ror(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x);",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:1679,Integrability,depend,depends,1679,"is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""Gaussian"",; ""Lineshape"",; ""Lorentzian"",; ""prefactor_ecd"",; ""prefactor_opa"",; ""spectrum"",; ]. from abc import abstractmethod; from dataclasses import dataclass; from typing import Callable, Dict, List, Union. import numpy as np; from psi4.driver import constants. [docs]@dataclass; class Lineshape:; """"""Lineshape ABC. Attributes; ----------; domain; Domain of the spectral band.; gamma; A function returning the broadening factor. Notes; -----; Why do we use a callable broadening factor?; For plots in the *wavelength domain*, the broadening factor depends on the location of the band's maximum.; """"""; domain: Union[np.ndarray, List[float]]; gamma: Callable[[float], float]. [docs] @abstractmethod; def lineshape(self, x_0: float) -> np.ndarray:; pass. [docs] @abstractmethod; def maximum(self, x_0: float) -> float:; pass. [docs]class Gaussian(Lineshape):; r""""""Gaussian function on `domain`, centered at `x_0` with broadening `gamma`. Parameters; ----------; domain; The domain of the Gaussian profile.; gamma; Broadening parameter.; This is related to the full width at half maximum as :math:`\mathrm{FWHM} = \gamma \sqrt{2\ln 2}`. Notes; -----; Use this profile to model inhomegenous broadening.; """""". [docs] def lineshape(self, x_0: float) -> np.ndarray:; """"""Gaussian function on :py:attr:`Lineshape.domain`, centered at `x_0` with broadening :py:attr:`Lineshape.gamma`. Parameters; ----------; x_0; Center of the Gaussian, i.e. its maximum. Returns; -------; numpy.ndarray; The Gaussian profile. """"""; prefac",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:4642,Integrability,depend,dependent,4642,"; -------; numpy.ndarray; The Lorentzian profile.; """"""; prefactor = 1.0 / np.pi; numerator = self.gamma(x_0) / 2.0; denominator = (self.domain - x_0)**2 + numerator**2. return prefactor * (numerator / denominator). [docs] def maximum(self, x_0: float) -> float:; """"""Maximum value of Lorentzian profile centered at `x_0`. Parameters; ----------; x_0; Center of the Lorentzian, i.e. its maximum. """"""; return 2.0 / (np.pi * self.gamma(x_0)). [docs]def prefactor_opa() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact th",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:5788,Integrability,depend,dependent,5788,"(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon absor",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11366,Performance,Perform,Perform,11366,"mong recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Genera",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10100,Security,Validat,Validate,10100," {""poles"": np.ndarray, ""residues"": np.ndarray}}. Notes; -----; * Conversion of the broadening parameter :math:`\gamma`.; The lineshape functions are formulated as functions of the angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\omega}\hbar`. References; ----------; A. Rizzo, S. Coriani, K. Ruud, ""Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy"". In Computational Strategies for Spectroscopy.; https://doi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, #",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10268,Security,Validat,Validate,10268,"angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\omega}\hbar`. References; ----------; A. Rizzo, S. Coriani, K. Ruud, ""Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy"". In Computational Strategies for Spectroscopy.; https://doi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelengt",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10457,Security,Validat,Validate,10457,"arameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\omega}\hbar`. References; ----------; A. Rizzo, S. Coriani, K. Ruud, ""Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy"". In Computational Strategies for Spectroscopy.; https://doi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:12055,Security,Validat,Validate,12055,"verters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x); y = prefactor * x * np.sum([transform_residue(r) * shape.lineshape(p) for p, r in zip(poles, residues)], axis=0). # Generate sticks; sticks = prefactor * np.array([p * transform_residue(r) * shape.maximum(p) for p, r in zip(poles, residues)]). return {""convolution"": {""x"": x, ""y"": y}, ""sticks"": {""poles"": poles, ""residues"": sticks}}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.sp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:5085,Testability,log,log,5085,"""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") *",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:6405,Testability,log,log,6405," following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon absorption (OPA) or electronic circular dichroism (ECD); spectra with phenomenological line broadening. This function gives arrays of values ready to be plotted as OPA spectrum:. .. math::. \varepsilon(\omega) =; \frac{4\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}; \sum_{i \rightarrow j}g_{ij}(\omega)|\mathbf{\mu}_{ij}|^{2}. or ECD spectrum:. .. math::. \Delta\varepsilon(\omega) =; \frac{16\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}; \sum_{i \rightarrow j}g_{ij}(\omega)\Im(\mathbf{\mu}_{ij}\cdot\mathbf{m}_{ij}). in macroscopic units of :math:`\mathrm{L}\cdot",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:4654,Deployability,update,updated,4654,"thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:3512,Integrability,message,message,3512,"eters; ----------; seq1; First string.; seq2; Second string. """"""; oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:3586,Integrability,message,message,3586,"eters; ----------; seq1; First string.; seq2; Second string. """"""; oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:3657,Integrability,message,message,3657,"1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:3666,Integrability,Message,Message,3666,"1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:3832,Integrability,message,message,3832,"thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:3890,Integrability,wrap,wrap,3890,"thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:3945,Integrability,message,message,3945,"thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:4278,Integrability,wrap,wrap,4278,"thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html:4247,Modifiability,extend,extend,4247,"thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:1785,Availability,Avail,Available,1785," the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". __all__ = [; ""copy_file_to_scratch"",; ""copy_file_from_scratch"",; ""cubeprop"",; ""get_memory"",; ""oeprop"",; ""set_memory"",; ]. import os; import re; import sys; import warnings; from typing import List, Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args: List[str], **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. :param args:. Arbitrary-number of properties to be computed from *wfn*.; See :ref:`Available One-Electron Properties <table:oe_features>`. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:9496,Deployability,update,updated,9496,"[4]: -mv /tmp/temp /scratch/parrish/psi.12345.32. """"""; pid = str(os.getpid()); scratch = core.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp'; if move:; cp = '/bin/mv'. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s %s/%s' % (cp, filename, scratch, target)). os.system(command). [docs]def copy_file_from_scratch(filename: str, prefix: str, namespace: str, unit: int, move: bool = False):; """"""Move a file out of scratch following the naming convention. Parameters; ----------. filename; Full path to target file.; prefix; Computation prefix, usually 'psi'.; namespace; Context namespace, usually molecule name.; unit; Unit number, e.g. 32; move; Whether to copy (default) or move?. Examples; --------. >>> # Assume PID is 12345 and SCRATCH is /scratch/parrish/; >>> copy_file_to_scratch('temp', 'psi', 'h2o', 32):; Out[1]: -cp /scratch/parrish/psi.12345.h2o.32 .temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; Out[2]: -cp /scratch/parrish/psi.12345.h2o.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; Out[3]: -cp /scratch/parrish/psi.12345.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; Out[4]: -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = core.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp'; if move:; cp = '/bin/mv'. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.util. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:1978,Energy Efficiency,energy,energy,1978,"are Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". __all__ = [; ""copy_file_to_scratch"",; ""copy_file_from_scratch"",; ""cubeprop"",; ""get_memory"",; ""oeprop"",; ""set_memory"",; ]. import os; import re; import sys; import warnings; from typing import List, Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args: List[str], **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. :param args:. Arbitrary-number of properties to be computed from *wfn*.; See :ref:`Available One-Electron Properties <table:oe_features>`. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:2858,Energy Efficiency,energy,energy,2858,"; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:3122,Energy Efficiency,energy,energy,3122,"UPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When Tru",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:1456,Security,Validat,ValidationError,1456,"you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". __all__ = [; ""copy_file_to_scratch"",; ""copy_file_from_scratch"",; ""cubeprop"",; ""get_memory"",; ""oeprop"",; ""set_memory"",; ]. import os; import re; import sys; import warnings; from typing import List, Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args: List[str], **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. :param args:. Arbitrary-number of properties to be computed from *wfn*.; See :ref:`Available One-Electron Properties <table:oe_features>`. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Comp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:3450,Security,Validat,ValidationError,3450,"lumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:4147,Security,Validat,ValidationError,4147,". """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. >>> # Good examples; >>> psi4.set_memory(800000000) # 800000000; >>> psi4.set_memory(2004088624.9) # 2004088624; >>> psi4.set_memory(1.0e9) # 1000000000; >>> psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_mem",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:5623,Security,Validat,ValidationError,5623," psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory() -> int:; """"""Retur",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:5736,Security,Validat,ValidationError,5736,"b') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory() -> int:; """"""Return the total memory allocation in bytes.""""""; return core.get_memory(). [docs]def copy_file_to_scratch(filename: ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:6330,Security,Validat,ValidationError,6330," float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory() -> int:; """"""Return the total memory allocation in bytes.""""""; return core.get_memory(). [docs]def copy_file_to_scratch(filename: str, prefix: str, namespace: str, unit: int, move: bool = False):; """"""Move a file into scratch following the naming convention. Parameters; ----------; filename; Full path to file.; prefix; Computation prefix, usually 'psi'.; namespace; Context namespace, usually molecule name.; unit; Unit number, e.g. 32.; move; Whether to copy (default) or move?. Examples; --------. >>> # Assume PID is 12345 and SCRATCH is /scratch/parrish/; >>> copy_file_to_scratch('temp', 'psi', 'h2o', 32):; Out[1]: -cp ./temp /scratch/parrish/psi.12345.h2o.32; >>> copy_file",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:2211,Availability,avail,available,2211,"D LICENSE; #. import collections; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; from qcengine.testing import _programs as _programs_qcng. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engines in capable.items():; capable_sorted_by_available[disp] = sorted(engines, key=lambda x: (not programs_disp[x], x)). return capable_sorted_by_available. [docs]class EmpiricalDispersion():; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"", ""nl"", ""dmp2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ""d4bjeeqatm""}; Name of dispersion correction to be ap",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:5784,Availability,error,error,5784,"isp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; param_tweaks; Values for the same keys as `dashcoeff[dashlevel]['default']`; (and same order if list) used to override any or all values; initialized by `name_hint`. Extra parameters will error.; engine; Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine; Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp; Whether to request atomic pairwise analysis. """"""; def __init__(self, *, name_hint: str = None, level_hint: str = None, param_tweaks: Union[Dict, List] = None, engine: str = None, gcp_engine: str = None, save_pairwise_disp: bool = False):; from .dft import dashcoeff_supplement; self.dashcoeff_supplement = dashcoeff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:14350,Deployability,update,updated,14350,"_part.add(gcp_part). return dashd_part; else:; return self.disp.compute_gradient(molecule). [docs] def compute_hessian(self,; molecule: core.Molecule,; wfn: core.Wavefunction = None) -> core.Matrix:; """"""Compute dispersion Hessian based on engine, dispersion level, and parameters in `self`.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; Matrix; (3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. """"""; optstash = p4util.OptionsState(['PRINT'], ['PARENT_SYMMETRY']); core.set_global_option('PRINT', 0). core.print_out(""\n\n Analytical Dispersion Hessians are not supported by any engine.\n""); core.print_out("" Computing the Hessian through finite difference of gradients.\n\n""). # Setup the molecule; molclone = molecule.clone(); molclone.reinterpret_coordentry(False); molclone.fix_orientation(True); molclone.fix_com(True). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molclone, -1); for displacement in findif_meta_dict[""displacements""].values():; geom_array = np.reshape(displacement[""geometry""], (-1, 3)); molclone.set_geometry(core.Matrix.from_array(geom_array)); molclone.update_geometry(); displacement[""gradient""] = self.compute_gradient(molclone).np.ravel().tolist(). H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, -1); if wfn is not None:; wfn.set_variable('DISPERSION CORRECTION HESSIAN', H); optstash.restore(); return core.Matrix.from_array(H). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.empirical_dispersion. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:5027,Energy Efficiency,ENERGY,ENERGY,5027,"eference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; `qcengine.programs.empirical_dispersion_resources.dashcoeff` itself for purposes of; validating :py:attr:`fctldash`.; engine : str; {'libdisp', ""s-dftd3"", 'dftd3', 'nl', 'mp2d', ""dftd4""}; Compute engine for dispersion. One of Psi4's internal libdisp; library, external Grimme or Beran projects, or nl.; disp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; param_tweaks; Values for the same keys as `dashcoeff[dashlevel]['default']`; (and same order if list) used to override any or all values; initialized by `name_hint`. Extra parameters will error.; engine; Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8644,Energy Efficiency,energy,energy,8644,"ion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(;",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8878,Energy Efficiency,energy,energy,8878,"aise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSIO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8936,Energy Efficiency,ENERGY,ENERGY,8936,"3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in j",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9072,Energy Efficiency,ENERGY,ENERGY,9072,"n <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca).",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9218,Energy Efficiency,energy,energy,9218,"cription); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_varia",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9879,Energy Efficiency,ENERGY,ENERGY,9879,"[Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS""]). if self.fctldash in ['hf3c', 'pbeh3c']:; jobrec = qcng.compute(; resi,; self.gcp_engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}); gcp_part = jobrec.return_result; dashd_part += gcp_part. return dashd_part. else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_variable(f""{self.fctldash} DISPERSION CORRECTION ENERGY"", ene); return ene. [docs] def compute_gradient(self,; molecule: core.Mole",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:10713,Energy Efficiency,ENERGY,ENERGY,10713,"scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS""]). if self.fctldash in ['hf3c', 'pbeh3c']:; jobrec = qcng.compute(; resi,; self.gcp_engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}); gcp_part = jobrec.return_result; dashd_part += gcp_part. return dashd_part. else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_variable(f""{self.fctldash} DISPERSION CORRECTION ENERGY"", ene); return ene. [docs] def compute_gradient(self,; molecule: core.Molecule,; wfn: core.Wavefunction = None) -> core.Matrix:; """"""Compute dispersion gradient based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; Matrix; (nat, 3) dispersion gradient [Eh/a0]. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'gradient',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:10805,Energy Efficiency,ENERGY,ENERGY,10805,"reads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS"",; jobrec.extras['qcvars'][""2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS""]). if self.fctldash in ['hf3c', 'pbeh3c']:; jobrec = qcng.compute(; resi,; self.gcp_engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}); gcp_part = jobrec.return_result; dashd_part += gcp_part. return dashd_part. else:; ene = self.disp.compute_energy(molecule); core.set_variable('DISPERSION CORRECTION ENERGY', ene); if self.fctldash:; core.set_variable(f""{self.fctldash} DISPERSION CORRECTION ENERGY"", ene); return ene. [docs] def compute_gradient(self,; molecule: core.Molecule,; wfn: core.Wavefunction = None) -> core.Matrix:; """"""Compute dispersion gradient based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; Matrix; (nat, 3) dispersion gradient [Eh/a0]. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'gradient',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOM",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:3332,Modifiability,flexible,flexible,3332," for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engines in capable.items():; capable_sorted_by_available[disp] = sorted(engines, key=lambda x: (not programs_disp[x], x)). return capable_sorted_by_available. [docs]class EmpiricalDispersion():; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"", ""nl"", ""dmp2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ""d4bjeeqatm""}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashparams : dict; Complete set of parameter values defining the flexible parts; of :py:attr:`dashlevel`. Number and parameter names vary by; :py:attr:`dashlevel`. Resolved into a complete set (keys of; dashcoeff[dashlevel]['default']) from `name_hint` and/or; `dashcoeff_supplement` and/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""ble",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:2063,Safety,detect,detection,2063,"g; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; from qcengine.testing import _programs as _programs_qcng. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engines in capable.items():; capable_sorted_by_available[disp] = sorted(engines, key=lambda x: (not programs_disp[x], x)). return capable_sorted_by_available. [docs]class EmpiricalDispersion():; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"", ""nl"", ""dmp2"", ""d3zero2",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:1457,Security,Validat,ValidationError,1457,"s.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; from qcengine.testing import _programs as _programs_qcng. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collec",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:4556,Security,validat,validating,4556,"/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; `qcengine.programs.empirical_dispersion_resources.dashcoeff` itself for purposes of; validating :py:attr:`fctldash`.; engine : str; {'libdisp', ""s-dftd3"", 'dftd3', 'nl', 'mp2d', ""dftd4""}; Compute engine for dispersion. One of Psi4's internal libdisp; library, external Grimme or Beran projects, or nl.; disp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `da",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:7520,Security,Validat,ValidationError,7520,"ff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.ordered_params = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. capable_engines_for_disp = _capable_engines_for_disp(); if engine is None:; self.engine = capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(f""This little engine ({engine}) can't ({self.dashlevel})""). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:7870,Security,Validat,ValidationError,7870,"s = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.ordered_params = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. capable_engines_for_disp = _capable_engines_for_disp(); if engine is None:; self.engine = capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(f""This little engine ({engine}) can't ({self.dashlevel})""). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion ener",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:2253,Testability,test,testing,2253,"s import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; from qcengine.testing import _programs as _programs_qcng. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engines in capable.items():; capable_sorted_by_available[disp] = sorted(engines, key=lambda x: (not programs_disp[x], x)). return capable_sorted_by_available. [docs]class EmpiricalDispersion():; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"", ""nl"", ""dmp2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ""d4bjeeqatm""}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashpara",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:6061,Usability,simpl,simple-,6061,"N ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; param_tweaks; Values for the same keys as `dashcoeff[dashlevel]['default']`; (and same order if list) used to override any or all values; initialized by `name_hint`. Extra parameters will error.; engine; Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine; Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp; Whether to request atomic pairwise analysis. """"""; def __init__(self, *, name_hint: str = None, level_hint: str = None, param_tweaks: Union[Dict, List] = None, engine: str = None, gcp_engine: str = None, save_pairwise_disp: bool = False):; from .dft import dashcoeff_supplement; self.dashcoeff_supplement = dashcoeff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.order",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:5556,Availability,fault,fault,5556,"_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:5820,Availability,Error,Error,5820,"cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13009,Availability,error,error,13009,"D >>>'); # for item in c4grad:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13026,Availability,ERROR,ERROR,13026,"D >>>'); # for item in c4grad:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:17438,Availability,Fault,Faulty,17438,"from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13144,Deployability,update,update,13144,"r instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalqua",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:17911,Deployability,update,updated,17911,"from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:2047,Energy Efficiency,energy,energy,2047,"Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:4221,Energy Efficiency,energy,energy,4221,"e. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. If path kwarg is; specified, also looks there preferentially for a GENBAS. Can; also specify GENBAS within an input file through a string and; setting the genbas kwarg. Note that due to the input parser's; aggression, blank lines need to be replaced by the text blankline. """"""; lowername = name.lower(); internal_p4c4_info = {}; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_N",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13273,Energy Efficiency,energy,energy,13273,"alse; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~dri",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13804,Energy Efficiency,ENERGY,ENERGY,13804,"out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Returns string with con",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:14248,Energy Efficiency,energy,energy,14248,"ose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', Fal",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:1192,Integrability,interface,interface,1192,".driver.procrouting.interface_cfour; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; cor",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:1710,Integrability,wrap,wrappers,1710,"n the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:6039,Integrability,message,message,6039,"environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:6076,Integrability,interface,interface,6076,"environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:6399,Integrability,message,message,6399,"s.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:8363,Integrability,message,message,8363,"reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:8488,Integrability,message,message,8488,".outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.harvest(qcdbmolecule, c4out, **c4files). # Absorb results into psi4 data ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:2316,Modifiability,Variab,Variables,2316,"de from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:4975,Modifiability,variab,variables,4975,"active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13046,Modifiability,variab,variables,13046,"f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:14645,Modifiability,Variab,Variables,14645,"nction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_sy",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:2081,Performance,optimiz,optimize,2081,"10-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT wi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:5630,Performance,Load,Load,5630," scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:5906,Performance,load,loaded,5906,"# Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:6622,Performance,load,loaded,6622," # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from e",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:7342,Performance,load,loaded,7342,"ule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:15982,Performance,load,loaded,15982,"memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; qbs = core.BasisSet.build(molecule, ""BASIS"", core.get_global_option('BASIS')); if qbs.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(qbs.genbas()); core.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:2429,Security,access,accessible,2429,"de from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:8472,Security,Validat,ValidationError,8472,".outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.harvest(qcdbmolecule, c4out, **c4files). # Absorb results into psi4 data ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13066,Security,Validat,ValidationError,13066,"f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13571,Security,Validat,ValidationError,13571,"reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:15826,Security,Validat,ValidationError,15826,"rent keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; qbs = core.BasisSet.build(molecule, ""BASIS"", core.get_global_option('BASIS')); if qbs.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(qbs.genbas()); core.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:17485,Security,Validat,ValidationError,17485,"from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13125,Usability,clear,clear,13125,"ch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURREN",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:4907,Availability,avail,available,4907,"module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:12254,Availability,avail,available,12254," mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30819,Availability,avail,available,30819,"_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def selec",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:32253,Availability,avail,available,32253,".get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33144,Availability,avail,available,33144,"nce in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:37420,Availability,error,error,37420,"'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_disp_functor(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", ""DFT_DIS",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:45961,Availability,checkpoint,checkpoint,45961,"ting from converged SCF. """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['INTS_TOLERANCE'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'ORBITALS_WRITE'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Make sure we grab the correctly scoped integral threshold for SCF; core.set_global_option('INTS_TOLERANCE', core.get_option('SCF', 'INTS_TOLERANCE')). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') == ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # decide if we keep the checkpoint file; _chkfile = kwargs.get('write_orbitals', True); write_checkpoint_file = False; if isinstance(_chkfile, str):; write_checkpoint_file = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_g",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:50007,Availability,avail,available,50007,"lif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:55351,Availability,Error,Error,55351,"om basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_opti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:58061,Availability,checkpoint,checkpoint,58061,"OLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # retain with -m (messy) option. if do_timer:; core.tstop(). optstash.restore(). if (not use_c1) or (scf_molecule.schoenflies_symbol() == 'c1'):; return scf_wfn; else:; # C1 copy quietly; c1_optstash = p4util.OptionsState(['PRINT']); core.set_global_option(""PRINT"", 0). # If we force c1 copy the active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True);",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:59796,Availability,avail,available,59796,"he active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); if not scf_wfn.has_variable(""-D ENERGY""):; tmp.del_variable(""-D ENERGY""); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:78977,Availability,avail,avail,78977,"'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:87903,Availability,avail,available,87903,"e.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:93463,Availability,avail,available,93463,")', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:105811,Availability,down,down,105811,"ented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX'):; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:114442,Availability,avail,available,114442,"r(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs). elif name == 'eom-cc2':; user_ref = core.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref); core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs). elif name == 'eom-cc3':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). core.cchbar(ref_wfn); core.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:116850,Availability,avail,available,116850,"defined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") <",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119721,Availability,avail,available,119721,"glet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one);",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:123407,Availability,toler,tolerance,123407,"root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Fea",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:123768,Availability,avail,available,123768,"tation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{lab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131710,Availability,avail,available,131710,"TH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:138065,Availability,avail,available,138065,"TION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:141986,Availability,avail,available,141986,". def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:150995,Availability,avail,available,150995,"'sapt2+3dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', True); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(ccd)', 'sapt2+(ccd)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name in ['sapt2+(3)(ccd)', 'sapt2+(3)(ccd)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name in ['sapt2+3(ccd)', 'sapt2+3(ccd)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', True); core.set_local_option('SAPT', 'DO_CCD_DISP', True). # Make sure we are not going to run CPHF on ROHF, since its MO Hessian; # is not SPD; if core.get_option('SCF', 'REFERENCE') == 'ROHF':; core.set_local_option('SAPT', 'COUPLED_INDUCTION', False); core.print_out(' Coupled induction not available for ROHF.\n'); core.print_out(' Proceeding with uncoupled induction only.\n'). core.print_out("" Constructing Basis Sets for SAPT...\n\n""); aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got inductio",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:162120,Availability,fault,fault,162120,"= mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 file; # and dump a copy into the outfile; core.print_out('\n===== Begin fort.56 input for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prin",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:178937,Availability,Error,Error,178937,"} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'W",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179072,Availability,Error,Error,179072,"CC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179816,Availability,avail,available,179816,"fn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182999,Availability,avail,available,182999,"AS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP I",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1784,Deployability,Upgrade,UpgradeHelper,1784,"FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; modul",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:4307,Deployability,Upgrade,UpgradeHelper,4307,"sage also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD comput",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11984,Deployability,Upgrade,UpgradeHelper,11984,"bal_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30549,Deployability,Upgrade,UpgradeHelper,30549,"tion('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:55768,Deployability,install,installing,55768,"n.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to prin",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:55788,Deployability,install,install,55788,"n.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to prin",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:56131,Deployability,install,installing,56131,"cf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:56153,Deployability,install,install,56153,"cf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72077,Deployability,update,update,72077," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:107595,Deployability,update,update,107595,"A', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). # => Make OEProp calls <=; if n_one > 0:; # ==> Initialize OEProp <==; oe = core.OEProp(ccwfn); for oe_prop_name in one:; oe.add(oe_prop_name.upper()); # ==> OEProp for the ground state <==; # TODO: When Psi is Py 3.9+, transition to the removeprefix version.; title = name.upper().replace(""EOM-"", """"); #title = name.upper().removeprefix(""EOM-""); oe.set_title(title); set_of_names = {title + "" {}"", ""CC {}""}; if name.startswith(""eom""):; gs_h = 0; for h, i in enumerate(ccwfn.soccpi()):; if i % 2:; gs_h = gs_h ^ h; ct = ccwfn.molecule().point_group().char_table(); total_h_lbl = ct.gamma(0).symbol(); gs_h_lbl = ct.gamma(gs_h).symbol(); set_of_names.update({title + "" ROOT 0 {}"", ""CC ROOT 0 {}"",; f""{title} ROOT 0 {{}} - {total_h_lbl} TRANSITION"",; f""CC ROOT 0 {{}} - {total_h_lbl} TRANSITION"",; f""{title} ROOT 0 ({gs_h_lbl}) {{}}"", f""CC ROOT 0 ({gs_h_lbl}) {{}}"",; f""{title} ROOT 0 (IN {gs_h_lbl}) {{}}"", f""CC ROOT 0 (IN {gs_h_lbl}) {{}}""}); oe.set_names(set_of_names); oe.compute(). # ==> OEProp for Excited States <==; if name.startswith('eom'):; n_root_pi = core.get_global_option(""ROOTS_PER_IRREP""); for h in range(ccwfn.nirrep()):; root_h_lbl = ct.gamma(h).symbol(); trans_h_lbl = ct.gamma(h ^ gs_h).symbol(); # Don't forget to count the ground state!; for i in range(n_root_pi[h]):; if h == gs_h: i += 1; root_title = title + f"" ROOT {i} (IN {root_h_lbl})""; oe.set_title(root_title); total_idx = ccwfn.total_index(i, h); set_of_names = {f""{title} ROOT {total_idx} {{}}"", f""CC ROOT {total_idx} {{}}"",; f""{title} ROOT {total_idx} {{}} - {trans_h_lbl} TRANSITION"",; f""CC ROOT {total_idx} {{}} - {trans_h_lbl} TRANSITION"",; f""{title} ROOT {total_idx} ({root_h_lbl}) {{}}"", f""CC ROOT {total_idx} ({root_h_lbl}) {{}}"",; f""{title} ROOT {i} (IN {root_h_lbl}) {{}}"", f""CC ROOT {i} (IN {root_h_lbl}) {",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:111557,Deployability,configurat,configuration,111557," dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_pro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:116865,Deployability,install,installing,116865,"tion('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:116889,Deployability,install,install,116889,"tion('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:116913,Deployability,install,install,116913,"tion('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131271,Deployability,configurat,configuration,131271,"ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROH",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:132331,Deployability,Upgrade,UpgradeHelper,132331,"PTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); level = int(mtdlvl_mobj.group(""level"")); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_option('DETCI', 'WFN', 'DETCI'); co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:183280,Deployability,release,release,183280,"# We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summar",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:184655,Deployability,update,updated,184655,"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1227,Energy Efficiency,energy,energy,1227,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import sol",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:3352,Energy Efficiency,energy,energy,3352,"y.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zap",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:4322,Energy Efficiency,energy,energy,4322,"sage also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD comput",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:4339,Energy Efficiency,energy,energy,4339,"sage also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD comput",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:7052,Energy Efficiency,energy,energy,7052,"r([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11115,Energy Efficiency,energy,energy,11115,"'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11999,Energy Efficiency,energy,energy,11999,"bal_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:12016,Energy Efficiency,energy,energy,12016,"bal_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:13575,Energy Efficiency,energy,energy,13575," the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:15060,Energy Efficiency,energy,energy,15060,"aise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:16604,Energy Efficiency,energy,energy,16604," if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:18091,Energy Efficiency,energy,energy,18091," func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algori",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19895,Energy Efficiency,energy,energy,19895,"name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_M",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:21387,Energy Efficiency,energy,energy,21387,"func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD t",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:22129,Energy Efficiency,energy,energy,22129,"unc is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD through CCENERGY for (RHF|ROHF) not enabled here since not advertised. It does run, though, see #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:24830,Energy Efficiency,energy,energy,24830,"SD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:25578,Energy Efficiency,energy,energy,25578,"ne:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:27890,Energy Efficiency,energy,energy,27890,", **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)"", ""ccsd(t)_l""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:29354,Energy Efficiency,energy,energy,29354,"nc = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif mtd_type == ""CD"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == ""ROHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30088,Energy Efficiency,energy,energy,30088,"run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30564,Energy Efficiency,energy,energy,30564,"tion('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30581,Energy Efficiency,energy,energy,30581,"tion('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31157,Energy Efficiency,energy,energy,31157,"lt modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31894,Energy Efficiency,energy,energy,31894,"""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_opti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33605,Energy Efficiency,energy,energy,33605,"ence, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROH",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:36049,Energy Efficiency,energy,energy,36049,"directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selecting the algorithm for a CC3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:37082,Energy Efficiency,energy,energy,37082,"irecting to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is No",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:42784,Energy Efficiency,charge,charges,42784,"d to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs:; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external po",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:42922,Energy Efficiency,charge,charge,42922,"ptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs:; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:43344,Energy Efficiency,charge,charge,43344,"al EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). for frag, frag_qxyz in external_potential.items():; if frag.upper() in ""ABC"":; chrgfield = QMMMbohr(); for qxyz in frag_qxyz:; chrgfield.extern.addCharge(*validate_qxyz(qxyz)). wfn.set_potential_variable(frag.upper(), chrgfield.extern); total_external_potential.appendCharges(chrgfield.extern.getCharges()). else:; core.print_out(""\n Warning! Unknown key for the external_potentials argument: %s"" % fra",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:51175,Energy Efficiency,Energy,Energy,51175," == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_fil",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:55215,Energy Efficiency,Energy,Energy,55215,"asisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:56634,Energy Efficiency,ENERGY,ENERGY,56634,"get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:56677,Energy Efficiency,ENERGY,ENERGY,56677,"get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:56695,Energy Efficiency,ENERGY,ENERGY,56695,"get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:56723,Energy Efficiency,ENERGY,ENERGY,56723,"get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:59288,Energy Efficiency,ENERGY,ENERGY,59288,"ption(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # retain with -m (messy) option. if do_timer:; core.tstop(). optstash.restore(). if (not use_c1) or (scf_molecule.schoenflies_symbol() == 'c1'):; return scf_wfn; else:; # C1 copy quietly; c1_optstash = p4util.OptionsState(['PRINT']); core.set_global_option(""PRINT"", 0). # If we force c1 copy the active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); if not scf_wfn.has_variable(""-D ENERGY""):; tmp.del_variable(""-D ENERGY""); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:59320,Energy Efficiency,ENERGY,ENERGY,59320,"e); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # retain with -m (messy) option. if do_timer:; core.tstop(). optstash.restore(). if (not use_c1) or (scf_molecule.schoenflies_symbol() == 'c1'):; return scf_wfn; else:; # C1 copy quietly; c1_optstash = p4util.OptionsState(['PRINT']); core.set_global_option(""PRINT"", 0). # If we force c1 copy the active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); if not scf_wfn.has_variable(""-D ENERGY""):; tmp.del_variable(""-D ENERGY""); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:64521,Energy Efficiency,energy,energy,64521,".5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72876,Energy Efficiency,energy,energy,72876,"); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:76700,Energy Efficiency,energy,energy,76700,"ype"": ""SCS"", },; ""custom-scs-mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""scs-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""SCS"", },; ""sos-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""SOS"", },; ""custom-scs-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},. ""remp2"": {""wfn_type"": ""REMP"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:78933,Energy Efficiency,energy,energy,78933,"'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:80808,Energy Efficiency,energy,energy,80808,"component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81035,Energy Efficiency,energy,energy,81035,"iable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81583,Energy Efficiency,ENERGY,ENERGY,81583,"set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_ener",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81722,Energy Efficiency,ENERGY,ENERGY,81722,"'SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81973,Energy Efficiency,ENERGY,ENERGY,81973,"; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssupe",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82049,Energy Efficiency,ENERGY,ENERGY,82049,"FT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().ite",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82138,Energy Efficiency,ENERGY,ENERGY,82138,"core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT '",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82255,Energy Efficiency,ENERGY,ENERGY,82255,"-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82387,Energy Efficiency,ENERGY,ENERGY,82387,"s_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_va",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82455,Energy Efficiency,ENERGY,ENERGY,82455,"ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSI",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82530,Energy Efficiency,ENERGY,ENERGY,82530,"= dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82630,Energy Efficiency,Energy,Energy,82630,"mp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variabl",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82751,Energy Efficiency,Energy,Energy,82751,"leading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); sc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82908,Energy Efficiency,energy,energy,82908,"D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83319,Energy Efficiency,ENERGY,ENERGY,83319,"f_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83343,Energy Efficiency,ENERGY,ENERGY,83343,"f_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83363,Energy Efficiency,ENERGY,ENERGY,83363,"f_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83462,Energy Efficiency,ENERGY,ENERGY,83462,"TAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83512,Energy Efficiency,ENERGY,ENERGY,83512,"fn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83555,Energy Efficiency,ENERGY,ENERGY,83555,"; scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is N",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83606,Energy Efficiency,ENERGY,ENERGY,83606,"t('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83650,Energy Efficiency,ENERGY,ENERGY,83650,"' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'C",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83694,Energy Efficiency,ENERGY,ENERGY,83694,"' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83732,Energy Efficiency,ENERGY,ENERGY,83732,"ut(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83773,Energy Efficiency,ENERGY,ENERGY,83773,"' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83811,Energy Efficiency,ENERGY,ENERGY,83811,"(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83864,Energy Efficiency,ENERGY,ENERGY,83864,"h)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83908,Energy Efficiency,ENERGY,ENERGY,83908,"tal energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(gra",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83959,Energy Efficiency,ENERGY,ENERGY,83959,"re.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", g",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83996,Energy Efficiency,ENERGY,ENERGY,83996," for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88483,Energy Efficiency,ENERGY,ENERGY,88483,"rithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfm",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88522,Energy Efficiency,ENERGY,ENERGY,88522,"not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88577,Energy Efficiency,ENERGY,ENERGY,88577,"se ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION E",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88622,Energy Efficiency,ENERGY,ENERGY,88622,"ce.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89155,Energy Efficiency,ENERGY,ENERGY,89155,"MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD');",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89200,Energy Efficiency,ENERGY,ENERGY,89200,"); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89253,Energy Efficiency,ENERGY,ENERGY,89253,". dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89299,Energy Efficiency,ENERGY,ENERGY,89299,"fn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_opti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89345,Energy Efficiency,ENERGY,ENERGY,89345,"grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_lo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89385,Energy Efficiency,ENERGY,ENERGY,89385,"dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89428,Energy Efficiency,ENERGY,ENERGY,89428,"NT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_op",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89468,Energy Efficiency,ENERGY,ENERGY,89468,"iable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89523,Energy Efficiency,ENERGY,ENERGY,89523," TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89569,Energy Efficiency,ENERGY,ENERGY,89569,"RENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCS",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:91654,Energy Efficiency,energy,energy,91654,", 'WFN', 'CCSD_AT'); core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_AT'); elif name == 'cc2':; core.set_local_option('TRANSQT2', 'WFN', 'CC2'); core.set_local_option('CCSORT', 'WFN', 'CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'CC2'); core.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; core.set_local_option('TRANSQT2', 'WFN', 'CC3'); core.set_local_option('CCSORT', 'WFN', 'CC3'); core.set_local_option('CCTRANSORT', 'WFN', 'CC3'); core.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option(""CC_TYPE"") == ""DF"":; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if ((core.get_option('SCF', 'REFERENCE') == 'ROHF'); and ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driv",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:95283,Energy Efficiency,energy,energy,95283,"ENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-S",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96150,Energy Efficiency,ENERGY,ENERGY,96150,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96183,Energy Efficiency,ENERGY,ENERGY,96183,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96226,Energy Efficiency,ENERGY,ENERGY,96226,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96273,Energy Efficiency,ENERGY,ENERGY,96273,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96302,Energy Efficiency,ENERGY,ENERGY,96302,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96331,Energy Efficiency,ENERGY,ENERGY,96331,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96359,Energy Efficiency,ENERGY,ENERGY,96359,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96393,Energy Efficiency,ENERGY,ENERGY,96393,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96437,Energy Efficiency,ENERGY,ENERGY,96437,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96485,Energy Efficiency,ENERGY,ENERGY,96485,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96515,Energy Efficiency,ENERGY,ENERGY,96515,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96545,Energy Efficiency,ENERGY,ENERGY,96545,"). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97180,Energy Efficiency,ENERGY,ENERGY,97180,"LATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97218,Energy Efficiency,ENERGY,ENERGY,97218,"RELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97268,Energy Efficiency,ENERGY,ENERGY,97268,"CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). fo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97306,Energy Efficiency,ENERGY,ENERGY,97306,"RGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRE",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97345,Energy Efficiency,ENERGY,ENERGY,97345,",; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97398,Energy Efficiency,ENERGY,ENERGY,97398,"ION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELA",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97442,Energy Efficiency,ENERGY,ENERGY,97442,"ION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97707,Energy Efficiency,ENERGY,ENERGY,97707,"le('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdsc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97749,Energy Efficiency,ENERGY,ENERGY,97749,"'BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.g",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97796,Energy Efficiency,ENERGY,ENERGY,97796,"cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanit",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97837,Energy Efficiency,ENERGY,ENERGY,97837,"ITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise Valida",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97890,Energy Efficiency,ENERGY,ENERGY,97890,"not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97931,Energy Efficiency,ENERGY,ENERGY,97931,"tions.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97970,Energy Efficiency,ENERGY,ENERGY,97970,"D iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98010,Energy Efficiency,ENERGY,ENERGY,98010,"D iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98060,Energy Efficiency,ENERGY,ENERGY,98060,"nt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98107,Energy Efficiency,ENERGY,ENERGY,98107,"_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF refere",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98145,Energy Efficiency,ENERGY,ENERGY,98145,"(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_conve",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98169,Energy Efficiency,ENERGY,ENERGY,98169,"(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_conve",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98199,Energy Efficiency,ENERGY,ENERGY,98199,"(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_conve",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98284,Energy Efficiency,ENERGY,ENERGY,98284,"; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98312,Energy Efficiency,ENERGY,ENERGY,98312,"; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98339,Energy Efficiency,ENERGY,ENERGY,98339,"; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98364,Energy Efficiency,ENERGY,ENERGY,98364,"; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98395,Energy Efficiency,ENERGY,ENERGY,98395,"; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98426,Energy Efficiency,ENERGY,ENERGY,98426,"; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98556,Energy Efficiency,energy,energy,98556,"ble(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98572,Energy Efficiency,energy,energy,98572,"ble(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98616,Energy Efficiency,energy,energy,98616,"ble(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110546,Energy Efficiency,ENERGY,ENERGY,110546,"on_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module c",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110589,Energy Efficiency,ENERGY,ENERGY,110589,"tion('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calcu",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110644,Energy Efficiency,ENERGY,ENERGY,110644,"/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110693,Energy Efficiency,ENERGY,ENERGY,110693,"ype (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110757,Energy Efficiency,ENERGY,ENERGY,110757,"_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = [",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110796,Energy Efficiency,ENERGY,ENERGY,110796,"or('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110851,Energy Efficiency,ENERGY,ENERGY,110851," properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110896,Energy Efficiency,ENERGY,ENERGY,110896,"util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in prope",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:120872,Energy Efficiency,energy,energy,120872,"ng interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""C",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121171,Energy Efficiency,energy,energy,121171,"(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_v",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121297,Energy Efficiency,energy,energy,121297,"reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121337,Energy Efficiency,Energy,Energy,121337,"s ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121381,Energy Efficiency,energy,energy,121381,"""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121483,Energy Efficiency,energy,energy,121483,"t_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.ex",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121532,Energy Efficiency,energy,energy,121532,"?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121585,Energy Efficiency,ENERGY,ENERGY,121585," not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excit",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121594,Energy Efficiency,energy,energy,121594," not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excit",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121642,Energy Efficiency,ENERGY,ENERGY,121642,"oper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{met",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121654,Energy Efficiency,energy,energy,121654,"); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121688,Energy Efficiency,Energy,Energy,121688,"n.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.exci",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121718,Energy Efficiency,energy,energy,121718,"n.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.exci",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121759,Energy Efficiency,Energy,Energy,121759,"fn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121852,Energy Efficiency,ENERGY,ENERGY,121852,"(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.prin",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:121912,Energy Efficiency,ENERGY,ENERGY,121912,"a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:122439,Energy Efficiency,ENERGY,ENERGY,122439," state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(toleran",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:122565,Energy Efficiency,ENERGY,ENERGY,122565,"y; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:122677,Energy Efficiency,ENERGY,ENERGY,122677,"ergy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:122789,Energy Efficiency,ENERGY,ENERGY,122789,"15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things availabl",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:128697,Energy Efficiency,ENERGY,ENERGY,128697,"able(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"")",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:128784,Energy Efficiency,ENERGY,ENERGY,128784,", data); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN)""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:128865,Energy Efficiency,ENERGY,ENERGY,128865,"; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRE",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:128938,Energy Efficiency,ENERGY,ENERGY,128938,"oot_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131992,Energy Efficiency,energy,energy,131992,"rmat_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:132347,Energy Efficiency,energy,energy,132347,"PTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); level = int(mtdlvl_mobj.group(""level"")); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_option('DETCI', 'WFN', 'DETCI'); co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:132373,Energy Efficiency,energy,energy,132373,"PTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); level = int(mtdlvl_mobj.group(""level"")); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_option('DETCI', 'WFN', 'DETCI'); co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134731,Energy Efficiency,ENERGY,ENERGY,134731,"ETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENE",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134765,Energy Efficiency,ENERGY,ENERGY,134765,", 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORREL",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135474,Energy Efficiency,ENERGY,ENERGY,135474,"riables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135530,Energy Efficiency,ENERGY,ENERGY,135530,"().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_opt",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135581,Energy Efficiency,ENERGY,ENERGY,135581,"alse; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicaliz",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135627,Energy Efficiency,ENERGY,ENERGY,135627,"iwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.mol",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135677,Energy Efficiency,ENERGY,ENERGY,135677,"print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135727,Energy Efficiency,ENERGY,ENERGY,135727,"ble(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_opti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135773,Energy Efficiency,ENERGY,ENERGY,135773,"NERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135823,Energy Efficiency,ENERGY,ENERGY,135823," good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:136897,Energy Efficiency,ENERGY,ENERGY,136897,"s):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn',",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:136940,Energy Efficiency,ENERGY,ENERGY,136940,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:136995,Energy Efficiency,ENERGY,ENERGY,136995,". """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.ge",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137044,Energy Efficiency,ENERGY,ENERGY,137044,"SIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137108,Energy Efficiency,ENERGY,ENERGY,137108,"obal_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_g",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137147,Energy Efficiency,ENERGY,ENERGY,137147,"t_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the w",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137202,Energy Efficiency,ENERGY,ENERGY,137202,"ut("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(re",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137247,Energy Efficiency,ENERGY,ENERGY,137247,"). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:140291,Energy Efficiency,ENERGY,ENERGY,140291,"_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Alg",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:140673,Energy Efficiency,ENERGY,ENERGY,140673,"_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=Tru",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:140851,Energy Efficiency,ENERGY,ENERGY,140851,"_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142478,Energy Efficiency,ENERGY,ENERGY,142478,"\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_opt",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142524,Energy Efficiency,ENERGY,ENERGY,142524,"""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142582,Energy Efficiency,ENERGY,ENERGY,142582,"n is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142634,Energy Efficiency,ENERGY,ENERGY,142634,"); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142707,Energy Efficiency,ENERGY,ENERGY,142707,"ified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142749,Energy Efficiency,ENERGY,ENERGY,142749,"ymbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). ret",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142807,Energy Efficiency,ENERGY,ENERGY,142807,"MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142855,Energy Efficiency,ENERGY,ENERGY,142855,"""""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:147748,Energy Efficiency,ENERGY,ENERGY,147748,"al_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148391,Energy Efficiency,ENERGY,ENERGY,148391,"SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148937,Energy Efficiency,ENERGY,ENERGY,148937," and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148987,Energy Efficiency,ENERGY,ENERGY,148987,"monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+3', 'sapt2+3",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152143,Energy Efficiency,ENERGY,ENERGY,152143,"asis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152268,Energy Efficiency,ENERGY,ENERGY,152268,"core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule());",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152330,Energy Efficiency,ENERGY,ENERGY,152330,"basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use m",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152418,Energy Efficiency,ENERGY,ENERGY,152418,"IS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152485,Energy Efficiency,ENERGY,ENERGY,152485,"global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152525,Energy Efficiency,ENERGY,ENERGY,152525,"_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_su",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152560,Energy Efficiency,ENERGY,ENERGY,152560,"sis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('mono",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152781,Energy Efficiency,charge,charge-transfer,152781,"port sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:156949,Energy Efficiency,Charge,Charge,156949," True); elif name == 'sapt2+(3)(ccd)-ct':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name == 'sapt2+3(ccd)-ct':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', True); core.set_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ----------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:157311,Energy Efficiency,ENERGY,ENERGY,157311,"t_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:157678,Energy Efficiency,ENERGY,ENERGY,157678,"x_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_chang",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:157820,Energy Efficiency,Charge,Charge,157820,"_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is Non",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:158260,Energy Efficiency,Charge,Charge,158260,"_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of mole",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:158392,Energy Efficiency,ENERGY,ENERGY,158392,"er Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161479,Energy Efficiency,ENERGY,ENERGY,161479,"; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:;",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164214,Energy Efficiency,energy,energy,164214,"threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.va",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164475,Energy Efficiency,ENERGY,ENERGY,164475,"_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORR",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164529,Energy Efficiency,ENERGY,ENERGY,164529,"put file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164669,Energy Efficiency,ENERGY,ENERGY,164669,"xcept OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # De",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164726,Energy Efficiency,ENERGY,ENERGY,164726,"not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False a",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164817,Energy Efficiency,ENERGY,ENERGY,164817,"rogram %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164924,Energy Efficiency,ENERGY,ENERGY,164924,"ram %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164977,Energy Efficiency,ENERGY,ENERGY,164977,"xternal_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep t",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165024,Energy Efficiency,ENERGY,ENERGY,165024,"rror(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do no",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165080,Energy Efficiency,ENERGY,ENERGY,165080,"ut.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMR",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165132,Energy Efficiency,ENERGY,ENERGY,165132,"ta.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165180,Energy Efficiency,ENERGY,ENERGY,165180,"'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165227,Energy Efficiency,ENERGY,ENERGY,165227,"; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165273,Energy Efficiency,ENERGY,ENERGY,165273,"elds = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165331,Energy Efficiency,ENERGY,ENERGY,165331,"s[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165383,Energy Efficiency,ENERGY,ENERGY,165383,""":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.var",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165433,Energy Efficiency,ENERGY,ENERGY,165433," = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165482,Energy Efficiency,ENERGY,ENERGY,165482,"ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165528,Energy Efficiency,ENERGY,ENERGY,165528,"RRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:166613,Energy Efficiency,energy,energy,166613,"e.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). dire",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:167543,Energy Efficiency,energy,energy,167543," sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168108,Energy Efficiency,energy,energy,168108,"er default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; ra",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168282,Energy Efficiency,energy,energy,168282,"int_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis S",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168630,Energy Efficiency,energy,energy,168630,"s Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:170343,Energy Efficiency,energy,energy,170343,"F_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""mp2"": { ""dfcc"": False, ""run_cepa"": False, ""run_mp2"": True, },. ""mp3"": { ""dfcc"": False, ""run_cepa"": False, ""run_mp3"": True, },; ""fno-mp3"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"":",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:172828,Energy Efficiency,energy,energy,172828," True, ""dfcc"": False, ""run_cepa"": False, ""compute_triples"": True, ""run_mp4"": True, ""compute_mp4_triples"": True, },. ""qcisd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:173002,Energy Efficiency,energy,energy,173002,"e, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"",",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:173295,Energy Efficiency,energy,energy,173295,"a"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_R",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174482,Energy Efficiency,energy,energy,174482,"vefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174499,Energy Efficiency,energy,energy,174499,"vefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174638,Energy Efficiency,ENERGY,ENERGY,174638,"('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174688,Energy Efficiency,ENERGY,ENERGY,174688," written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174743,Energy Efficiency,ENERGY,ENERGY,174743,"type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"":",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174799,Energy Efficiency,ENERGY,ENERGY,174799,""" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": Tr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174867,Energy Efficiency,ENERGY,ENERGY,174867,"basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174912,Energy Efficiency,ENERGY,ENERGY,174912," ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174959,Energy Efficiency,ENERGY,ENERGY,174959,"DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:175229,Energy Efficiency,energy,energy,175229,"C"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": False,},; ""fno-lccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": False,},; ""cepa(0)"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singl",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177526,Energy Efficiency,energy,energy,177526,"nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(1)"", ""cepa_no_singles"": False,},. ""cepa(3)"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_b",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177700,Energy Efficiency,energy,energy,177700,"vel"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177981,Energy Efficiency,energy,energy,177981,"un_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:183867,Energy Efficiency,ENERGY,ENERGY,183867,"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:183991,Energy Efficiency,ENERGY,ENERGY,183991,"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:184050,Energy Efficiency,ENERGY,ENERGY,184050,"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:184107,Energy Efficiency,ENERGY,ENERGY,184107,"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:184173,Energy Efficiency,ENERGY,ENERGY,184173,"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:184224,Energy Efficiency,ENERGY,ENERGY,184224,"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.proc. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1952,Integrability,wrap,wrappers,1952,"neral Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:2967,Integrability,message,message,2967,"pers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33881,Integrability,rout,route,33881,"; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:37343,Integrability,rout,routing,37343,"'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_disp_functor(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", ""DFT_DIS",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:37426,Integrability,message,messages,37426,"'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_disp_functor(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", ""DFT_DIS",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:51892,Integrability,rout,routine,51892," base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.bas",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:91761,Integrability,rout,routine,91761,"ore.set_local_option('CCSORT', 'WFN', 'CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'CC2'); core.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; core.set_local_option('TRANSQT2', 'WFN', 'CC3'); core.set_local_option('CCSORT', 'WFN', 'CC3'); core.set_local_option('CCTRANSORT', 'WFN', 'CC3'); core.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option(""CC_TYPE"") == ""DF"":; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if ((core.get_option('SCF', 'REFERENCE') == 'ROHF'); and ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:95354,Integrability,rout,routine,95354,"ls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATI",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119870,Integrability,interface,interface,119870,"nction method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119907,Integrability,interface,interface,119907,"nction method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:163898,Integrability,message,message,163898," for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164019,Integrability,message,message,164019,".print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{s",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:57456,Modifiability,variab,variable,57456,"f_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # reta",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:60761,Modifiability,variab,variables,60761,"ionError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.variables().items():; core.set_variable(k, v). return dct_wfn. def run_dct_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:61886,Modifiability,variab,variables,61886," of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_globa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:65948,Modifiability,variab,variables,65948,"rgs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", """,MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:65999,Modifiability,variab,variables,65999," is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALS",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:69767,Modifiability,variab,variables,69767,"lse:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:69818,Modifiability,variab,variables,69818,"ies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72012,Modifiability,variab,variables,72012," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72088,Modifiability,variab,variables,72088," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72226,Modifiability,variab,variables,72226,"nflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_M",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:73781,Modifiability,variab,variables,73781,", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCS"", },; ""scs(n)-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSN"", },; ""scs-mp2-vdw"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSVDW"",},; ""sos-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOS"", },; ""sos-pi-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOSPI"", },; ""custom-scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:73832,Modifiability,variab,variables,73832,"r(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCS"", },; ""scs(n)-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSN"", },; ""scs-mp2-vdw"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSVDW"",},; ""sos-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOS"", },; ""sos-pi-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOSPI"", },; ""custom-scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""omp2"": ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:77203,Modifiability,variab,variables,77203," ""TRUE"", ""spin_scale_type"": ""NONE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_ty",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:77369,Modifiability,variab,variables,77369,"type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:77423,Modifiability,variab,variables,77423,"USTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:79610,Modifiability,variab,variables,79610," },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:79776,Modifiability,variab,variables,79776,"local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwarg",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:79830,Modifiability,variab,variables,79830,"('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.funct",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81546,Modifiability,variab,variable,81546,"set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_ener",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81696,Modifiability,variab,variable,81696,"'SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81823,Modifiability,variab,variables,81823,"n.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlatio",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:82195,Modifiability,variab,variables,82195,"IT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.d",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83017,Modifiability,variab,variables,83017," DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variable",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83132,Modifiability,variab,variables,83132," SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83407,Modifiability,variab,variable,83407,"lse:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83430,Modifiability,variab,variable,83430,"TAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83529,Modifiability,variab,variable,83529,"; scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is N",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83574,Modifiability,variab,variable,83574,"t('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83667,Modifiability,variab,variable,83667,"' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83713,Modifiability,variab,variable,83713,"ut(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83790,Modifiability,variab,variable,83790,"(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83881,Modifiability,variab,variable,83881,"tal energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(gra",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:83976,Modifiability,variab,variable,83976," for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:84015,Modifiability,variab,variables,84015,"):; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:84064,Modifiability,variab,variables,84064,"# Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten l",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:85195,Modifiability,variab,variables,85195,"""""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:85244,Modifiability,variab,variables,85244," module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional()",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:86444,Modifiability,variab,variables,86444,"proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:86493,Modifiability,variab,variables,86493,"ame). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88357,Modifiability,variab,variables,88357,"has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88502,Modifiability,variab,variable,88502,"not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88596,Modifiability,variab,variable,88596,"ce.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:88655,Modifiability,variab,variables,88655,"ference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89174,Modifiability,variab,variable,89174,"); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89221,Modifiability,variab,variable,89221,". dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89318,Modifiability,variab,variable,89318,"grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_lo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89366,Modifiability,variab,variable,89366,"dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89447,Modifiability,variab,variable,89447,"iable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89542,Modifiability,variab,variable,89542,"RENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCS",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89588,Modifiability,variab,variables,89588," CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN',",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:89639,Modifiability,variab,variables,89639,"dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_AT'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:92982,Modifiability,variab,variables,92982,"x_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if ((core.get_option('SCF', 'REFERENCE') == 'ROHF'); and ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(cc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96694,Modifiability,variab,variable,96694,"et_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96737,Modifiability,variab,variable,96737,"re.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97133,Modifiability,variab,variable,97133,"""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORREC",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97197,Modifiability,variab,variable,97197,"RELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97285,Modifiability,variab,variable,97285,"RGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRE",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97325,Modifiability,variab,variable,97325,",; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97415,Modifiability,variab,variable,97415,"ION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97724,Modifiability,variab,variable,97724,"'BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.g",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97813,Modifiability,variab,variable,97813,"ITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise Valida",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97907,Modifiability,variab,variable,97907,"tions.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:97950,Modifiability,variab,variable,97950,"D iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98077,Modifiability,variab,variable,98077,"_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF refere",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98500,Modifiability,variab,variable,98500,"ion; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDS",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:99861,Modifiability,variab,variables,99861,"CF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in respo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:99906,Modifiability,variab,variables,99906,"list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.a",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:102076,Modifiability,variab,variable,102076,"ties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110565,Modifiability,variab,variable,110565,"tion('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calcu",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110663,Modifiability,variab,variable,110663,"ype (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110776,Modifiability,variab,variable,110776,"or('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110870,Modifiability,variab,variable,110870,"util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in prope",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:111070,Modifiability,variab,variables,111070,"se, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:111121,Modifiability,variab,variables,111121,"ified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Comp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:111557,Modifiability,config,configuration,111557," dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_pro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:123446,Modifiability,variab,variables,123446,"tion_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_pr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:123495,Modifiability,variab,variables,123495,"f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Star",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131042,Modifiability,variab,variables,131042,"# wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131091,Modifiability,variab,variables,131091,"OOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131271,Modifiability,config,configuration,131271,"ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROH",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134464,Modifiability,variab,variables,134464,", 'WFN', 'DETCI'); core.set_local_option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134511,Modifiability,variab,variables,134511,"option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134712,Modifiability,variab,variable,134712,"ETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENE",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134747,Modifiability,variab,variable,134747,", 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORREL",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135310,Modifiability,variab,variable,135310,"files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwarg",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135596,Modifiability,variab,variable,135596,"iwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.mol",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135644,Modifiability,variab,variable,135644,"print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135742,Modifiability,variab,variable,135742,"NERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135790,Modifiability,variab,variable,135790," good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:136916,Modifiability,variab,variable,136916,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137014,Modifiability,variab,variable,137014,"SIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137127,Modifiability,variab,variable,137127,"t_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the w",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137221,Modifiability,variab,variable,137221,"). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137266,Modifiability,variab,variables,137266,"tion is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137317,Modifiability,variab,variables,137317,"'ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:139180,Modifiability,extend,extend,139180,"le(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:139381,Modifiability,extend,extend,139381,". # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sor",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:140778,Modifiability,variab,variable,140778,"rtree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPN",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142500,Modifiability,variab,variable,142500,"""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142604,Modifiability,variab,variable,142604,"); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142729,Modifiability,variab,variable,142729,"ymbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). ret",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142829,Modifiability,variab,variable,142829,"""""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142874,Modifiability,variab,variables,142874,"if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142928,Modifiability,variab,variables,142928," != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:143651,Modifiability,variab,variables,143651," dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:143701,Modifiability,variab,variables,143701,"ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Sh",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144354,Modifiability,variab,variables,144354,"wargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144404,Modifiability,variab,variables,144404," written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144711,Modifiability,variab,variables,144711,"ariable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144764,Modifiability,variab,variables,144764,"un_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = k",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:145316,Modifiability,variab,variables,145316,"tore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); mono",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:145369,Modifiability,variab,variables,145369," space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(mono",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:147722,Modifiability,variab,variable,147722,"al_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148365,Modifiability,variab,variable,148365,"SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148911,Modifiability,variab,variable,148911," and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152285,Modifiability,variab,variable,152285,"ASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Wa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152435,Modifiability,variab,variable,152435,"tion(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_uti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152539,Modifiability,variab,variable,152539,"sis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('mono",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:157293,Modifiability,variab,variable,157293,"t_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:157660,Modifiability,variab,variable,157660,"x_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_chang",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161459,Modifiability,variab,variable,161459,"; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:;",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161864,Modifiability,variab,variables,161864,"ef_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164994,Modifiability,variab,variable,164994,"rror(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do no",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165197,Modifiability,variab,variable,165197,"; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165246,Modifiability,variab,variable,165246,"elds = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165450,Modifiability,variab,variable,165450,"ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165501,Modifiability,variab,variable,165501,"RRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:166325,Modifiability,variab,variables,166325,"ef_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:166374,Modifiability,variab,variables,166374,"ON ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:170062,Modifiability,variab,variables,170062,"onError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:170113,Modifiability,variab,variables,170113,"of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; # Note ""nat_orbs",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174657,Modifiability,variab,variable,174657,"Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174762,Modifiability,variab,variable,174762,"PE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_le",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174886,Modifiability,variab,variable,174886," ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174933,Modifiability,variab,variable,174933,"DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174978,Modifiability,variab,variables,174978,"('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:175029,Modifiability,variab,variables,175029,").has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": False,},; ""fn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179271,Modifiability,variab,variables,179271,"sure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if no",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179322,Modifiability,variab,variables,179322,"oc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SC",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182528,Modifiability,variab,variable,182528,"_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182573,Modifiability,variab,variables,182573,"SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182620,Modifiability,variab,variables,182620,"n('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1237,Performance,optimiz,optimize,1237,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import sol",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:2549,Performance,perform,performance,2549," import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:3400,Performance,perform,performance,3400,"y.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zap",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:5299,Performance,perform,performance,5299,"= 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""F",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:6336,Performance,perform,performance,6336," specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE').",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:7100,Performance,perform,performance,7100,"r([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:7873,Performance,perform,performance,7873," ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'U",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:8595,Performance,perform,performance,8595,"unc = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:9243,Performance,perform,performance,9243,"e in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:9887,Performance,perform,performance,9887,"RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:10533,Performance,perform,performance,10533,", 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; fun",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11163,Performance,perform,performance,11163,"'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:12646,Performance,perform,performance,12646," = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:13623,Performance,perform,performance,13623," the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:14396,Performance,perform,performance,14396,"Error([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:15108,Performance,perform,performance,15108,"aise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:15860,Performance,perform,performance,15860,"me__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:16652,Performance,perform,performance,16652," if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:17429,Performance,perform,performance,17429," module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:18139,Performance,perform,performance,18139," func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algori",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19153,Performance,perform,performance,19153,"y call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19943,Performance,perform,performance,19943,"name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_M",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:20718,Performance,perform,performance,20718,"or([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:21435,Performance,perform,performance,21435,"func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD t",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:22177,Performance,perform,performance,22177,"unc is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD through CCENERGY for (RHF|ROHF) not enabled here since not advertised. It does run, though, see #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:23873,Performance,perform,performance,23873," == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in ["""", ""OCC""]:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:24878,Performance,perform,performance,24878,"SD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:25626,Performance,perform,performance,25626,"ne:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:27041,Performance,perform,performance,27041,"_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:27938,Performance,perform,performance,27938,", **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)"", ""ccsd(t)_l""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:29402,Performance,perform,performance,29402,"nc = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif mtd_type == ""CD"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == ""ROHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30136,Performance,perform,performance,30136,"run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31205,Performance,perform,performance,31205,"lt modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31942,Performance,perform,performance,31942,"""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_opti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:32833,Performance,perform,performance,32833,"; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_t",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33653,Performance,perform,performance,33653,"ence, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROH",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:35078,Performance,perform,performance,35078,"C2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CC2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selectin",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:36097,Performance,perform,performance,36097,"directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selecting the algorithm for a CC3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:62111,Performance,optimiz,optimized,62111,"wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC. Se",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:66211,Performance,optimiz,optimized,66211,"("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:70030,Performance,optimiz,optimized,70030,"ut("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:104359,Performance,Perform,Perform,104359,"in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_globa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:147863,Performance,LOAD,LOAD,147863,"persion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:154151,Performance,LOAD,LOAD,154151,"st; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'); core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF (Dimer Basis)'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.set_global_option('DF_INTS_IO', df_ints_io). core.IO.set_default_namespace('monomerAm'); core.print_out('\n'); p4util.banner('Monomer A HF (Monomer Basis)'); core.print_out('\n'); monomerAm_wfn = scf_helper('RHF', molecule=monomerAm, **kwargs). core.IO.set_default_namespace('monomerBm'); core.print_out('\n'); p4util.banner('Monomer B HF (Monomer Basis)'); core.print_out('\n'); monomerBm_wfn = scf_helper('RHF', molecule=monomerBm,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:162833,Performance,Load,Load,162833,"PATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 file; # and dump a copy into the outfile; core.print_out('\n===== Begin fort.56 input for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165541,Performance,Load,Load,165541,"inue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:2713,Safety,avoid,avoids,2713,"les as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:49771,Safety,Detect,Detected,49771,". castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72138,Safety,risk,risks,72138,"per(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98786,Safety,sanity check,sanity checks,98786,"AL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1799,Security,Validat,ValidationError,1799,"FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; modul",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:32353,Security,access,access,32353,"pe(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33244,Security,access,access,33244,"nt_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and whi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:40342,Security,Validat,ValidationError,40342,"p_type` that quacked; # like a list rather than the more common dict handled above. if; # ever again sighted, make an issue so this code can accommodate. _disp_functor.print_out(); return superfunc, _disp_functor. else:; return superfunc, None. [docs]def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; # Figure out functional and dispersion; superfunc, _disp_functor = build_disp_functor(name, restricted=(reference in [""RKS"", ""RHF""]), **kwargs). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if _disp_functor and _disp_functor.engine != 'nl':; wfn._disp_functor = _disp_functor. # Set the DF basis sets; df_needed = core.get_global_option(""SCF_TYPE"") in [""DF"", ""MEM_DF"", ""DISK_DF"", ""COSX"", ""LINK""]; df_needed |= (core.get_global_option(""SCF_TYPE"") == ""DIRECT"" and core.get_option(""SCF"", ""DF_SCF_GUESS"")); if df_needed:; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis); else:; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()). # Set the relativistic basis sets; if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; decon_basis = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:42429,Security,Validat,ValidationError,42429,"of SAD basis sets; if (core.get_option(""SCF"", ""GUESS"") in [""SAD"", ""SADNO"", ""HUCKEL""]):; sad_basis_list = core.BasisSet.build(wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=wfn.basisset().has_puream(),; return_atomlist=True); wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; # We need to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs:; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_po",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:43320,Security,Validat,ValidationError,43320,"al EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). for frag, frag_qxyz in external_potential.items():; if frag.upper() in ""ABC"":; chrgfield = QMMMbohr(); for qxyz in frag_qxyz:; chrgfield.extern.addCharge(*validate_qxyz(qxyz)). wfn.set_potential_variable(frag.upper(), chrgfield.extern); total_external_potential.appendCharges(chrgfield.extern.getCharges()). else:; core.print_out(""\n Warning! Unknown key for the external_potentials argument: %s"" % fra",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:45837,Security,Validat,ValidationError,45837,"ctions should call; this function, common exceptions being when multireference; SCF is needed or when restarting from converged SCF. """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['INTS_TOLERANCE'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'ORBITALS_WRITE'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Make sure we grab the correctly scoped integral threshold for SCF; core.set_global_option('INTS_TOLERANCE', core.get_option('SCF', 'INTS_TOLERANCE')). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') == ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # decide if we keep the checkpoint file; _chkfile = kwargs.get('write_orbitals', True); write_checkpoint_file = False; if isinstance(_chkfile, str):; write_checkpoint_file = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:47150,Security,Validat,ValidationError,47150,"SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:47747,Security,Validat,ValidationError,47747,"olecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = corresponding_basis(core.get_global_option('BASIS'), 'GUESS')[0]; if guessbasis is None:; guessbasis = '3-21G' # guess of last resort; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:49330,Security,Validat,ValidationError,49330," = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = corresponding_basis(core.get_global_option('BASIS'), 'GUESS')[0]; if guessbasis is None:; guessbasis = '3-21G' # guess of last resort; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE').",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:49752,Security,Validat,ValidationError,49752,". castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:49945,Security,Validat,ValidationError,49945,"lif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:52416,Security,Validat,ValidationError,52416,"andard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.basis_projection(Ca_occ, old_wfn.nalphapi(), old_wfn.basisset(), scf_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, old_wfn.nbetapi(), old_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = old_wfn.name().replace(""KS"", """").replace(""HF"", """"); new_ref = scf_wfn.name().replace(""KS"", """").replace(""HF"", """"); if old_ref != new_ref:; scf_wfn.reset_occ_ = True. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.pat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:54316,Security,Validat,ValidationError,54316,"ue. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.path.isfile(read_filename):; core.print_out(f""\n !!! Unable to find file {read_filename}, defaulting to SAD guess. !!!\n\n""); core.set_local_option('SCF', 'GUESS', 'SAD'); sad_basis_list = core.BasisSet.build(scf_wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; sad_fitting_list = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_fitting_basissets(sad_fitting_list). if cast:; core.print_out(""\n Computing basis projection from %s to %s\n\n"" % (ref_wfn.basisset().name(), base_wfn.basisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:55332,Security,Validat,ValidationError,55332,"om basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_opti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:59760,Security,Validat,ValidationError,59760,"he active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); if not scf_wfn.has_variable(""-D ENERGY""):; tmp.del_variable(""-D ENERGY""); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:62996,Security,Validat,ValidationError,62996,"*kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC. See Capabilities Table at {dtl}""""""). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FA",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:64471,Security,Validat,ValidationError,64471,".5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:65148,Security,Validat,ValidationError,65148,"DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a de",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:67839,Security,Validat,ValidationError,67839,",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:68023,Security,Validat,ValidationError,68023,"F-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:68261,Security,Validat,ValidationError,68261,"""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:68853,Security,Validat,ValidationError,68853,"gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); retu",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:70534,Security,Validat,ValidationError,70534,"HF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_opt",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:71264,Security,Validat,ValidationError,71264,"; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72824,Security,Validat,ValidationError,72824,"); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:73545,Security,Validat,ValidationError,73545,"L_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCS"", },; ""scs(n)-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSN"", },; ""scs-mp2-vdw"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSVDW"",},; ""sos-mp2"": ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:76652,Security,Validat,ValidationError,76652,"ype"": ""SCS"", },; ""custom-scs-mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""scs-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""SCS"", },; ""sos-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""SOS"", },; ""custom-scs-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},. ""remp2"": {""wfn_type"": ""REMP"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:78024,Security,Validat,ValidationError,78024,"iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:78676,Security,Validat,ValidationError,78676,"rgs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:80978,Security,Validat,ValidationError,80978,"iable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:85832,Security,Validat,ValidationError,85832,"-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecul",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:86922,Security,Validat,ValidationError,86922,"rted""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerica",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:87572,Security,Validat,ValidationError,87572,"un_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENER",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:87845,Security,Validat,ValidationError,87845,"e.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:93427,Security,Validat,ValidationError,93427,")', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:95092,Security,Validat,ValidationError,95092,"; del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:95227,Security,Validat,ValidationError,95227,"ENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-S",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98829,Security,Validat,ValidationError,98829,"AL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:100129,Security,Validat,ValidationError,100129,"VERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what so",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:101473,Security,Validat,ValidationError,101473," """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:101582,Security,Validat,Validate,101582,"es'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module cal",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:103478,Security,Validat,ValidationError,103478,"turn scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:. prop = prop.upper(); if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:104104,Security,Validat,ValidationError,104104,"d = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:. prop = prop.upper(); if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everyt",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:104249,Security,Validat,ValidationError,104249,"e.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:104712,Security,Validat,ValidationError,104712,"' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itsel",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:105016,Security,Validat,ValidationError,105016,"ported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type p",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:106401,Security,Validat,ValidationError,106401,", 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX'):; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). # => Make OEProp calls <=; if n_one > 0:; # ==> Initialize OEProp <==; oe = core.OEProp(ccwfn); for oe_prop_name in one:; oe.add(oe_prop_name.upper()); # ==> OEProp for the ground state <==; # TODO: When Psi is Py 3.9+, transition to the removeprefix version.; title = name.upper().replace(""EOM-"", """"); #title = name.upper().removeprefix(""EOM-""); oe.set_title(title); set_of_names = {title + "" {}"", ""CC {}""}; if name.startswith(""eom""):; gs_h = 0; for h, i in e",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:109783,Security,Validat,ValidationError,109783,"_density(root_title + "" ALPHA""); oe.set_Da_so(Da); if not ccwfn.same_a_b_dens():; Db = ccwfn.get_density(root_title + "" BETA""); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:114393,Security,Validat,ValidationError,114393,"r(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs). elif name == 'eom-cc2':; user_ref = core.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref); core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs). elif name == 'eom-cc3':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). core.cchbar(ref_wfn); core.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:116807,Security,Validat,ValidationError,116807,"defined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") <",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:117008,Security,Validat,ValidationError,117008,"on('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:118005,Security,Validat,ValidationError,118005,"; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:118509,Security,Validat,ValidationError,118509,"n.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBIT",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:118699,Security,Validat,ValidationError,118699,"""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC var",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119207,Security,Validat,ValidationError,119207,"ion(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameter",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119318,Security,Validat,ValidationError,119318,"ion(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameter",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119481,Security,Validat,ValidationError,119481,"ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calcul",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119666,Security,Validat,ValidationError,119666,"glet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one);",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:120162,Security,Validat,ValidationError,120162,"c2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.gro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:120352,Security,Validat,ValidationError,120352,"ed, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:124378,Security,Validat,ValidationError,124378,"s(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:125829,Security,Validat,ValidationError,125829,"eturn f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - A TRANSITION"", data_mat). if ""OSCILLATOR_STRENGTH"" in pr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131663,Security,Validat,ValidationError,131663,"TH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131939,Security,Validat,ValidationError,131939,"rmat_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:138034,Security,Validat,ValidationError,138034,"TION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:141407,Security,Validat,ValidationError,141407,"np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if nam",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:141775,Security,Validat,ValidationError,141775,") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:141952,Security,Validat,ValidationError,141952,". def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:146586,Security,Validat,ValidationError,146586," default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(monomerB, ""BASIS"", core.get_global_option(""BASIS"")); nfc_ab = monomerA_basis.n_frozen_core() + monomerB_basis.n_frozen_core(). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False; do_empirical_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:153696,Security,Validat,ValidationError,153696,"t_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'); core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF (Dimer Basis)'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); c",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:159538,Security,Validat,ValidationError,159538,"an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('FISAPT requires requires \""reference rhf\"".'). if ref_wfn is None:; core.timer_on(""FISAPT: Dimer SCF""); ref_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""FISAPT: Dimer SCF""). core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(),; ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"",; core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). sapt_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161236,Security,Validat,ValidationError,161236,"; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch di",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164003,Security,Validat,ValidationError,164003,".print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{s",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:167491,Security,Validat,ValidationError,167491," sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168058,Security,Validat,ValidationError,168058,"er default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; ra",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168218,Security,Validat,ValidationError,168218,"int_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis S",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168582,Security,Validat,ValidationError,168582,"s Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:169075,Security,Validat,ValidationError,169075,"rgy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wf",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:172778,Security,Validat,ValidationError,172778," True, ""dfcc"": False, ""run_cepa"": False, ""compute_triples"": True, ""run_mp4"": True, ""compute_mp4_triples"": True, },. ""qcisd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:172938,Security,Validat,ValidationError,172938,"e, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"",",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:173242,Security,Validat,ValidationError,173242,"a"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_R",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177476,Security,Validat,ValidationError,177476,"nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(1)"", ""cepa_no_singles"": False,},. ""cepa(3)"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_b",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177636,Security,Validat,ValidationError,177636,"vel"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177928,Security,Validat,ValidationError,177928,"un_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179769,Security,Validat,ValidationError,179769,"fn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179998,Security,Validat,ValidationError,179998,"name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwargs); else:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; if (core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV'):; mints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). ref_optstash.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:181962,Security,Validat,ValidationError,181962,"1); mints.integrals(). ref_optstash.restore(). # The DF case; if core.get_option('DETCI', 'MCSCF_TYPE') == 'DF':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). core.print_out("" Constructing Basis Sets for MCSCF...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise V",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182963,Security,Validat,ValidationError,182963,"AS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP I",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:64600,Testability,log,logic,64600," ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", s",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:124782,Testability,assert,assert,124782," # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gaug",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168387,Testability,log,logic,168387,"roc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basis",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:57393,Usability,simpl,simplefilter,57393,"; scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:100410,Usability,simpl,simple,100410,"f_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:113141,Usability,clear,clear,113141,"f', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(); ciwfn.oeprop = oe. # If we have more than one root, compute all data; if nroots > 1:; core.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). core.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:125264,Usability,simpl,simplefilter,125264,"lternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:2455,Availability,error,error,2455,"List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_string(; molstr=molinit,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); molrec = compound_molrec['qm']. elif molinit",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5109,Availability,avail,available,5109,"str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilen",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5178,Availability,avail,available,5178,"self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5860,Availability,avail,available,5860,"t_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5929,Availability,avail,available,5929," def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:37753,Availability,error,error,37753,"turn geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=e",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40542,Availability,error,error,40542,"om']) < 5**(-(prec))] = 0. smol = qcel.molparse.to_string(; molrec,; dtype=dtype,; units=units,; atom_format=atom_format,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43130,Availability,error,error,43130,"oat(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58448,Availability,fault,faulty,58448,"al; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:67796,Deployability,update,updated,67796,"; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1591,Energy Efficiency,charge,charge,1591,"lic License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):;",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5120,Energy Efficiency,Charge,Charge,5120,"self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5223,Energy Efficiency,charge,charge,5223," += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5871,Energy Efficiency,Charge,Charge,5871," def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5974,Energy Efficiency,charge,charge,5974,"alse, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7230,Energy Efficiency,charge,charge,7230," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7258,Energy Efficiency,charge,chargem,7258," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7310,Energy Efficiency,CHARGE,CHARGE,7310," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7322,Energy Efficiency,charge,chargem,7322," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7346,Energy Efficiency,charge,chargem,7346," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7431,Energy Efficiency,charge,charge,7431," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:13760,Energy Efficiency,charge,charge,13760," be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True. return text, options. def format_molecule_for_psi4_xyz(self):; """"""not much examined. """"""; text = """"; if self.nallatom():. factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # append units and any other non-default molecule keywords; text += ""units Angstrom\n""; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += ""no_com\n""; if self.PYfix_orientation:; text += ""no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s%s%d %d\n"" % ("""" if Pfr == 0 else ""--\n"", ""#"" if self.fragment_types[fr] == 'Ghost'; or self.fragment_types[fr] == 'Absent' else """", self.fragment_charges[fr],; self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent' or self.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2a",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:15244,Energy Efficiency,CHARGE,CHARGE,15244,"f.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # TODO keep fix_or? # Jan 2015 turning off fix_or; #self.fix_orientation(True); #self.PYmove_to_com = False; self.update_geometry(). text = """"; text += 'angstrom\n'; text += 'geometry={\n'; dummy = []. for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % (self.symbol(i),; x * factor, y * factor, z * factor); if not self.Z(i):; dummy.append(str(i + 1)) # Molpro atom number is 1-indexed. text += '}\n\n'; text += 'SET,CHARGE=%d\n' % (self.molecular_charge()); text += 'SET,SPIN=%d\n' % (self.multiplicity() - 1) # Molpro wants (mult-1); if len(dummy) > 0:; text += 'dummy,' + ','.join(dummy) + '\n'; return text. def format_molecule_for_cfour(self):; """"""Function to print Molecule in a form readable by Cfour. """"""; self.update_geometry(); factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; #factor = 1.0 if self.PYunits == 'Bohr' else 1.0/psi_bohr2angstroms. text = 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # append atoms and coordentries; for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""GH""),; x * factor, y * factor, z * factor). #for fr in range(self.nfragments()):; # if self.fragment_types[fr] == 'Absent':; # pass; # else:; # for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; # [x, y, z] = self.atoms[at].compute(); # text += '%-2s %17.12f %",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:22622,Energy Efficiency,charge,charge,22622,"format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variabl",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:32331,Energy Efficiency,charge,charge,32331," 1.0e-6 else 0.0; ]. # Determine degeneracy of rotational constants.; degen = 0; for i in range(2):; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:32548,Energy Efficiency,charge,charge,32548,"rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:32714,Energy Efficiency,charge,charge,32714,"Degeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e-8):; """"""Molecule vs. laboratory frame representation (e.g., IR or IIIL). Parameters; ----------; zero : float, optional; S",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40629,Energy Efficiency,energy,energy-only,40629,"ormat,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40681,Energy Efficiency,efficient,efficient,40681,"ormat,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40777,Energy Efficiency,energy,energy,40777,"ional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40811,Energy Efficiency,energy,energy,40811,"ional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40899,Energy Efficiency,energy,energy,40899,"ion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40980,Energy Efficiency,energy,energy,40980,"--; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:42018,Energy Efficiency,ENERGY,ENERGY,42018,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameter",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:42175,Energy Efficiency,ENERGY,ENERGY,42175,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameter",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43217,Energy Efficiency,energy,energy-only,43217,"']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43269,Energy Efficiency,efficient,efficient,43269,"']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43365,Energy Efficiency,energy,energy,43365,"l[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43399,Energy Efficiency,energy,energy,43399,"l[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43480,Energy Efficiency,energy,energy,43480,"; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43554,Energy Efficiency,energy,energy,43554,"; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:44862,Energy Efficiency,ENERGY,ENERGY,44862,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interf",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45019,Energy Efficiency,ENERGY,ENERGY,45019,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interf",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45574,Energy Efficiency,energy,energy,45574,"from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both ene",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45643,Energy Efficiency,energy,energy,45643,"from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both ene",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46268,Energy Efficiency,energy,energy-only,46268,"rogram. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_na",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46320,Energy Efficiency,efficient,efficient,46320,"rogram. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_na",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46435,Energy Efficiency,energy,energy,46435,"correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46469,Energy Efficiency,energy,energy,46469,"correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46550,Energy Efficiency,energy,energy,46550,"nt; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (l",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46624,Energy Efficiency,energy,energy,46624,"nt; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (l",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:47748,Energy Efficiency,ENERGY,ENERGY,47748,"np = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dty",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:47891,Energy Efficiency,ENERGY,ENERGY,47891,"np = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dty",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:55304,Energy Efficiency,charge,charge,55304,"ovenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment_charges']],; molrec['fragment_multiplicities']). self.set_molecular_charge(int(molrec['molecular_charge'])); self.set_multiplicity(molrec['molecular_multiplicity']). self.fix_com(molrec['fix_com']); self.fix_orientation(molrec['fix_orientation']); if 'fix_symmetry' in molrec:; # Save the user-specified symmetry, but don't set it as the point group; # That step occurs in update_geometry, after the atoms are added; self.PYsymmetry_from_i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58153,Energy Efficiency,charge,charge,58153,"ays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58694,Energy Efficiency,adapt,adapted,58694,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:62502,Energy Efficiency,charge,charge,62502," = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,; rgeom=rgeom,; cuniq=cuniq,; runiq=runiq,; do_plot=do_plot,; verbose=verbose,; atoms_map=atoms_map,; run_resorting=run_resorting,; mols_align=mols_align,; run_to_completion=run_to_completion,; run_mirror=run_mirror,; uno_cutoff=uno_cutoff). ageom, amass, aelem, aelez, auniq = solution.align_system(cgeom, cmass, celem, celez, cuniq, reverse=False); adict = qcel.molparse.from_arrays(; geom=ageom,; mass=amass,; elem=aelem,; elez=aelez,; units='Bohr',; molecular_charge=concern_mol.molecular_charge(),; molecular_multiplicity=concern_mol.multiplicity(),; fix_com=True,; fix_orientation=True); if isinstance(concern_mol, Molecule):; amol = Molecule.from_dict(adict); else:; from psi4 import core; amol = core.Molecule.fr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:37939,Integrability,wrap,wrapper,37939,"orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43625,Integrability,wrap,wraps,43625,"BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43664,Integrability,wrap,wraps,43664,"BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45942,Integrability,interface,interface,45942,"erint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:48107,Integrability,wrap,wrapper,48107,"resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dtype`."""""". molrec = self.to_dict(np_out=True); schmol = qcel.molparse.to_schema(molrec, dtype=dtype, units=units); return schmol. [docs] def to_dict(self, force_c1=False, force_units=False, np_out=True):; """"""Serializes instance into Molecule dictionary."""""". self.update_geometry(); molrec = {}.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:60843,Integrability,Wrap,Wraps,60843,"r_multiplicity may not be conservable upon fragmentation; # potentially could do two passes and try to preserve it; fix_com=self.com_fixed(),; fix_orientation=self.orientation_fixed(),; fix_symmetry=(None if self.symmetry_from_input() == '' else self.symmetry_from_input()),; fragment_separators=dcontig['fragment_separators']); if isinstance(self, Molecule):; ret_mol = Molecule.from_dict(molrec); else:; from psi4 import core; ret_mol = core.Molecule.from_dict(molrec). outputs.append(ret_mol). outputs = tuple(outputs); return (frag_pattern, ) + outputs[1:]. [docs] def B787(concern_mol: Union[qcdbmol, psi4.core.Molecule],; ref_mol: Union[qcdbmol, psi4.core.Molecule],; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: bool = False,; run_to_completion: bool = False,; uno_cutoff: float = 1.e-3,; run_mirror: bool = False):; """"""Finds shift, rotation, and atom reordering of `concern_mol` that best; aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`psi4.driver.qcdb.Molecule` or; :py:class:`psi4.core.Molecule`. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters; ----------; concern_mol; Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with `ref_mol`.; ref_mol; Molecule to match.; atoms_map; Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc.; If true, specifying `True` can save much time.; mols_align; Whether `ref_mol` and `concern_mol` have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run t",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1806,Modifiability,extend,extends,1806,". See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:4374,Modifiability,variab,variable,4374,"me,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilena",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:4701,Modifiability,variab,variable,4701,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:21791,Modifiability,variab,variables,21791,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:21868,Modifiability,variab,variables,21868,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:23554,Modifiability,variab,variables,23554,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(),",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:37922,Modifiability,variab,variables,37922,"olstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_c",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43835,Modifiability,extend,extending,43835,"me of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45894,Modifiability,extend,extended,45894,"erint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:54894,Modifiability,variab,variables,54894,"rn mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58694,Modifiability,adapt,adapted,58694,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:51067,Performance,perform,performed,51067," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5058,Safety,detect,detected,5058," comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to tur",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5809,Safety,detect,detected,5809,"dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:56648,Safety,Detect,Detect,56648,"s, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment_charges']],; molrec['fragment_multiplicities']). self.set_molecular_charge(int(molrec['molecular_charge'])); self.set_multiplicity(molrec['molecular_multiplicity']). self.fix_com(molrec['fix_com']); self.fix_orientation(molrec['fix_orientation']); if 'fix_symmetry' in molrec:; # Save the user-specified symmetry, but don't set it as the point group; # That step occurs in update_geometry, after the atoms are added; self.PYsymmetry_from_input = molrec['fix_symmetry'].lower(). ## hack to prevent update_geometry termination upon no atoms; #if nat == 0:; # self.set_lock_frame(True). if not unsettled:; self.update_geometry(). [docs] def BFS(self,; seed_atoms: List = None,; bond_threshold: float = 1.20,; return_arrays: bool = False,; return_molecules: bool = False,; return_molecule: bool = False):; """"""Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters; ----------; self : qcdb.Molecule or psi4.core.Molecule; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`; bond_threshold; Factor beyond average of covalent radii to determine bond cutoff.; return_arrays; If `True`, also return fragments as list of arrays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built fro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:57382,Safety,detect,detected,57382,"etry termination upon no atoms; #if nat == 0:; # self.set_lock_frame(True). if not unsettled:; self.update_geometry(). [docs] def BFS(self,; seed_atoms: List = None,; bond_threshold: float = 1.20,; return_arrays: bool = False,; return_molecules: bool = False,; return_molecule: bool = False):; """"""Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters; ----------; self : qcdb.Molecule or psi4.core.Molecule; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`; bond_threshold; Factor beyond average of covalent radii to determine bond cutoff.; return_arrays; If `True`, also return fragments as list of arrays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1128,Security,hash,hashlib,1128,".molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:4641,Security,access,accessing,4641,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:6545,Security,Validat,ValidationError,6545," """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to mat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:6694,Security,Validat,ValidationError,6694,"lse, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7476,Security,Validat,ValidationError,7476,"e, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.mat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7608,Security,Validat,ValidationError,7608,"name)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:8230,Security,Validat,ValidationError,8230,"GE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.frag",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:8339,Security,Validat,ValidationError,8339,"GE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.frag",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:8943,Security,Validat,ValidationError,8943,"set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / qcel.constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.0407120000",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:9061,Security,Validat,ValidationError,9061,"up(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / qcel.constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:24221,Security,Validat,ValidationError,24221,"ype(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i),; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), ma",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:33460,Security,Validat,ValidationError,33460," = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e-8):; """"""Molecule vs. laboratory frame representation (e.g., IR or IIIL). Parameters; ----------; zero : float, optional; Screen for inertial tensor elements. Returns; -------; str; Representation code IR, IIR, IIIR, IL, IIL, IIIL. When; molecule not in inertial frame, string is prefixed by ""~"". Notes; -----; Not carefully handling degenerate inertial elements. """"""; it = self.inertia_tensor(zero=zero); Iidx = np.argsort(np.diagonal(it)); if np.array_equal(Iidx, np.asarray([1, 2, 0])):; ar = 'IR'; elif np.array_equal(Iidx, np.asarray([2, 0, 1])):; ar = 'IIR'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if n",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:35118,Security,hash,hash,35118,"'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. [docs] def to_arrays(self, dummy: bool = False, ghost_as_dummy: bool = False) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:; """"""Exports coordinate info into NumPy arrays. Parameters; ----------; dummy; Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy; Whether or not to treat ghost atoms as dummies. Returns; -------; geom, mass, elem, elez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geome",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:35937,Security,hash,hashlib,35937,"ez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:36429,Security,hash,hashlib,36429,"l qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:51137,Security,expose,exposed,51137," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:52679,Security,Validat,ValidationError,52679,"_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the difference and; # (2) return the from_arrays filled-in values; # * from.arrays is expecting speclabel ""Co_userlbl"" for elbl, but we're; # sending ""_userlbl"", hence speclabel=False; # * from.arrays sets difference provenance than input mol; forgive = ['elea', 'provenance']. # * from_arrays and comparison lines below are quite unnecessary to; # to_dict, but is included as a check. in practice, only fills in mass; # numbers and heals user chgmult.; try:; validated_molrec = qcel.molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); except qcel.ValidationError as err:; # * this can legitimately happen if total chg or mult has been set; # independently b/c fragment chg/mult not reset. so try again.; print(; """"""Following warning is harmless if you've altered chgmult through `set_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, mol",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:53935,Security,validat,validated,53935,"t_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.s",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58667,Security,Validat,ValidationError,58667,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:67261,Security,Validat,ValidationError,67261,"; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1345,Testability,test,testing,1345,"corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_retur",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:61811,Testability,test,test,61811,"; aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`psi4.driver.qcdb.Molecule` or; :py:class:`psi4.core.Molecule`. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters; ----------; concern_mol; Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with `ref_mol`.; ref_mol; Molecule to match.; atoms_map; Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc.; If true, specifying `True` can save much time.; mols_align; Whether `ref_mol` and `concern_mol` have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:64450,Testability,Test,Tester,64450,"e):; amol = Molecule.from_dict(adict); else:; from psi4 import core; amol = core.Molecule.from_dict(adict). compare_values(; concern_mol.nuclear_repulsion_energy(),; amol.nuclear_repulsion_energy(),; 4,; 'Q: concern_mol-->returned_mol NRE uncorrupted',; verbose=verbose - 1); if mols_align:; compare_values(; ref_mol.nuclear_repulsion_energy(),; amol.nuclear_repulsion_energy(),; 4,; 'Q: concern_mol-->returned_mol NRE matches ref_mol',; verbose=verbose - 1); compare_integers(; True,; np.allclose(ref_mol.geometry(), amol.geometry(), atol=4),; 'Q: concern_mol-->returned_mol geometry matches ref_mol',; verbose=verbose - 1). return rmsd, solution, amol. [docs] def scramble(ref_mol: ""Molecule"",; do_shift: Union[bool, np.ndarray, List] = True,; do_rotate: Union[bool, np.ndarray, List[List]] = True,; do_resort: Union[bool, List] = True,; deflection: float = 1.0,; do_mirror: bool = False,; do_plot: bool = False,; run_to_completion: bool = False,; run_resorting: bool = False,; verbose: int = 1):; """"""Tester for B787 by shifting, rotating, and atom shuffling `ref_mol` and; checking that the aligner returns the opposite transformation. Parameters; ----------; ref_mol; Molecule to perturb.; do_shift; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate; Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort; Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`).; To specify shuffle, supply a nat-element list of indices.; deflection; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror; Whether to construct the mirror image structure by inverting y-axis.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; By construction, scrambled s",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:65651,Testability,test,test,65651,"_shift; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate; Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort; Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`).; To specify shuffle, supply a nat-element list of indices.; deflection; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror; Whether to construct the mirror image structure by inverting y-axis.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, `True` turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting; Even if atoms not shuffled, test the resorting machinery.; verbose; Print level. Returns; -------; None. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); nat = rgeom.shape[0]. perturbation = qcel.molutil.compute_scramble(; rgeom.shape[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_c",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:1380,Availability,toler,tolerance,1380," file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Toleranc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:1889,Availability,toler,tolerance,1889," FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2096,Availability,toler,tolerance,2096,". import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2136,Availability,error,error,2136,"ols; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2278,Availability,failure,failure,2278,"elemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; che",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2389,Availability,Toler,Tolerances,2389,"y max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:;",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2513,Availability,toler,tolerance,2513,"mega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:10925,Availability,toler,tolerance,10925,"s in diff (xyz) arrangements); idx_sort_wi_degen = np.lexsort(; (idx_max_elem_each_normco[istart:istart + degree], max_elem_each_normco[istart:istart + degree])); idx_vib_reordering[istart:istart + degree] = np.arange(istart, istart + degree)[idx_sort_wi_degen]. arr2 = arr[:, idx_vib_reordering]. reorderings = ['{}-->{}'.format(i, v) for i, v in enumerate(idx_vib_reordering) if (i != v)]; if reorderings and verbose >= 2:; print('Degenerate modes reordered:', ', '.join(reorderings)). return arr2. def _phase_cols_to_max_element(arr, tol=1.e-2, verbose=1):; """"""Returns copy of 2D `arr` scaled such that, within cols, max(fabs); element is positive. If max(fabs) is pos/neg pair, scales so first; element (within `tol`) is positive. """"""; arr2 = np.copy(arr). rephasing = []; for v in range(arr.shape[1]):; vextreme = 0.0; iextreme = None. # find most extreme value; for varr in arr[:, v]:; vextreme = max(np.absolute(varr), vextreme). # find the first index whose fabs equals that value, w/i tolerance; for iarr, varr in enumerate(arr[:, v]):; if (vextreme - np.absolute(varr)) < tol:; iextreme = iarr; break. sign = np.sign(arr[iextreme, v]); if sign == -1.:; rephasing.append(str(v)); arr2[:, v] *= sign. if rephasing and verbose >= 2:; print('Negative modes rephased:', ', '.join(rephasing)). return arr2. [docs]def harmonic_analysis(hess: np.ndarray, geom: np.ndarray, mass: np.ndarray, basisset: psi4.core.BasisSet, irrep_labels: List[str], dipder: np.ndarray = None, project_trans: bool = True, project_rot: bool = True) -> Tuple[Dict[str, Datum], str]:; """"""Extract frequencies, normal modes and other properties from electronic Hessian. Like so much other Psi4 goodness, originally by @andysim. Parameters; ----------; hess; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; geom; (nat, 3) geometry [a0] at which Hessian computed.; mass; (nat,) atomic masses [u].; basisset; Basis set object (can be dummy, e.g., STO-3G) for SALCs.; irrep_labels; Irreducible representat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:18997,Availability,down,downhill,18997,"(qcel.constants.na * qcel.constants.hartree2J * 1.0e19) /; (2 * np.pi * qcel.constants.c * qcel.constants.bohr2angstroms)); pre_frequency_cm_1 = np.lib.scimath.sqrt(pre_force_constant_au) * uconv_cm_1. pre_lowfreq = np.where(np.real(pre_frequency_cm_1) < 100.0)[0]; pre_lowfreq = np.append(pre_lowfreq, np.arange(nrt_expected)) # catch at least nrt modes; for lf in set(pre_lowfreq):; vlf = pre_frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' pre-proj low-frequency mode: {:9.4f}i [cm^-1]'.format(vlf.real, vlf.imag)); else:; text.append(' pre-proj low-frequency mode: {:9.4f} [cm^-1]'.format(vlf.real, '')); text.append(' pre-proj all modes:' + str(_format_omega(pre_frequency_cm_1, 4))). # project & solve; mwhess_proj = np.dot(P.T, mwhess).dot(P); text.append(mat_symm_info(mwhess_proj, lbl='projected mass-weighted Hessian') + f' ({nrt})'). #print('projhess = ', np.array_repr(mwhess_proj)); force_constant_au, qL = np.linalg.eigh(mwhess_proj). # expected order for vibrations is steepest downhill to steepest uphill; idx = np.argsort(force_constant_au); force_constant_au = force_constant_au[idx]; qL = qL[:, idx]; qL = _phase_cols_to_max_element(qL); vibinfo['q'] = Datum('normal mode', 'a0 u^1/2', qL, comment='normalized mass-weighted'). # frequency, LAB II.17; frequency_cm_1 = np.lib.scimath.sqrt(force_constant_au) * uconv_cm_1; vibinfo['omega'] = Datum('frequency', 'cm^-1', frequency_cm_1). # degeneracies; ufreq, uinv, ucts = np.unique(np.around(frequency_cm_1, 1), return_inverse=True, return_counts=True); vibinfo['degeneracy'] = Datum('degeneracy', '', ucts[uinv]). # look among the symmetry subspaces h for one to which the normco; # of vib does *not* add an extra dof to the vector space; active = []; irrep_classification = []; for idx, vib in enumerate(frequency_cm_1):. if vec_in_space(qL[:, idx], TRspace, 1.0e-4):; active.append('TR'); irrep_classification.append(None). else:; active.append('V'). for h in Uh.keys():; if vec_in_space(qL[:, idx], Uh[h], 1.0e-4):; ir",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:42777,Deployability,update,updated,42777,"p.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.qcdb.vib. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:14211,Energy Efficiency,reduce,reduced,14211," +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | x | normal mode, normalized un-mass-weighted | a0 | ndarray(ndof, ndof) float |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | degeneracy | degree of degeneracy | | ndarray(ndof) int |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | TRV | translation/rotation/vibration | | ndarray(ndof) str 'TR' or 'V' or '-' for partial |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | gamma | irreducible representation | | ndarray(ndof) str irrep or None if unclassifiable |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | mu | reduced mass | u | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | k | force constant | mDyne/A | ndarray(ndof) float (+/-) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | DQ0 | RMS deviation v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(n",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:15637,Energy Efficiency,energy,energy,15637," | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.li",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:21431,Energy Efficiency,reduce,reduced,21431,"cted)) # catch at least nrt modes; for lf in set(lowfreq):; vlf = frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' post-proj low-frequency mode: {:9.4f}i [cm^-1] ({})'.format(vlf.imag, active[lf])); else:; text.append(' post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intens",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:21670,Energy Efficiency,reduce,reduced,21670,"post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:22206,Energy Efficiency,meter,meter,22206,"qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_intens_D2A2u); ir_intensity_kmmol = ir_intensity * uconv_kmmol; vibinfo['IR_intensity'] = Datum('infrared intensity', 'km/mol', ir_intensity_kmmol). # force constants, LAB II.16 (real compensates for earlier sqrt); uconv_mdyne_a = (0.1 * (2 * np.pi * qcel.constants.c)**2) / qcel.constants.na; force_constant_mdyne_a = reduced_mass_u * (frequency_cm_1 * frequency_cm_1).real * uconv_mdyne_a; vibinfo['k'] = Datum('force constant', 'mDyne/A', force_constant_mdyne_a). force_constant_cm_1_bb = reduced_mass_u * (f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:25360,Energy Efficiency,reduce,reduced,25360,"ts.c / qcel.constants.kb; vib_temperature_K = frequency_cm_1.real * uconv_K; vibinfo['theta_vib'] = Datum('char temp', 'K', vib_temperature_K). return vibinfo, '\n'.join(text). def _br(string):; return '[' + string + ']'. def _format_omega(omega, decimals):; """"""Return complex frequencies in `omega` into strings showing only real or imag (""i""-labeled); to `decimals` precision. """"""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(""""""{:.{prec}f}i"""""".format(fr.imag, prec=decimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requeste",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:25840,Energy Efficiency,reduce,reduced,25840,"cimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:27806,Energy Efficiency,Reduce,Reduced,27806,"= 24; if groupby == -1:; groupby = len(active). omega_str = _format_omega(vibinfo['omega'].data, decimals=prec). text = ''; for row in grouper(active, groupby):. text += """"""\n{:{presp}}{:{prewidth}}"""""".format('', 'Vibration', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; # ran out of vibrations in this row; break; text += """"""{:^{width}d}{:{colsp}}"""""".format(vib + 1, '', width=width, colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('', 'Freq [cm^-1]', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}} """""".format(omega_str[vib], width=width); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('', 'Irrep', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; break; val = vibinfo['gamma'].data[vib]; if val is None:; val = ''; text += """"""{:^{width}}{:{colsp}}"""""".format(val, '', width=width, colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'Reduced mass ' + _br(vibinfo['mu'].units),; prewidth=prewidth,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}{:{colsp}}"""""".format(vibinfo['mu'].data[vib],; '',; width=width,; prec=prec,; colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'Force const ' + _br(vibinfo['k'].units),; prewidth=prewidth,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}{:{colsp}}"""""".format(vibinfo['k'].data[vib],; '',; width=width,; prec=prec,; colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'Turning point v=0 ' + _br(vibinfo['Xtp0'].units),; prewidth=prewidth,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}{:{colsp}}"""""".format(vibinfo['Xtp0'].data[vib],; '',; width=width,; prec=prec,; colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'RMS dev v=0 ' + _br(vibinfo['DQ0'].units),; prewidth=prewidth,; presp=presp); for vib i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:30898,Energy Efficiency,energy,energy,30898,"[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:30952,Energy Efficiency,ENERGY,ENERGY,30952,"[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:33633,Energy Efficiency,reduce,reduced,33633,"const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['ele",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37101,Energy Efficiency,Energy,Energy,37101," [kcal/mol] {:11.3f} [kJ/mol] {:15.8f} [Eh]""""""; uconv = np.asarray([qcel.constants.hartree2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, E",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37156,Energy Efficiency,energy,energy,37156,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37206,Energy Efficiency,energy,energy,37206,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37293,Energy Efficiency,energy,energy,37293,""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); tex",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37594,Energy Efficiency,energy,energy,37594,"t = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37681,Energy Efficiency,Energy,Energy,37681,"a). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of norm",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37843,Energy Efficiency,energy,energy,37843,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:38192,Energy Efficiency,energy,energy,38192,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2142,Integrability,message,messages,2142,"ols; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:40125,Integrability,depend,dependencies,40125," remove=[i for i, d in enumerate(allvibs['gamma'].data) if d != 'A1']). """"""; work = {}; if remove is None:; remove = [idx for idx, dat in enumerate(vibinfo['TRV'].data) if dat != 'V']; for asp, oasp in vibinfo.items():; if asp in ['q', 'w', 'x']:; axis = 1; else:; axis = 0; work[asp] = Datum(oasp.label, oasp.units, np.delete(oasp.data, remove, axis=axis), comment=oasp.comment, numeric=False). return work. [docs]def filter_omega_to_real(omega: np.ndarray) -> np.ndarray:; """"""Returns ndarray (float) of `omega` (complex) where imaginary entries are converted to negative reals.""""""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(-1 * fr.imag); else:; freqs.append(fr.real); return np.asarray(freqs). def _get_TR_space(m: np.ndarray, geom: np.ndarray, space: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); as",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:3285,Modifiability,extend,extend,3285,"red; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and asp in toldict:; ktol = toldict[asp]; else:; ktol = tol. if asp in 'qwx':; ccnc = _phase_cols_to_max_element(computed[asp].data); eenc = _phase_cols_to_max_element(expected[asp].data); ccnc = _check_degen_modes(ccnc, computed['omega'].data); eenc = _check_degen_modes(eenc, expected['omega'].data); same = np.allclose(eenc, ccnc, atol=ktol); print_stuff(asp=asp, same=same, ref=eenc, val=ccnc, space='\n'); same = _check_rank_degen_modes(ccnc, computed[""omega""].data, eenc, difftol=ktol, svdtol=svdtol). elif asp in ['gamma', 'TRV']:; same = all([computed[asp].data[idx] == val for idx, val in enumerate(expected[asp].data)]); print_stuff(asp=asp, same=same, ref=expected[asp].data, val=computed[asp].data). elif isinstance(expected[asp].data, float):; same = abs(expected[asp].data - computed[asp].data) < ktol; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:30802,Performance,Perform,Perform,30802,"'\n'. if shortlong:; for at in range(nat):; text += """"""{:{presp}}{:5d} {:{width}}"""""".format('',; at + 1,; atom_lbl[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constan",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:15911,Security,Validat,ValidationError,15911,"--+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.linalg.matrix_rank(geom) == 1:; nrt_expected = 5; else:; nrt_expected = 6. nmwhess = hess.copy(); text.append(mat_symm_info(nmwhess, lbl='non-mass-weighted Hessian') + ' (0)'). # get SALC object, possibly w/o trans & rot; mints = psi4.core.MintsHelper(basisset); cdsalcs = mints.cdsalcs(0xFF, project_tran",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:26306,Security,Validat,ValidationError,26306,"coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if groupby == -1:; groupby = len(active). omega_str = _format_omega(vibinfo['omega'].data, decimals=prec). text = ''; for row in grouper(active, groupby):. text += """"""\n{:{presp}}{:{prewidth}}"""""".format('', 'Vibration', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; # ran out of vibrations in this row; break; text += """"""{:^{width}d}{:{colsp}}"""""".format(vib + 1, '', width=width, colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('', 'Freq [cm^-1]', prewidth=pre",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:5713,Testability,test,tested,5713,"metrize(hess: np.ndarray, mol: psi4.core.Molecule) -> np.ndarray:; """"""Apply Abelian symmetry of `mol` to Hessian `hess`. Parameters; ----------; hess; (3 * nat, 3 * nat) Hessian array perhaps with jitter unbecoming a symmetric molecule.; mol; Molecule at which Hessian computed. Returns; -------; numpy.ndarray; (3 * nat, 3 * nat) symmetrized Hessian array. """"""; ct = mol.point_group().char_table(). # Obtain atom mapping of atom * symm op to atom; atom_map = compute_atom_map(mol). syms = []; smap = []; for g in range(ct.order()):; syms.append(np.asarray(ct.symm_operation(g).d)); smap.append([atom_map[at][g] for at in range(mol.natom())]). np.set_printoptions(formatter={'float': '{: 16.12f}'.format}); b_hess = blockwise_expand(hess, (3, 3), False). bDG = []; nat = b_hess.shape[0]; for iat in range(nat):; for jat in range(nat):; for sym in range(len(syms)):; bDG.append(np.zeros_like(b_hess)); bDG[sym][iat, jat] = syms[sym].dot(b_hess[iat, jat].dot(syms[sym])); # Note that tested syms all diagonal, so above may be off by some transposes. for sym in range(len(syms)):; bDG[sym] = bDG[sym][:, smap[sym]]; bDG[sym] = bDG[sym][smap[sym], :]; tot = np.sum(bDG, axis=0); tot = np.divide(tot, len(syms)). print('symmetrization diff:', np.linalg.norm(tot - b_hess)); m_tot = blockwise_contract(tot); return m_tot. [docs]def print_molden_vibs(vibinfo: Dict[str, Datum], atom_symbol: Union[np.ndarray, List[str]], geom: Union[np.ndarray, List[List[float]]], standalone: bool = True) -> str:; """"""Format vibrational analysis for Molden. Parameters; ----------; vibinfo; Holds results of vibrational analysis.; atom_symbol; (nat,) element symbols for geometry of vibrational analysis.; geom; (nat, 3) geometry of vibrational analysis [a0].; standalone; Whether returned string prefixed ""[Molden Format]"" for standalone rather than append. Returns; -------; str; `vibinfo` formatted for Molden, including FREQ, FR-COORD, & FR-NORM-COORD fields. Notes; -----; Molden format spec from http://www.cmbi.ru.nl",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32042,Testability,log,log,32042,"ty of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32294,Testability,log,log,32294,"RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibon",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32650,Testability,log,log,32650,"minfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32948,Testability,log,log,32948,"y; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')]",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:33909,Testability,log,log,33909,"; sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uco",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:34185,Testability,assert,assert,34185,"a(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uconv_R_EhK = qcel.constants.R / qcel.constants.hartree2kJmol; for piece in ['S', 'Cv', 'Cp']:; sm[(piece, term)] *= uconv_R_EhK # [mEh/K] <-- []; for piece in ['ZPE', 'E', 'H', 'G']:; sm[(piece, term)] *= uconv_R_EhK * 0.001 # [Eh] <-- [K]. # sum corrections and totals; for piece in ['S', 'Cv', ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:40936,Testability,assert,assert,40936,"e: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in sp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:40984,Testability,assert,assert,40984,"se: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41031,Testability,assert,assert,41031,"zed translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41078,Testability,assert,assert,41078,"geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it run",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41126,Testability,assert,assert,41126,"encies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]).",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41173,Testability,assert,assert,41173,"toms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41221,Testability,assert,assert,41221,") otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=Fals",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41353,Testability,assert,assert,41353,"ray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41596,Usability,ux,ux,41596,", 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41768,Usability,ux,ux,41768,"1 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.qcdb.vib. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 1",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41870,Usability,ux,ux,41870,"1 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.qcdb.vib. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 1",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41919,Usability,ux,ux,41919,"1 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.qcdb.vib. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 1",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.AngularMomentumInt.html:527,Deployability,update,updated,527,"﻿. AngularMomentumInt. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt. AngularMomentumInt¶. class psi4.core.AngularMomentumInt¶; Bases: OneBodyAOInt; Computes angular momentum integrals. table of contents. AngularMomentumInt; AngularMomentumInt. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.AngularMomentumInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.AngularMomentumInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.AOShellCombinationsIterator.html:1393,Deployability,update,updated,1393,"﻿. AOShellCombinationsIterator. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator. AOShellCombinationsIterator¶. class psi4.core.AOShellCombinationsIterator¶; Bases: pybind11_object; Attributes Summary. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Summary. first(self); docstring. is_done(self); docstring. next(self); docstring. Attributes Documentation. p¶; Returns current P index. q¶; Returns current Q index. r¶; Returns current R index. s¶; Returns current S index. Methods Documentation. first(self: psi4.core.AOShellCombinationsIterator) → None¶; docstring. is_done(self: psi4.core.AOShellCombinationsIterator) → bool¶; docstring. next(self: psi4.core.AOShellCombinationsIterator) → None¶; docstring. table of contents. AOShellCombinationsIterator; AOShellCombinationsIterator; AOShellCombinationsIterator.p; AOShellCombinationsIterator.q; AOShellCombinationsIterator.r; AOShellCombinationsIterator.s; AOShellCombinationsIterator.first(); AOShellCombinationsIterator.is_done(); AOShellCombinationsIterator.next(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.AOShellCombinationsIterator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.AOShellCombinationsIterator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html:547,Deployability,update,updated,547,"﻿. array_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable¶. psi4.core.array_variable(key: str) → psi4.core.Matrix¶; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html:281,Modifiability,variab,variable,281,"﻿. array_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable¶. psi4.core.array_variable(key: str) → psi4.core.Matrix¶; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html:542,Deployability,update,updated,542,"﻿. array_variables. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables¶. psi4.core.array_variables() → Dict[str, psi4.core.Matrix]¶; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variables. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html:272,Modifiability,variab,variables,272,"﻿. array_variables. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables¶. psi4.core.array_variables() → Dict[str, psi4.core.Matrix]¶; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; array_variables. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisExtents.html:1092,Deployability,update,updated,1092,"﻿. BasisExtents. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BasisExtents. BasisExtents¶. class psi4.core.BasisExtents¶; Bases: pybind11_object; docstring; Methods Summary. basis(self); docstring. delta(self); docstring. maxR(self); docstring. set_delta(self, arg0); docstring. shell_extents(self); docstring. Methods Documentation. basis(self: psi4.core.BasisExtents) → psi4.core.BasisSet¶; docstring. delta(self: psi4.core.BasisExtents) → float¶; docstring. maxR(self: psi4.core.BasisExtents) → float¶; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float) → None¶; docstring. shell_extents(self: psi4.core.BasisExtents) → psi4.core.Vector¶; docstring. table of contents. BasisExtents; BasisExtents; BasisExtents.basis(); BasisExtents.delta(); BasisExtents.maxR(); BasisExtents.set_delta(); BasisExtents.shell_extents(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BasisExtents. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisExtents.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisExtents.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisFunctions.html:1333,Deployability,update,updated,1333,"﻿. BasisFunctions. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions. BasisFunctions¶. class psi4.core.BasisFunctions¶; Bases: pybind11_object; docstring; Methods Summary. basis_values(self); docstring. compute_functions(self, arg0); docstring. deriv(self); docstring. max_functions(self); docstring. max_points(self); docstring. set_deriv(self, arg0); docstring. Methods Documentation. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi4.core.BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. set_deriv(self: psi4.core.BasisFunctions, arg0: int) → None¶; docstring. table of contents. BasisFunctions; BasisFunctions; BasisFunctions.basis_values(); BasisFunctions.compute_functions(); BasisFunctions.deriv(); BasisFunctions.max_functions(); BasisFunctions.max_points(); BasisFunctions.set_deriv(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisFunctions.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:3883,Availability,avail,available,3883,"oes it correspond to. blend(self: psi4.core.BasisSet) → str¶; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False)¶; Build a primary or auxiliary basis set. Parameters:. mol (Molecule) – Molecule for which to build the basis set instance.; key (Optional[str]) – {‘BASIS’, ‘ORBITAL’, ‘DF_BASIS_SCF’, ‘DF_BASIS_MP2’, ‘DF_BASIS_CC’, ‘BASIS_RELATIVISTIC’, ‘DF_BASIS_SAD’}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None]) – Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str) – {‘ORBITAL’, ‘JKFIT’, ‘RIFIT’, ‘DECON’}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; can’t complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None]) – Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int) – Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; pur",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:10270,Deployability,update,updated,10270,"int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int) → int¶; Return the i’th shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int) → int¶; Return the atomic center for the i’th shell. static zero_ao_basis_set() → psi4.core.BasisSet¶; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BasisSet. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:1927,Integrability,depend,depending,1927,"respond to. genbas(self); Returns basis set per atom in CFOUR format. has_ECP(self); Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self, arg0, arg1); Translate a given atom by a given amount. n_ecp_core(*args, **kwargs); Overloaded function. n_ecp_shell_on_center(self, i); Return the number of ECP shells on a given center. n_frozen_core(self[, local, molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self, i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell_on_center(self, c, i); Return the i'th shell on center. shell_to_ao_function(self, i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self, i); Given a shell return its first basis function. shell_to_center(self, i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int) → int¶; Given a cartesian function (AO) number what shell does it corr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:2013,Integrability,contract,contractions,2013,"Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self, arg0, arg1); Translate a given atom by a given amount. n_ecp_core(*args, **kwargs); Overloaded function. n_ecp_shell_on_center(self, i); Return the number of ECP shells on a given center. n_frozen_core(self[, local, molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self, i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell_on_center(self, c, i); Return the i'th shell on center. shell_to_ao_function(self, i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self, i); Given a shell return its first basis function. shell_to_center(self, i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int) → int¶; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet) → str¶; Plus-separated string of [basisna",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:2746,Integrability,contract,contraction,2746,"llback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self, i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell_on_center(self, c, i); Return the i'th shell on center. shell_to_ao_function(self, i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self, i); Given a shell return its first basis function. shell_to_center(self, i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int) → int¶; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet) → str¶; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False)¶; Build a primary or auxiliary basis set. Parameters:. mol (Molecule) – Molecule for which to build the basis set instance.; key (Optional[str]) – {‘BASIS’, ‘ORBITAL’, ‘DF_BASIS_SCF’, ‘DF_BASIS_MP2’, ‘DF_BASIS_CC’, ‘BASIS_RELATIVISTIC’, ‘DF_BASIS_SAD’}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None]) – Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely fr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:7793,Integrability,depend,depending,7793,"oes not affect the underlying molecule object. n_ecp_core(*args, **kwargs)¶; Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None) → int¶; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet) → str¶; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet) → int¶; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet) → int¶; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet) → int¶; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet) → int¶; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int) → int¶; Return the i’th shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th she",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:7906,Integrability,contract,contractions,7906,"psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None) → int¶; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet) → str¶; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet) → int¶; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet) → int¶; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet) → int¶; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet) → int¶; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int) → int¶; Return the i’th shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its first basis function",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:9144,Integrability,contract,contraction,9144,"ts detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int) → int¶; Return the i’th shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int) → int¶; Return the atomic center for the i’th shell. static zero_ao_basis_set() → psi4.core.BasisSet¶; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:4102,Usability,simpl,simple,4102,"omlist=False, *, quiet=False)¶; Build a primary or auxiliary basis set. Parameters:. mol (Molecule) – Molecule for which to build the basis set instance.; key (Optional[str]) – {‘BASIS’, ‘ORBITAL’, ‘DF_BASIS_SCF’, ‘DF_BASIS_MP2’, ‘DF_BASIS_CC’, ‘BASIS_RELATIVISTIC’, ‘DF_BASIS_SAD’}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None]) – Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str) – {‘ORBITAL’, ‘JKFIT’, ‘RIFIT’, ‘DECON’}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; can’t complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None]) – Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int) – Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; puream and this puream argument.; return_atomlist (bool) – Build one-atom basis sets (e.g., for SAD) rather than one whole-mol; basis set.; quiet (bool) – When True, do not print to the output file. Ret",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:592,Deployability,update,updated,592,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:262,Integrability,rout,routines,262,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:300,Integrability,rout,routine,300,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:225,Performance,Perform,Perform,225,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:233,Testability,benchmark,benchmark,233,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:592,Deployability,update,updated,592,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:262,Integrability,rout,routines,262,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:300,Integrability,rout,routine,300,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:225,Performance,Perform,Perform,225,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:233,Testability,benchmark,benchmark,233,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:621,Deployability,update,updated,621,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:280,Integrability,rout,routines,280,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:318,Integrability,rout,routine,318,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:243,Performance,Perform,Perform,243,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:251,Testability,benchmark,benchmark,251,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:582,Deployability,update,updated,582,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:293,Integrability,rout,routine,293,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:221,Performance,Perform,Perform,221,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:252,Performance,perform,performance,252,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:229,Testability,benchmark,benchmark,229,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html:687,Deployability,update,updated,687,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html:240,Performance,Perform,Perform,240,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html:248,Testability,benchmark,benchmark,248,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html:295,Testability,Benchmark,Benchmark,295,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:591,Deployability,update,updated,591,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:302,Integrability,rout,routine,302,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:207,Performance,Perform,Perform,207,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:215,Testability,benchmark,benchmark,215,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.be_quiet.html:523,Deployability,update,updated,523,"﻿. be_quiet. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; be_quiet. be_quiet¶. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). Doesn’t work with Windows. table of contents. be_quiet; be_quiet(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; be_quiet. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.be_quiet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.be_quiet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BlockOPoints.html:1747,Deployability,update,updated,1747,"﻿. BlockOPoints. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints. BlockOPoints¶. class psi4.core.BlockOPoints¶; Bases: pybind11_object; docstring; Methods Summary. functions_local_to_global(self); docstring. npoints(self); docstring. parent_atom(self); Returns the atom number this BlockOfPoints belongs to. print_out(self[, out_fname, print]); docstring. refresh(self); docstring. shells_local_to_global(self); docstring. w(self). x(self). y(self). z(self). Methods Documentation. functions_local_to_global(self: psi4.core.BlockOPoints) → List[int]¶; docstring. npoints(self: psi4.core.BlockOPoints) → int¶; docstring. parent_atom(self: psi4.core.BlockOPoints) → int¶; Returns the atom number this BlockOfPoints belongs to. print_out(self: psi4.core.BlockOPoints, out_fname: str = 'outfile', print: int = 2) → None¶; docstring. refresh(self: psi4.core.BlockOPoints) → None¶; docstring. shells_local_to_global(self: psi4.core.BlockOPoints) → List[int]¶; docstring. w(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. x(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. y(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. z(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. table of contents. BlockOPoints; BlockOPoints; BlockOPoints.functions_local_to_global(); BlockOPoints.npoints(); BlockOPoints.parent_atom(); BlockOPoints.print_out(); BlockOPoints.refresh(); BlockOPoints.shells_local_to_global(); BlockOPoints.w(); BlockOPoints.x(); BlockOPoints.y(); BlockOPoints.z(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BlockOPoints.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BlockOPoints.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html:488,Deployability,update,updated,488,"﻿. BoysLocalizer. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer¶. class psi4.core.BoysLocalizer¶; Bases: Localizer; Performs Boys orbital localization. table of contents. BoysLocalizer; BoysLocalizer. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html:203,Performance,Perform,Performs,203,"﻿. BoysLocalizer. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer¶. class psi4.core.BoysLocalizer¶; Bases: Localizer; Performs Boys orbital localization. table of contents. BoysLocalizer; BoysLocalizer. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1694,Availability,error,error,1694,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:2058,Deployability,update,updated,2058,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:346,Modifiability,extend,extend,346,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:883,Modifiability,extend,extend,883,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:930,Modifiability,extend,extend,930,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1009,Modifiability,Extend,Extend,1009," .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The P",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1071,Modifiability,extend,extend,1071,"I4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1133,Modifiability,Extend,Extend,1133,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1811,Modifiability,extend,extend,1811,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:247,Usability,clear,clear,247,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:260,Usability,Clear,Clear,260,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:694,Usability,clear,clear,694,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:742,Usability,Clear,Clear,742,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1781,Usability,clear,clear,1781,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccdensity.html:504,Deployability,update,updated,504,"﻿. ccdensity. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccdensity. ccdensity¶. psi4.core.ccdensity(ref_wfn: psi4.core.CCWavefunction) → float¶; Runs the code to compute coupled cluster density matrices. table of contents. ccdensity; ccdensity(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccdensity. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccdensity.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccdensity.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html:491,Deployability,update,updated,491,"﻿. ccenergy. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy¶. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccenergy. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html:242,Energy Efficiency,energy,energy,242,"﻿. ccenergy. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy¶. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccenergy. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cceom.html:486,Deployability,update,updated,486,"﻿. cceom. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cceom. cceom¶. psi4.core.cceom(ref_wfn: psi4.core.CCWavefunction) → float¶; Runs the equation of motion coupled cluster code for excited states. table of contents. cceom; cceom(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cceom. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cceom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cceom.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cchbar.html:487,Deployability,update,updated,487,"﻿. cchbar. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cchbar. cchbar¶. psi4.core.cchbar(ref_wfn: psi4.core.Wavefunction) → None¶; Runs the code to generate the similarity transformed Hamiltonian. table of contents. cchbar; cchbar(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cchbar. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cchbar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cchbar.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cclambda.html:501,Deployability,update,updated,501,"﻿. cclambda. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cclambda. cclambda¶. psi4.core.cclambda(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the coupled cluster lambda equations code. table of contents. cclambda; cclambda(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cclambda. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cclambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cclambda.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccresponse.html:497,Deployability,update,updated,497,"﻿. ccresponse. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccresponse. ccresponse¶. psi4.core.ccresponse(ref_wfn: psi4.core.Wavefunction) → float¶; Runs the coupled cluster response theory code. table of contents. ccresponse; ccresponse(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ccresponse. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccresponse.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccresponse.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctransort.html:542,Deployability,update,updated,542,"﻿. cctransort. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cctransort. cctransort¶. psi4.core.cctransort(ref_wfn: psi4.core.Wavefunction) → None¶; Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. table of contents. cctransort; cctransort(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cctransort. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cctransort.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctransort.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html:485,Deployability,update,updated,485,"﻿. cctriples. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples¶. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction) → float¶; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cctriples. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html:233,Energy Efficiency,energy,energy,233,"﻿. cctriples. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples¶. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction) → float¶; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; cctriples. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1440,Availability,error,error,1440," 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1991,Deployability,update,updated,1991," 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:432,Energy Efficiency,energy,energy-sorted,432,"﻿. CCWavefunction. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1144,Energy Efficiency,energy,energy,1144," 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1639,Energy Efficiency,energy,energy-sorted,1639," 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:878,Integrability,depend,depending,878,"﻿. CCWavefunction. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1339,Modifiability,variab,variable,1339," 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction¶. class psi4.core.CCWavefunction¶; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalc.html:1041,Deployability,update,updated,1041,"﻿. CdSalc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CdSalc. CdSalc¶. class psi4.core.CdSalc¶; Bases: pybind11_object; Cartesian displacement SALC; Methods Summary. irrep(self); Return the irrep bit representation. irrep_index(self); Return the irrep index. print_out(self); Print the irrep index and the coordinates of the SALC of Cartesian displacements. Methods Documentation. irrep(self: psi4.core.CdSalc) → str¶; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc) → int¶; Return the irrep index. print_out(self: psi4.core.CdSalc) → None¶; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. table of contents. CdSalc; CdSalc; CdSalc.irrep(); CdSalc.irrep_index(); CdSalc.print_out(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CdSalc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html:2025,Deployability,update,updated,2025,"++ and Python; CdSalcList. CdSalcList¶. class psi4.core.CdSalcList¶; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self, basename, factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self, h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self, i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList) → int¶; Return the number of irreps. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html:227,Energy Efficiency,adapt,adapted,227,"﻿. CdSalcList. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList¶. class psi4.core.CdSalcList¶; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self, basename, factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self, h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self, i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList) → int¶; Return the number of irreps. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. © Copyright 2007-2023, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html:227,Modifiability,adapt,adapted,227,"﻿. CdSalcList. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList¶. class psi4.core.CdSalcList¶; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self, basename, factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self, h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self, i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList) → int¶; Return the number of irreps. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. © Copyright 2007-2023, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CharacterTable.html:1203,Deployability,update,updated,1203,"﻿. CharacterTable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CharacterTable. CharacterTable¶. class psi4.core.CharacterTable¶; Bases: pybind11_object; Contains the character table of the point group; Methods Summary. gamma(self, arg0); Returns the irrep with the given index in the character table. order(self); Return the order of the point group. symm_operation(self, arg0); Return the i'th symmetry operation. Methods Documentation. gamma(self: psi4.core.CharacterTable, arg0: int) → psi4.core.IrreducibleRepresentation¶; Returns the irrep with the given index in the character table. order(self: psi4.core.CharacterTable) → int¶; Return the order of the point group. symm_operation(self: psi4.core.CharacterTable, arg0: int) → psi4.core.SymmetryOperation¶; Return the i’th symmetry operation. 0-indexed. table of contents. CharacterTable; CharacterTable; CharacterTable.gamma(); CharacterTable.order(); CharacterTable.symm_operation(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CharacterTable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CharacterTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CharacterTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIVector.html:2961,Deployability,update,updated,2961,"loat, arg1: psi4.core.CIVector, arg2: int, arg3: int) → None¶; docstring. close_io_files(self: psi4.core.CIVector, arg0: int) → None¶; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int) → None¶; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int) → float¶; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int) → None¶; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool) → None¶; docstring. norm(self: psi4.core.CIVector, arg0: int) → float¶; docstring. read(self: psi4.core.CIVector, arg0: int, arg1: int) → int¶; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int) → None¶; docstring. set_nvec(self: psi4.core.CIVector, arg0: int) → None¶; docstring. shift(self: psi4.core.CIVector, arg0: float, arg1: int) → None¶; docstring. symnormalize(self: psi4.core.CIVector, arg0: float, arg1: int) → None¶; docstring. vdot(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int) → float¶; docstring. vector_multiply(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: psi4.core.CIVector, arg3: int, arg4: int, arg5: int) → None¶; docstring. write(self: psi4.core.CIVector, arg0: int, arg1: int) → int¶; docstring. zero(self: psi4.core.CIVector) → None¶; docstring. table of contents. CIVector; CIVector; CIVector.np; CIVector.axpy(); CIVector.close_io_files(); CIVector.copy(); CIVector.dcalc(); CIVector.divide(); CIVector.init_io_files(); CIVector.norm(); CIVector.read(); CIVector.scale(); CIVector.set_nvec(); CIVector.shift(); CIVector.symnormalize(); CIVector.vdot(); CIVector.vector_multiply(); CIVector.write(); CIVector.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CIVector. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CIVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIVector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html:7641,Deployability,update,updated,7641,"(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. table of contents. CIWavefunction; CIWavefunction; CIWavefunction.D_vector(); CIWavefunction.Hd_vector(); CIWavefunction.ci_nat_orbs(); CIWavefunction.cleanup_ci(); CIWavefunction.cleanup_dpd(); CIWavefunction.compute_state_transfer(); CIWavefunction.diag_h(); CIWavefunction.form_opdm(); CIWavefunction.form_tpdm(); CIWavefunction.get_dimension(); CIWavefunction.get_opdm(); CIWavefunction.get_orbitals(); CIWavefunction.get_tpdm(); CIWavefunction.hamiltonian(); CIWavefunction.mcscf_object(); CIWavefunction.ndet(); CIWavefunction.new_civector(); CIWavefunction.opdm(); CIWavefunction.pitzer_to_ci_order_onel(); CIWavefunction.pitzer_to_ci_order_twoel(); CIWavefunction.print_vector(); CIWavefunction.reset_ci_H0block(); CIWavefunction.rotate_mcscf_integrals(); CIWavefunction.semicanonical_orbs(); CIWavefunction.set_ci_guess(); CIWavefunction.set_orbitals(); CIWavefunction.sigma(); CIWavefunction.tpdm(); CIWavefunction.transform_ci_integrals(); CIWavefunction.transform_mcscf_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CIWavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html:4039,Integrability,contract,contract,4039,"ulations.; Jroot (int) – The index of the root in the ket. Select -1 for the same as Iroot.; Always use -1 for single-state calculations.; spin (str) – {‘A’, ‘B’, ‘SUM’}; Return the alpha density matrix, the beta density matrix, or their sum?; full_space (bool) – Return a density matrix in the space of all orbitals (true) or the active orbitals (false)?. Returns:; The selected one-particle density/transition matrix with Pitzer-ordered orbitals.; Irrep h of the matrix corresponds to orbitals of irrep h.; Element pq is <ψ|a^p a_q|ψ>. Return type:; Matrix. get_orbitals(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Matrix¶; docstring. get_tpdm(self: psi4.core.CIWavefunction, spin: str, symmetrize: bool) → psi4.core.Matrix¶; Returns the two-particle density matrix. Parameters:. spin (str) – {“AA”, “AB”, “BB”, “SUM”}; Which spin-block of the TPDM should be returned? SUM sums over all possible spin cases.; symmetrize (bool) – Return a genuine TPDM element (false) or an “average” of TPDM elements that contract with the same integral (true)?; Only working for SUM. Returns:; The two-particle density matrix with Pitzer-ordered orbitals, restricted to the active space.; If symmetrize is false, element pqrs is <ψ|a^p a^r a_s a_q|ψ>.; If symmetrize is true, element pqrs is obtained by summing over all “flips” of p/s, q/r, and multiplying by 0.5. Return type:; Matrix. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix¶; docstring. mcscf_object(self: psi4.core.CIWavefunction) → psi4.core.SOMCSCF¶; docstring. ndet(self: psi4.core.CIWavefunction) → int¶; docstring. new_civector(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: bool, arg3: bool) → psi4.core.CIVector¶; docstring. opdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector) → None¶; docstri",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean.html:436,Deployability,update,updated,436,"﻿. clean. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean. clean¶. psi4.core.clean() → None¶; Remove scratch files. Call between independent jobs. table of contents. clean; clean(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_options.html:469,Deployability,update,updated,469,"﻿. clean_options. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean_options. clean_options¶. psi4.core.clean_options() → None¶; Reset options to clean state. table of contents. clean_options; clean_options(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean_options. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_timers.html:544,Deployability,update,updated,544,"﻿. clean_timers. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean_timers. clean_timers¶. psi4.core.clean_timers() → None¶; Reinitialize timers for independent timer.dat entries. Vital when earlier independent calc finished improperly. table of contents. clean_timers; clean_timers(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean_timers. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean_timers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_timers.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_variables.html:532,Deployability,update,updated,532,"﻿. clean_variables. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean_variables. clean_variables¶. psi4.core.clean_variables() → None¶; Empties all double and Matrix QCVariables that have been set in global memory. table of contents. clean_variables; clean_variables(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; clean_variables. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.close_outfile.html:463,Deployability,update,updated,463,"﻿. close_outfile. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; close_outfile. close_outfile¶. psi4.core.close_outfile() → None¶; Closes the output file. table of contents. close_outfile; close_outfile(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; close_outfile. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.close_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.close_outfile.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html:819,Deployability,update,updated,819,"﻿. CompositeJK. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK¶. class psi4.core.CompositeJK¶; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK) → None¶; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK) → bool¶; Was the last Fock build incremental?. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html:236,Usability,Clear,Clear,236,"﻿. CompositeJK. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK¶. class psi4.core.CompositeJK¶; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK) → None¶; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK) → bool¶; Was the last Fock build incremental?. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html:398,Usability,Clear,Clear,398,"﻿. CompositeJK. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK¶. class psi4.core.CompositeJK¶; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK) → None¶; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK) → bool¶; Was the last Fock build incremental?. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationFactor.html:772,Deployability,update,updated,772,"﻿. CorrelationFactor. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor. CorrelationFactor¶. class psi4.core.CorrelationFactor¶; Bases: pybind11_object; docstring; Methods Summary. set_params(self, coeff, exponent); Set coefficient and exponent. Methods Documentation. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. table of contents. CorrelationFactor; CorrelationFactor; CorrelationFactor.set_params(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationFactor.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html:2120,Deployability,update,updated,2120,"ses: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self, arg0); Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self, arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self, arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degenercy of the irrep. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int¶; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup¶; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int¶; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html:571,Energy Efficiency,reduce,reduced,571,"﻿. CorrelationTable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. CorrelationTable¶. class psi4.core.CorrelationTable¶; Bases: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self, arg0); Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self, arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self, arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degenercy of the irrep. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int¶; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup¶; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int¶; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html:1373,Energy Efficiency,reduce,reduced,1373,"ses: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self, arg0); Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self, arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self, arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degenercy of the irrep. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int¶; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup¶; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int¶; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html:1793,Deployability,update,updated,1793,"﻿. CubeProperties. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties¶. class psi4.core.CubeProperties¶; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self, D, key); Compute and dump a cube file for a density matrix. compute_orbitals(self, C, indices, labels, key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties) → psi4.core.BasisSet¶; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str) → None¶; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str) → None¶; Compute and dump a cube file for a set of orbitals. compute_properties()¶; Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties) → None¶; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html:533,Integrability,wrap,wrapper,533,"﻿. CubeProperties. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties¶. class psi4.core.CubeProperties¶; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self, D, key); Compute and dump a cube file for a density matrix. compute_orbitals(self, C, indices, labels, key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties) → psi4.core.BasisSet¶; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str) → None¶; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str) → None¶; Compute and dump a cube file for a set of orbitals. compute_properties()¶; Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties) → None¶; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html:1183,Integrability,wrap,wrapper,1183,"﻿. CubeProperties. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties¶. class psi4.core.CubeProperties¶; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self, D, key); Compute and dump a cube file for a density matrix. compute_orbitals(self, C, indices, labels, key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties) → psi4.core.BasisSet¶; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str) → None¶; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str) → None¶; Compute and dump a cube file for a set of orbitals. compute_properties()¶; Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties) → None¶; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CUHF.html:1272,Deployability,update,updated,1272,"﻿. CUHF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CUHF. CUHF¶. class psi4.core.CUHF¶; Bases: HF; docstring; Methods Summary. c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, ...); docstring. diis(self, arg0); docstring. mintshelper(self); The MintsHelper object. Methods Documentation. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type:; float. Parameters:. save_fock (bool) – ; max_diis_vectors (int) – . diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. mintshelper(self: psi4.core.CUHF) → psi4.core.MintsHelper¶; The MintsHelper object. table of contents. CUHF; CUHF; CUHF.c1_deep_copy(); CUHF.compute_orbital_gradient(); CUHF.diis(); CUHF.mintshelper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; CUHF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CUHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CUHF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DASUM.html:445,Deployability,update,updated,445,"﻿. DASUM. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DASUM. DASUM¶. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → float¶; docstring. table of contents. DASUM; DASUM(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DASUM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DASUM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DASUM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DAXPY.html:487,Deployability,update,updated,487,"﻿. DAXPY. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DAXPY. DAXPY¶. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int) → None¶; docstring. table of contents. DAXPY; DAXPY(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DAXPY. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DAXPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DAXPY.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DCOPY.html:474,Deployability,update,updated,474,"﻿. DCOPY. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DCOPY. DCOPY¶. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → None¶; docstring. table of contents. DCOPY; DCOPY(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DCOPY. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DCOPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DCOPY.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dct.html:470,Deployability,update,updated,470,"﻿. dct. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dct. dct¶. psi4.core.dct(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the density cumulant (functional) theory code. table of contents. dct; dct(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dct. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dct.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DDOT.html:468,Deployability,update,updated,468,"﻿. DDOT. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DDOT. DDOT¶. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → float¶; docstring. table of contents. DDOT; DDOT(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DDOT. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DDOT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DDOT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_array_variable.html:559,Deployability,update,updated,559,"﻿. del_array_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; del_array_variable. del_array_variable¶. psi4.core.del_array_variable(key: str) → None¶; Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_array_variable; del_array_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; del_array_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.del_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_scalar_variable.html:566,Deployability,update,updated,566,"﻿. del_scalar_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable. del_scalar_variable¶. psi4.core.del_scalar_variable(key: str) → None¶; Removes the double QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_scalar_variable; del_scalar_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.del_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_scalar_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_variable.html:607,Deployability,update,updated,607,"﻿. del_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; del_variable. del_variable¶. psi4.core.del_variable(key)¶; Removes scalar or array QCVariable key; from global memory if present. Parameters:; key (str) – Case-insensitive key to global double or Matrix; storage maps. Return type:; None. table of contents. del_variable; del_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; del_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.del_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Deriv.html:1698,Deployability,update,updated,1698,"﻿. Deriv. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Deriv. Deriv¶. class psi4.core.Deriv¶; Bases: pybind11_object; Computes gradients of wavefunctions; Methods Summary. compute(self, deriv_calc_type); Compute the gradient. compute_df(self, arg0, arg1); Compute the density-fitted gradient. set_deriv_density_backtransformed(self[, val]); Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self[, val]); Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self[, val]); Is the TPDM already presorted? Default is False. Methods Documentation. compute(self: psi4.core.Deriv, deriv_calc_type: psi4.core.DerivCalcType = <DerivCalcType.Default: 0>) → psi4.core.Matrix¶; Compute the gradient. compute_df(self: psi4.core.Deriv, arg0: str, arg1: str) → psi4.core.Matrix¶; Compute the density-fitted gradient. set_deriv_density_backtransformed(self: psi4.core.Deriv, val: bool = False) → None¶; Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self: psi4.core.Deriv, val: bool = False) → None¶; Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self: psi4.core.Deriv, val: bool = False) → None¶; Is the TPDM already presorted? Default is False. table of contents. Deriv; Deriv; Deriv.compute(); Deriv.compute_df(); Deriv.set_deriv_density_backtransformed(); Deriv.set_ignore_reference(); Deriv.set_tpdm_presorted(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Deriv. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Deriv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Deriv.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html:841,Deployability,update,updated,841,"﻿. DerivCalcType. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType¶. class psi4.core.DerivCalcType¶; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>¶. Default = <DerivCalcType.Default: 0>¶. name¶. value¶. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html:242,Testability,log,logic,242,"﻿. DerivCalcType. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType¶. class psi4.core.DerivCalcType¶; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>¶. Default = <DerivCalcType.Default: 0>¶. name¶. value¶. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html:232,Deployability,configurat,configuration,232,"﻿. detci. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; detci. detci¶. psi4.core.detci(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; detci. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html:491,Deployability,update,updated,491,"﻿. detci. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; detci. detci¶. psi4.core.detci(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; detci. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html:232,Modifiability,config,configuration,232,"﻿. detci. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; detci. detci¶. psi4.core.detci(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; detci. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html:866,Deployability,update,updated,866,"﻿. DFEP2Wavefunction. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction¶. class psi4.core.DFEP2Wavefunction¶; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html:357,Energy Efficiency,energy,energy,357,"﻿. DFEP2Wavefunction. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction¶. class psi4.core.DFEP2Wavefunction¶; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html:545,Energy Efficiency,energy,energy,545,"﻿. DFEP2Wavefunction. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction¶. class psi4.core.DFEP2Wavefunction¶; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFHelper.html:3477,Deployability,update,updated,3477,"verloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], arg3: List[int]) -> psi4.core.Matrix. get_tensor_shape(self: psi4.core.DFHelper, arg0: str) → Tuple[int, int, int]¶. get_tensor_size(self: psi4.core.DFHelper, arg0: str) → int¶. hold_met(self: psi4.core.DFHelper, arg0: bool) → None¶. initialize(self: psi4.core.DFHelper) → None¶. print_header(self: psi4.core.DFHelper) → None¶. set_AO_core(self: psi4.core.DFHelper, arg0: bool) → None¶. set_MO_core(self: psi4.core.DFHelper, arg0: bool) → None¶. set_memory(self: psi4.core.DFHelper, arg0: int) → None¶. set_method(self: psi4.core.DFHelper, arg0: str) → None¶. set_nthreads(self: psi4.core.DFHelper, arg0: int) → None¶. set_schwarz_cutoff(self: psi4.core.DFHelper, arg0: float) → None¶. set_subalgo(self: psi4.core.DFHelper, arg0: str) → None¶. transform(self: psi4.core.DFHelper) → None¶. transpose(self: psi4.core.DFHelper, arg0: str, arg1: Tuple[int, int, int]) → None¶. table of contents. DFHelper; DFHelper; DFHelper.add_space(); DFHelper.add_transformation(); DFHelper.clear_all(); DFHelper.clear_spaces(); DFHelper.get_AO_core(); DFHelper.get_AO_size(); DFHelper.get_MO_core(); DFHelper.get_memory(); DFHelper.get_method(); DFHelper.get_schwarz_cutoff(); DFHelper.get_space_size(); DFHelper.get_tensor(); DFHelper.get_tensor_shape(); DFHelper.get_tensor_size(); DFHelper.hold_met(); DFHelper.initialize(); DFHelper.print_header(); DFHelper.set_AO_core(); DFHelper.set_MO_core(); DFHelper.set_memory(); DFHelper.set_method(); DFHelper.set_nthreads(); DFHelper.set_schwarz_cutoff(); DFHelper.set_subalgo(); DFHelper.transform(); DFHelper.transpose(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFHelper. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfmp2.html:454,Deployability,update,updated,454,"﻿. dfmp2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dfmp2. dfmp2¶. psi4.core.dfmp2(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the DF-MP2 code. table of contents. dfmp2; dfmp2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dfmp2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfmp2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html:484,Deployability,update,updated,484,"﻿. dfocc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc¶. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dfocc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html:237,Performance,optimiz,optimized,237,"﻿. dfocc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc¶. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dfocc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFSOMCSCF.html:433,Deployability,update,updated,433,"﻿. DFSOMCSCF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF. DFSOMCSCF¶. class psi4.core.DFSOMCSCF¶; Bases: SOMCSCF; docstring. table of contents. DFSOMCSCF; DFSOMCSCF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFSOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTensor.html:1180,Deployability,update,updated,1180,"﻿. DFTensor. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFTensor. DFTensor¶. class psi4.core.DFTensor¶; Bases: pybind11_object; docstring; Methods Summary. Idfmo(self); doctsring. Imo(self); doctsring. Qmo(self); doctsring. Qoo(self); doctsring. Qov(self); doctsring. Qso(self); doctsring. Qvv(self); doctsring. Methods Documentation. Idfmo(self: psi4.core.DFTensor) → psi4.core.Matrix¶; doctsring. Imo(self: psi4.core.DFTensor) → psi4.core.Matrix¶; doctsring. Qmo(self: psi4.core.DFTensor) → psi4.core.Matrix¶; doctsring. Qoo(self: psi4.core.DFTensor) → psi4.core.Matrix¶; doctsring. Qov(self: psi4.core.DFTensor) → psi4.core.Matrix¶; doctsring. Qso(self: psi4.core.DFTensor) → psi4.core.Matrix¶; doctsring. Qvv(self: psi4.core.DFTensor) → psi4.core.Matrix¶; doctsring. table of contents. DFTensor; DFTensor; DFTensor.Idfmo(); DFTensor.Imo(); DFTensor.Qmo(); DFTensor.Qoo(); DFTensor.Qov(); DFTensor.Qso(); DFTensor.Qvv(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFTensor. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFTensor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTensor.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTGrid.html:784,Deployability,update,updated,784,"﻿. DFTGrid. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFTGrid. DFTGrid¶. class psi4.core.DFTGrid¶; Bases: MolecularGrid; docstring; Methods Summary. build(*args, **kwargs); Overloaded function. Methods Documentation. static build(*args, **kwargs)¶; Overloaded function. build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet) -> psi4.core.DFTGrid; build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet, arg2: Dict[str, int], arg3: Dict[str, str]) -> psi4.core.DFTGrid. table of contents. DFTGrid; DFTGrid; DFTGrid.build(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DFTGrid. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFTGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTGrid.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGBMV.html:578,Deployability,update,updated,578,"﻿. DGBMV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGBMV. DGBMV¶. psi4.core.DGBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int, arg11: float, arg12: psi::Vector, arg13: int) → None¶; docstring. table of contents. DGBMV; DGBMV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGBMV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGBMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEEV.html:597,Deployability,update,updated,597,"﻿. DGEEV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGEEV. DGEEV¶. psi4.core.DGEEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int, arg12: psi::Vector, arg13: int) → int¶; docstring. table of contents. DGEEV; DGEEV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGEEV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGEEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEEV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMM.html:578,Deployability,update,updated,578,"﻿. DGEMM. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGEMM. DGEMM¶. psi4.core.DGEMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Matrix, arg10: int, arg11: float, arg12: psi::Matrix, arg13: int) → None¶; docstring. table of contents. DGEMM; DGEMM(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGEMM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGEMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMV.html:554,Deployability,update,updated,554,"﻿. DGEMV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGEMV. DGEMV¶. psi4.core.DGEMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int) → None¶; docstring. table of contents. DGEMV; DGEMV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGEMV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGEMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGER.html:521,Deployability,update,updated,521,"﻿. DGER. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGER. DGER¶. psi4.core.DGER(arg0: int, arg1: int, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int) → None¶; docstring. table of contents. DGER; DGER(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGER. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGER.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGER.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRF.html:483,Deployability,update,updated,483,"﻿. DGETRF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGETRF. DGETRF¶. psi4.core.DGETRF(arg0: int, arg1: int, arg2: int, arg3: psi::Matrix, arg4: int, arg5: psi::IntVector) → int¶; docstring. table of contents. DGETRF; DGETRF(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGETRF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGETRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRI.html:502,Deployability,update,updated,502,"﻿. DGETRI. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGETRI. DGETRI¶. psi4.core.DGETRI(arg0: int, arg1: int, arg2: psi::Matrix, arg3: int, arg4: psi::IntVector, arg5: psi::Vector, arg6: int) → int¶; docstring. table of contents. DGETRI; DGETRI(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGETRI. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGETRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRI.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRS.html:524,Deployability,update,updated,524,"﻿. DGETRS. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGETRS. DGETRS¶. psi4.core.DGETRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int) → int¶; docstring. table of contents. DGETRS; DGETRS(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DGETRS. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGETRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRS.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiagonalizeOrder.html:862,Deployability,update,updated,862,"﻿. DiagonalizeOrder. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder. DiagonalizeOrder¶. class psi4.core.DiagonalizeOrder¶; Bases: pybind11_object; Defines ordering of eigenvalues after diagonalization; Members:. Ascending; Descending. Attributes Summary. Ascending. Descending. name. value. Attributes Documentation. Ascending = <DiagonalizeOrder.Ascending: 1>¶. Descending = <DiagonalizeOrder.Descending: 3>¶. name¶. value¶. table of contents. DiagonalizeOrder; DiagonalizeOrder; DiagonalizeOrder.Ascending; DiagonalizeOrder.Descending; DiagonalizeOrder.name; DiagonalizeOrder.value. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DiagonalizeOrder.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiagonalizeOrder.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dimension.html:2705,Deployability,update,updated,2705,"ibutes Documentation. name¶; The name of the dimension. Used in printing. Methods Documentation. fill(self: psi4.core.Dimension, val: int) → None¶; Fill all elements with given value. classmethod from_list(dims, name='New Dimension')¶; Builds a Dimension object from a Python list or tuple. If a; Dimension object is passed, a copy will be returned. Parameters:. dims (Union[Tuple[int], List[int], ndarray, Dimension]) – Iterable of integers defining irrep dimensions.; name – Name for new instance. Return type:; Dimension. init(self: psi4.core.Dimension, arg0: int, arg1: str) → None¶; Re-initializes the dimension object. max(*args, **kwargs)¶; Overloaded function. max(self: psi4.core.Dimension) -> int. Gets the maximum value from the dimension object. max(self: psi4.core.Dimension) -> int. Return the maximum element. n(self: psi4.core.Dimension) → int¶; The order of the dimension. print_out(self: psi4.core.Dimension) → None¶; Print out the dimension object to the output file. sum(*args, **kwargs)¶; Overloaded function. sum(self: psi4.core.Dimension) -> int. Gets the sum of the values in the dimension object. sum(self: psi4.core.Dimension) -> int. Return the sum of constituent dimensions. to_tuple()¶; Serializes Dimension to a tuple. Return type:; Tuple[int]. Parameters:; self (Dimension) – . zero(*args, **kwargs)¶; Overloaded function. zero(self: psi4.core.Dimension) -> None. Zeros all values in the dimension object. zero(self: psi4.core.Dimension) -> None. Zero all elements. table of contents. Dimension; Dimension; Dimension.name; Dimension.fill(); Dimension.from_list(); Dimension.init(); Dimension.max(); Dimension.n(); Dimension.print_out(); Dimension.sum(); Dimension.to_tuple(); Dimension.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Dimension. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Dimension.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dimension.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DipoleInt.html:454,Deployability,update,updated,454,"﻿. DipoleInt. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DipoleInt. DipoleInt¶. class psi4.core.DipoleInt¶; Bases: OneBodyAOInt; Computes dipole integrals. table of contents. DipoleInt; DipoleInt. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DipoleInt. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DipoleInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DirectJK.html:639,Deployability,update,updated,639,"﻿. DirectJK. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DirectJK. DirectJK¶. class psi4.core.DirectJK¶; Bases: JK; docstring; Methods Summary. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. do_incfock_iter(self: psi4.core.DirectJK) → bool¶; Was the last Fock build incremental?. table of contents. DirectJK; DirectJK; DirectJK.do_incfock_iter(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DirectJK. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DirectJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DirectJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiskSOMCSCF.html:447,Deployability,update,updated,447,"﻿. DiskSOMCSCF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF. DiskSOMCSCF¶. class psi4.core.DiskSOMCSCF¶; Bases: SOMCSCF; docstring. table of contents. DiskSOMCSCF; DiskSOMCSCF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DiskSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiskSOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dispersion.html:3509,Deployability,update,updated,3509," compute_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → psi4.core.Matrix¶; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → psi4.core.Matrix¶; docstring. d(self: psi4.core.Dispersion) → float¶; docstring. description(self: psi4.core.Dispersion) → str¶; docstring. name(self: psi4.core.Dispersion) → str¶; docstring. print_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → str¶; docstring. print_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → str¶; docstring. print_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → str¶; docstring. print_out(self: psi4.core.Dispersion) → None¶; docstring. s6(self: psi4.core.Dispersion) → float¶; docstring. s8(self: psi4.core.Dispersion) → float¶; docstring. set_bibtex(self: psi4.core.Dispersion, arg0: str) → None¶; Set the BibTeX key for the literature reference. set_citation(self: psi4.core.Dispersion, arg0: str) → None¶; docstring. set_description(self: psi4.core.Dispersion, arg0: str) → None¶; docstring. set_name(self: psi4.core.Dispersion, arg0: str) → None¶; docstring. sr6(self: psi4.core.Dispersion) → float¶; docstring. table of contents. Dispersion; Dispersion; Dispersion.a1(); Dispersion.a2(); Dispersion.bibtex(); Dispersion.build(); Dispersion.citation(); Dispersion.compute_energy(); Dispersion.compute_gradient(); Dispersion.compute_hessian(); Dispersion.d(); Dispersion.description(); Dispersion.name(); Dispersion.print_energy(); Dispersion.print_gradient(); Dispersion.print_hessian(); Dispersion.print_out(); Dispersion.s6(); Dispersion.s8(); Dispersion.set_bibtex(); Dispersion.set_citation(); Dispersion.set_description(); Dispersion.set_name(); Dispersion.sr6(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Dispersion. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dlpno.html:451,Deployability,update,updated,451,"﻿. dlpno. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dlpno. dlpno¶. psi4.core.dlpno(arg0: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the DLPNO codes. table of contents. dlpno; dlpno(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dlpno. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dlpno.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dlpno.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html:446,Deployability,update,updated,446,"﻿. dmrg. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg¶. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction) → float¶; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dmrg. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html:201,Integrability,interface,interface,201,"﻿. dmrg. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg¶. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction) → float¶; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dmrg. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DNRM2.html:445,Deployability,update,updated,445,"﻿. DNRM2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DNRM2. DNRM2¶. psi4.core.DNRM2(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → float¶; docstring. table of contents. DNRM2; DNRM2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DNRM2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DNRM2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DNRM2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.doublet.html:588,Deployability,update,updated,588,"﻿. doublet. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; doublet. doublet¶. psi4.core.doublet(A: psi4.core.Matrix, B: psi4.core.Matrix, transA: bool = False, transB: bool = False) → psi4.core.Matrix¶; Returns the multiplication of two matrices A and B, with options to transpose each beforehand. table of contents. doublet; doublet(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; doublet. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.doublet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.doublet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdbuf4.html:1121,Deployability,update,updated,1121,"﻿. dpdbuf4. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4. dpdbuf4¶. class psi4.core.dpdbuf4¶; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self, arg0, arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all with entries. Methods Documentation. axpy_matrix(self: psi4.core.dpdbuf4, arg0: psi4.core.Matrix, arg1: float) → int¶; Add ‘a’ times a Matrix to this. coldim(self: psi4.core.dpdbuf4) → psi4.core.Dimension¶; Return the dimensions of the column index. rowdim(self: psi4.core.dpdbuf4) → psi4.core.Dimension¶; Return the dimensions of the row index. zero(self: psi4.core.dpdbuf4) → int¶; Fill all with entries. table of contents. dpdbuf4; dpdbuf4; dpdbuf4.axpy_matrix(); dpdbuf4.coldim(); dpdbuf4.rowdim(); dpdbuf4.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dpdbuf4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdbuf4.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdfile2.html:1150,Deployability,update,updated,1150,"﻿. dpdfile2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dpdfile2. dpdfile2¶. class psi4.core.dpdfile2¶; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self, arg0, arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all entries with zeroes. Methods Documentation. axpy_matrix(self: psi4.core.dpdfile2, arg0: psi4.core.Matrix, arg1: float) → int¶; Add ‘a’ times a Matrix to this. coldim(self: psi4.core.dpdfile2) → psi4.core.Dimension¶; Return the dimensions of the column index. rowdim(self: psi4.core.dpdfile2) → psi4.core.Dimension¶; Return the dimensions of the row index. zero(self: psi4.core.dpdfile2) → int¶; Fill all entries with zeroes. table of contents. dpdfile2; dpdfile2; dpdfile2.axpy_matrix(); dpdfile2.coldim(); dpdfile2.rowdim(); dpdfile2.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; dpdfile2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dpdfile2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdfile2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRF.html:461,Deployability,update,updated,461,"﻿. DPOTRF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DPOTRF. DPOTRF¶. psi4.core.DPOTRF(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int) → int¶; docstring. table of contents. DPOTRF; DPOTRF(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DPOTRF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DPOTRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRI.html:461,Deployability,update,updated,461,"﻿. DPOTRI. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DPOTRI. DPOTRI¶. psi4.core.DPOTRI(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int) → int¶; docstring. table of contents. DPOTRI; DPOTRI(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DPOTRI. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DPOTRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRI.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRS.html:502,Deployability,update,updated,502,"﻿. DPOTRS. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DPOTRS. DPOTRS¶. psi4.core.DPOTRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Matrix, arg7: int) → int¶; docstring. table of contents. DPOTRS; DPOTRS(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DPOTRS. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DPOTRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRS.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DROT.html:493,Deployability,update,updated,493,"﻿. DROT. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DROT. DROT¶. psi4.core.DROT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int, arg6: float, arg7: float) → None¶; docstring. table of contents. DROT; DROT(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DROT. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DROT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DROT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSBMV.html:554,Deployability,update,updated,554,"﻿. DSBMV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSBMV. DSBMV¶. psi4.core.DSBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int) → None¶; docstring. table of contents. DSBMV; DSBMV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSBMV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSBMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSCAL.html:457,Deployability,update,updated,457,"﻿. DSCAL. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSCAL. DSCAL¶. psi4.core.DSCAL(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int) → None¶; docstring. table of contents. DSCAL; DSCAL(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSCAL. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSCAL.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSCAL.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSWAP.html:474,Deployability,update,updated,474,"﻿. DSWAP. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSWAP. DSWAP¶. psi4.core.DSWAP(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → None¶; docstring. table of contents. DSWAP; DSWAP(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSWAP. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSWAP.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSWAP.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYEV.html:514,Deployability,update,updated,514,"﻿. DSYEV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYEV. DSYEV¶. psi4.core.DSYEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: int) → int¶; docstring. table of contents. DSYEV; DSYEV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYEV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYEV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMM.html:566,Deployability,update,updated,566,"﻿. DSYMM. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYMM. DSYMM¶. psi4.core.DSYMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int) → None¶; docstring. table of contents. DSYMM; DSYMM(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYMM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMV.html:542,Deployability,update,updated,542,"﻿. DSYMV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYMV. DSYMV¶. psi4.core.DSYMV(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: int, arg8: float, arg9: psi::Vector, arg10: int) → None¶; docstring. table of contents. DSYMV; DSYMV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYMV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR.html:491,Deployability,update,updated,491,"﻿. DSYR. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYR. DSYR¶. psi4.core.DSYR(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Matrix, arg7: int) → None¶; docstring. table of contents. DSYR; DSYR(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYR. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYR.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2.html:528,Deployability,update,updated,528,"﻿. DSYR2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYR2. DSYR2¶. psi4.core.DSYR2(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int) → None¶; docstring. table of contents. DSYR2; DSYR2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYR2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYR2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2K.html:573,Deployability,update,updated,573,"﻿. DSYR2K. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYR2K. DSYR2K¶. psi4.core.DSYR2K(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int) → None¶; docstring. table of contents. DSYR2K; DSYR2K(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYR2K. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYR2K.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2K.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYRK.html:534,Deployability,update,updated,534,"﻿. DSYRK. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYRK. DSYRK¶. psi4.core.DSYRK(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: float, arg9: psi::Matrix, arg10: int) → None¶; docstring. table of contents. DSYRK; DSYRK(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYRK. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYRK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYRK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYSV.html:548,Deployability,update,updated,548,"﻿. DSYSV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYSV. DSYSV¶. psi4.core.DSYSV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int) → int¶; docstring. table of contents. DSYSV; DSYSV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DSYSV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYSV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBMV.html:518,Deployability,update,updated,518,"﻿. DTBMV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTBMV. DTBMV¶. psi4.core.DTBMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int) → None¶; docstring. table of contents. DTBMV; DTBMV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTBMV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBSV.html:518,Deployability,update,updated,518,"﻿. DTBSV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTBSV. DTBSV¶. psi4.core.DTBSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int) → None¶; docstring. table of contents. DTBSV; DTBSV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTBSV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTBSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBSV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMM.html:544,Deployability,update,updated,544,"﻿. DTRMM. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRMM. DTRMM¶. psi4.core.DTRMM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int) → None¶; docstring. table of contents. DTRMM; DTRMM(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRMM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMV.html:507,Deployability,update,updated,507,"﻿. DTRMV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRMV. DTRMV¶. psi4.core.DTRMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int) → None¶; docstring. table of contents. DTRMV; DTRMV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRMV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSM.html:544,Deployability,update,updated,544,"﻿. DTRSM. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRSM. DTRSM¶. psi4.core.DTRSM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int) → None¶; docstring. table of contents. DTRSM; DTRSM(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRSM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRSM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSV.html:507,Deployability,update,updated,507,"﻿. DTRSV. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRSV. DTRSV¶. psi4.core.DTRSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int) → None¶; docstring. table of contents. DTRSV; DTRSV(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; DTRSV. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectricFieldInt.html:511,Deployability,update,updated,511,"﻿. ElectricFieldInt. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt. ElectricFieldInt¶. class psi4.core.ElectricFieldInt¶; Bases: OneBodyAOInt; Computes electric field integrals. table of contents. ElectricFieldInt; ElectricFieldInt. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ElectricFieldInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectricFieldInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectrostaticInt.html:510,Deployability,update,updated,510,"﻿. ElectrostaticInt. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt. ElectrostaticInt¶. class psi4.core.ElectrostaticInt¶; Bases: OneBodyAOInt; Computes electrostatic integrals. table of contents. ElectrostaticInt; ElectrostaticInt. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ElectrostaticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectrostaticInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERI.html:435,Deployability,update,updated,435,"﻿. ERI. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ERI. ERI¶. class psi4.core.ERI¶; Bases: TwoBodyAOInt; Computes normal two electron repulsion integrals. table of contents. ERI; ERI. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ERI. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ERI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERI.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERISieve.html:1619,Deployability,update,updated,1619,"﻿. ERISieve. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ERISieve. ERISieve¶. class psi4.core.ERISieve¶; Bases: pybind11_object; docstring; Methods Summary. build(orbital_basis[, cutoff, do_csam]); Constructs a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for ERI screening and an optional input to enable CSAM screening (over Schwarz screening). shell_significant(self, arg0, arg1, arg2, arg3). Methods Documentation. static build(orbital_basis, cutoff=0.0, do_csam=False)¶; Constructs a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for; ERI screening and an optional input to enable CSAM screening (over Schwarz screening). Parameters:. orbital_basis (BasisSet) – Basis set to use in the ERISieve object.; cutoff (float) – Integral cutoff threshold to use for Schwarz/CSAM screening. Defaults to 0.0, disabling screening entirely.; do_csam (bool) – Use CSAM screening? If True, CSAM screening is used; else, Schwarz screening is used. By default,; Schwarz screening is utilized. Returns:; Initialized ERISieve object. Return type:; ERISieve. Example; >>> sieve = psi4.core.ERISieve.build(bas, cutoff, csam). shell_significant(self: psi4.core.ERISieve, arg0: int, arg1: int, arg2: int, arg3: int) → bool¶. table of contents. ERISieve; ERISieve; ERISieve.build(); ERISieve.shell_significant(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ERISieve. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ERISieve.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERISieve.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html:1163,Deployability,update,updated,1163,"﻿. ESPPropCalc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc¶. class psi4.core.ESPPropCalc¶; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self, arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self, arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix) → psi4.core.Vector¶; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html:218,Integrability,rout,routines,218,"﻿. ESPPropCalc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc¶. class psi4.core.ESPPropCalc¶; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self, arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self, arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix) → psi4.core.Vector¶; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html:208,Security,access,access,208,"﻿. ESPPropCalc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc¶. class psi4.core.ESPPropCalc¶; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self, arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self, arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix) → psi4.core.Vector¶; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:3110,Deployability,update,updated,3110,"fs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:435,Energy Efficiency,charge,charge,435,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:502,Energy Efficiency,charge,charge,502,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:816,Energy Efficiency,energy,energy,816,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:982,Energy Efficiency,charge,charge,982,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1379,Energy Efficiency,charge,charge,1379," of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.Exte",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1524,Energy Efficiency,charge,charge,1524,"of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. tabl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2000,Energy Efficiency,energy,energy,2000,"f charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2307,Energy Efficiency,charge,charge,2307,"fs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:548,Usability,clear,clear,548,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1570,Usability,clear,clear,1570,"o zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2667,Usability,clear,clear,2667,"fs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FCHKWriter.html:1104,Deployability,update,updated,1104,"﻿. FCHKWriter. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter. FCHKWriter¶. class psi4.core.FCHKWriter¶; Bases: pybind11_object; Extracts information from a wavefunction object, and writes it to an FCHK file; Methods Summary. SCF_Dtot(self). set_postscf_density_label(self, label); Set base label for post-SCF density, e.g. ' CC Density'. write(self, filename); Write wavefunction information to file. Methods Documentation. SCF_Dtot(self: psi4.core.FCHKWriter) → psi4.core.Matrix¶. set_postscf_density_label(self: psi4.core.FCHKWriter, label: str) → None¶; Set base label for post-SCF density, e.g. ‘ CC Density’. write(self: psi4.core.FCHKWriter, filename: str) → None¶; Write wavefunction information to file. table of contents. FCHKWriter; FCHKWriter; FCHKWriter.SCF_Dtot(); FCHKWriter.set_postscf_density_label(); FCHKWriter.write(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FCHKWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FCHKWriter.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.fcidump_tei_helper.html:619,Deployability,update,updated,619,"﻿. fcidump_tei_helper. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper. fcidump_tei_helper¶. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str = 'INTDUMP') → None¶; Write integrals to file in FCIDUMP format. table of contents. fcidump_tei_helper; fcidump_tei_helper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.fcidump_tei_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.fcidump_tei_helper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FDDS_Dispersion.html:2856,Deployability,update,updated,2856,"y AO to auxiliary AO space. Methods Documentation. R_A(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains (R^t)^-1 for monomer A. R_B(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains (R^t)^-1 for monomer B. aux_overlap(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS aux_overlap. form_aux_matrices(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → Dict[str, psi4.core.Matrix]¶; Forms the uncoupled amplitudes and other matrices for either monomer. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → psi4.core.Matrix¶; Forms the uncoupled amplitudes for either monomer. get_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: Tuple[int, int, int]) → psi4.core.Matrix¶; Debug only: fetches 3-index intermediate from disk and return as matrix. metric(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric_inv. print_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: str, arg2: Tuple[int, int, int]) → None¶; Debug only: prints formatted 3-index intermediate to file. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; Projects a density from the primary AO to auxiliary AO space. table of contents. FDDS_Dispersion; FDDS_Dispersion; FDDS_Dispersion.R_A(); FDDS_Dispersion.R_B(); FDDS_Dispersion.aux_overlap(); FDDS_Dispersion.form_aux_matrices(); FDDS_Dispersion.form_unc_amplitude(); FDDS_Dispersion.get_tensor_pqQ(); FDDS_Dispersion.metric(); FDDS_Dispersion.metric_inv(); FDDS_Dispersion.print_tensor_pqQ(); FDDS_Dispersion.project_densities(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FDDS_Dispersion. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FDDS_Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FDDS_Dispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.finalize.html:459,Deployability,update,updated,459,"﻿. finalize. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; finalize. finalize¶. psi4.core.finalize() → None¶; Called upon psi4 module exit to closes timers and I/O. table of contents. finalize; finalize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; finalize. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.finalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.finalize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:5432,Deployability,update,updated,5432,"ion energies. overlap(self: psi4.core.FISAPT) → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. plot()¶; Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. unify_part2(self: psi4.core.FISAPT) → None¶; Finish producing unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → Dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.compute_energy(); FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.fdrop(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.plot(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FISAPT. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:286,Energy Efficiency,energy,energy,286,"﻿. FISAPT. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT¶. class psi4.core.FISAPT¶; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. compute_energy([external_potentials]); Computes the FSAPT energy. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT ene",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:456,Energy Efficiency,energy,energy,456,"﻿. FISAPT. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT¶. class psi4.core.FISAPT¶; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. compute_energy([external_potentials]); Computes the FSAPT energy. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT ene",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:1695,Energy Efficiency,energy,energy,1695,"put files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT) → None¶; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. fdrop(external_potentials=None)¶; Drop output files from ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:1998,Energy Efficiency,energy,energy,1998,"ize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT) → None¶; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. fdrop(external_potentials=None)¶; Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:2334,Energy Efficiency,energy,energy,2334,". plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT) → None¶; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT) → None¶; SAPT0 electrostatics. exch(self: psi4.core.FISAPT) → None¶; SAPT0 exchange. fdisp(self: psi4.core.FISAPT) → None¶; F-SAPT0 dispersion. fdrop(external_potentials=None)¶; Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the i",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:4309,Energy Efficiency,energy,energy,4309,"trix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molecule¶; Returns the FISAPT’s molecule. nuclear(self: psi4.core.FISAPT) → None¶; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT) → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. plot()¶; Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. unify_part2(self: psi4.core.FISAPT) → None¶; Finish producing unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → Dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.compute_energy(); FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.fdrop(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.plot(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). «; hide menu. menu; sidebar; »; . Navigat",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:1319,Integrability,wrap,wrapper,1319,"K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self, arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self, arg0, arg1, arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None)¶; Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT) → None¶; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) → None¶; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and E",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:3696,Integrability,wrap,wrapper,3696,"elst(self: psi4.core.FISAPT) → None¶; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT) → None¶; F-SAPT0 exchange. find(self: psi4.core.FISAPT) → None¶; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT) → None¶; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT) → None¶; Freeze the core orbitals. ind(self: psi4.core.FISAPT) → None¶; SAPT0 induction. kinetic(self: psi4.core.FISAPT) → None¶; Build the kinetic integrals T. localize(self: psi4.core.FISAPT) → None¶; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT) → Dict[str, psi4.core.Matrix]¶; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT) → psi4.core.Molecule¶; Returns the FISAPT’s molecule. nuclear(self: psi4.core.FISAPT) → None¶; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT) → None¶; Build the overlap integrals S. partition(self: psi4.core.FISAPT) → None¶; Partition the nuclei and electrons. plot()¶; Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT) → None¶; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT) → None¶; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str) → None¶; Plot some analysis files. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT) → None¶; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT) → None¶; Produce unified matrices for A’, B’, and C’. unify_part2(self: psi4.core.FISAPT) → None¶; Finish producing unified matrices for A’, B’, and C’. vectors(self: psi4.core.FISAPT) → Dict[str, psi4.core.Vector]¶; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.compute_energy(); FISAPT.cou",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittedSlaterCorrelationFactor.html:747,Deployability,update,updated,747,"﻿. FittedSlaterCorrelationFactor. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor. FittedSlaterCorrelationFactor¶. class psi4.core.FittedSlaterCorrelationFactor¶; Bases: CorrelationFactor; docstring; Methods Summary. exponent(self). Methods Documentation. exponent(self: psi4.core.FittedSlaterCorrelationFactor) → float¶. table of contents. FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor.exponent(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FittedSlaterCorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittedSlaterCorrelationFactor.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittingMetric.html:2047,Deployability,update,updated,2047,"ingMetric. FittingMetric¶. class psi4.core.FittingMetric¶; Bases: pybind11_object; docstring; Methods Summary. form_QR_inverse(self, arg0); docstring. form_cholesky_inverse(self); docstring. form_eig_inverse(self, arg0); docstring. form_fitting_metric(self); docstring. form_full_inverse(self); docstring. get_algorithm(self); docstring. get_metric(self); docstring. get_pivots(self); docstring. get_reverse_pivots(self); docstring. is_inverted(self); docstring. is_poisson(self); docstring. Methods Documentation. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric) → None¶; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_fitting_metric(self: psi4.core.FittingMetric) → None¶; docstring. form_full_inverse(self: psi4.core.FittingMetric) → None¶; docstring. get_algorithm(self: psi4.core.FittingMetric) → str¶; docstring. get_metric(self: psi4.core.FittingMetric) → psi4.core.Matrix¶; docstring. get_pivots(self: psi4.core.FittingMetric) → psi4.core.IntVector¶; docstring. get_reverse_pivots(self: psi4.core.FittingMetric) → psi4.core.IntVector¶; docstring. is_inverted(self: psi4.core.FittingMetric) → bool¶; docstring. is_poisson(self: psi4.core.FittingMetric) → bool¶; docstring. table of contents. FittingMetric; FittingMetric; FittingMetric.form_QR_inverse(); FittingMetric.form_cholesky_inverse(); FittingMetric.form_eig_inverse(); FittingMetric.form_fitting_metric(); FittingMetric.form_full_inverse(); FittingMetric.get_algorithm(); FittingMetric.get_metric(); FittingMetric.get_pivots(); FittingMetric.get_reverse_pivots(); FittingMetric.is_inverted(); FittingMetric.is_poisson(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FittingMetric. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FittingMetric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittingMetric.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.flush_outfile.html:464,Deployability,update,updated,464,"﻿. flush_outfile. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; flush_outfile. flush_outfile¶. psi4.core.flush_outfile() → None¶; Flushes the output file. table of contents. flush_outfile; flush_outfile(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; flush_outfile. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.flush_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.flush_outfile.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html:484,Deployability,update,updated,484,"﻿. fnocc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc¶. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fnocc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html:244,Energy Efficiency,energy,energy,244,"﻿. fnocc. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc¶. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fnocc. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FragmentType.html:806,Deployability,update,updated,806,"﻿. FragmentType. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FragmentType. FragmentType¶. class psi4.core.FragmentType¶; Bases: pybind11_object; Fragment activation status; Members:. Absent; Real; Ghost. Attributes Summary. Absent. Ghost. Real. name. value. Attributes Documentation. Absent = <FragmentType.Absent: 0>¶. Ghost = <FragmentType.Ghost: 2>¶. Real = <FragmentType.Real: 1>¶. name¶. value¶. table of contents. FragmentType; FragmentType; FragmentType.Absent; FragmentType.Ghost; FragmentType.Real; FragmentType.name; FragmentType.value. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; FragmentType. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FragmentType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FragmentType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Functional.html:3805,Deployability,update,updated,3805,"ional) → str¶; docstring. omega(self: psi4.core.Functional) → float¶; docstring. print_detail(self: psi4.core.Functional, arg0: int) → None¶; docstring. print_out(self: psi4.core.Functional) → None¶; docstring. set_alpha(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_citation(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_density_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_description(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_gga(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_meta(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_name(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. table of contents. Functional; Functional; Functional.alpha(); Functional.build_base(); Functional.citation(); Functional.compute_functional(); Functional.density_cutoff(); Functional.description(); Functional.is_gga(); Functional.is_lrc(); Functional.is_meta(); Functional.lsda_cutoff(); Functional.meta_cutoff(); Functional.name(); Functional.omega(); Functional.print_detail(); Functional.print_out(); Functional.set_alpha(); Functional.set_citation(); Functional.set_density_cutoff(); Functional.set_description(); Functional.set_gga(); Functional.set_lsda_cutoff(); Functional.set_meta(); Functional.set_meta_cutoff(); Functional.set_name(); Functional.set_omega(); Functional.set_parameter(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Functional. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Functional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:3043,Deployability,update,updated,3043,"ical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:359,Integrability,contract,contraction,359,"﻿. GaussianShell. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell¶. class psi4.core.GaussianShell¶; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:410,Integrability,contract,contraction,410,"﻿. GaussianShell. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell¶. class psi4.core.GaussianShell¶; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:490,Integrability,contract,contraction,490,"﻿. GaussianShell. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell¶. class psi4.core.GaussianShell¶; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1028,Integrability,contract,contraction,1028,"vigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell¶. class psi4.core.GaussianShell¶; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.Gaus",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1089,Integrability,contract,contraction,1089,"PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell¶. class psi4.core.GaussianShell¶; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the giv",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1338,Integrability,contract,contraction,1338,"character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical ha",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1390,Integrability,contract,contraction,1390,"The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1471,Integrability,contract,contraction,1471,"er symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self, pi); Return coefficient of the pi'th primitive. erd_coef(self, pi); Return ERD normalized coefficient of pi'th primitive. exp(self, prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primiti",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:2170,Integrability,contract,contraction,2170,"ical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:2264,Integrability,contract,contraction,2264,"ical harmonic basis function. original_coef(self, pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. function_index¶; Basis function index where this shell starts. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianType.html:794,Deployability,update,updated,794,"﻿. GaussianType. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianType. GaussianType¶. class psi4.core.GaussianType¶; Bases: pybind11_object; 0 if Cartesian, 1 if Pure; Members:. Cartesian : (n+1)(n+2)/2 functions; Pure : 2n+1 functions. Attributes Summary. Cartesian. Pure. name. value. Attributes Documentation. Cartesian = <GaussianType.Cartesian: 0>¶. Pure = <GaussianType.Pure: 1>¶. name¶. value¶. table of contents. GaussianType; GaussianType; GaussianType.Cartesian; GaussianType.Pure; GaussianType.name; GaussianType.value. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GaussianType. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GeometryUnits.html:772,Deployability,update,updated,772,"﻿. GeometryUnits. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits. GeometryUnits¶. class psi4.core.GeometryUnits¶; Bases: pybind11_object; The units used to define the geometry; Members:. Angstrom; Bohr. Attributes Summary. Angstrom. Bohr. name. value. Attributes Documentation. Angstrom = <GeometryUnits.Angstrom: 0>¶. Bohr = <GeometryUnits.Bohr: 1>¶. name¶. value¶. table of contents. GeometryUnits; GeometryUnits; GeometryUnits.Angstrom; GeometryUnits.Bohr; GeometryUnits.name; GeometryUnits.value. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GeometryUnits.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GeometryUnits.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_active_molecule.html:541,Deployability,update,updated,541,"﻿. get_active_molecule. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule. get_active_molecule¶. psi4.core.get_active_molecule() → psi4.core.Molecule¶; Returns the currently active molecule object. table of contents. get_active_molecule; get_active_molecule(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_active_molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html:534,Deployability,update,updated,534,"﻿. get_array_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable¶. psi4.core.get_array_variable(key)¶. Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_array_variable; get_array_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html:248,Modifiability,variab,variable,248,"﻿. get_array_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable¶. psi4.core.get_array_variable(key)¶. Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_array_variable; get_array_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html:539,Deployability,update,updated,539,"﻿. get_array_variables. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables¶. psi4.core.get_array_variables()¶. Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_array_variables; get_array_variables(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html:249,Modifiability,variab,variables,249,"﻿. get_array_variables. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables¶. psi4.core.get_array_variables()¶. Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_array_variables; get_array_variables(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_datadir.html:479,Deployability,update,updated,479,"﻿. get_datadir. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_datadir. get_datadir¶. psi4.core.get_datadir() → str¶; Returns the path to shared text resources, PSIDATADIR. table of contents. get_datadir; get_datadir(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_datadir. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_datadir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_datadir.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html:394,Availability,error,error,394,"﻿. get_global_option. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option¶. psi4.core.get_global_option(key: str) → object¶; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_global_option. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html:689,Deployability,update,updated,689,"﻿. get_global_option. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option¶. psi4.core.get_global_option(key: str) → object¶; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_global_option. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option_list.html:545,Deployability,update,updated,545,"﻿. get_global_option_list. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list. get_global_option_list¶. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. table of contents. get_global_option_list; get_global_option_list(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_global_option_list.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option_list.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html:390,Availability,error,error,390,"﻿. get_local_option. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option¶. psi4.core.get_local_option(module: str, key: str) → object¶; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_local_option. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html:697,Deployability,update,updated,697,"﻿. get_local_option. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option¶. psi4.core.get_local_option(module: str, key: str) → object¶; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_local_option. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html:204,Availability,avail,available,204,"﻿. get_memory. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory¶. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_memory. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html:475,Deployability,update,updated,475,"﻿. get_memory. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory¶. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_memory. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_num_threads.html:519,Deployability,update,updated,519,"﻿. get_num_threads. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_num_threads. get_num_threads¶. psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. table of contents. get_num_threads; get_num_threads(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_num_threads. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_num_threads.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html:388,Availability,error,error,388,"﻿. get_option. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option¶. psi4.core.get_option(module: str, key: str) → object¶; Return keyword key value used by module. Returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_option. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html:714,Deployability,update,updated,714,"﻿. get_option. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option¶. psi4.core.get_option(module: str, key: str) → object¶; Return keyword key value used by module. Returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_option. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_options.html:451,Deployability,update,updated,451,"﻿. get_options. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_options. get_options¶. psi4.core.get_options() → psi4.core.Options¶; Get options. table of contents. get_options; get_options(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_options. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_output_file.html:518,Deployability,update,updated,518,"﻿. get_output_file. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_output_file. get_output_file¶. psi4.core.get_output_file() → str¶; Returns output file name (stem + suffix, no directory). ‘stdout’. table of contents. get_output_file; get_output_file(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_output_file. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_output_file.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html:492,Deployability,update,updated,492,"﻿. get_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable¶. psi4.core.get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_variable; get_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html:224,Modifiability,variab,variable,224,"﻿. get_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable¶. psi4.core.get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_variable; get_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html:497,Deployability,update,updated,497,"﻿. get_variables. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables¶. psi4.core.get_variables()¶. Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_variables; get_variables(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variables. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html:225,Modifiability,variab,variables,225,"﻿. get_variables. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables¶. psi4.core.get_variables()¶. Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_variables; get_variables(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_variables. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_writer_file_prefix.html:586,Deployability,update,updated,586,"﻿. get_writer_file_prefix. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix. get_writer_file_prefix¶. psi4.core.get_writer_file_prefix(molecule_name: str) → str¶; Returns the prefix to use for writing files for external programs. table of contents. get_writer_file_prefix; get_writer_file_prefix(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_writer_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_writer_file_prefix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.git_version.html:455,Deployability,update,updated,455,"﻿. git_version. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; git_version. git_version¶. psi4.core.git_version() → None¶. Deprecated since version 1.4. table of contents. git_version; git_version(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; git_version. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.git_version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.git_version.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_array_variable.html:558,Deployability,update,updated,558,"﻿. has_array_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_array_variable. has_array_variable¶. psi4.core.has_array_variable(key: str) → bool¶; Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_array_variable; has_array_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_array_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_global_option_changed.html:807,Deployability,update,updated,807,"﻿. has_global_option_changed. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed. has_global_option_changed¶. psi4.core.has_global_option_changed(key: str) → bool¶; Whether keyword key value has been touched at global (all-module) scope. Has it been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. table of contents. has_global_option_changed; has_global_option_changed(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_global_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_local_option_changed.html:815,Deployability,update,updated,815,"﻿. has_local_option_changed. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed. has_local_option_changed¶. psi4.core.has_local_option_changed(module: str, key: str) → bool¶; Whether keyword key value has been touched at module scope. Has it been touched in the scope of the specified module by either user or code.Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. table of contents. has_local_option_changed; has_local_option_changed(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_local_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_option_changed.html:767,Deployability,update,updated,767,"﻿. has_option_changed. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_option_changed. has_option_changed¶. psi4.core.has_option_changed(module: str, key: str) → bool¶; Whether keyword key value has been touched or is default. Has it been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. table of contents. has_option_changed; has_option_changed(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_option_changed. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_scalar_variable.html:565,Deployability,update,updated,565,"﻿. has_scalar_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable. has_scalar_variable¶. psi4.core.has_scalar_variable(key: str) → bool¶; Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_scalar_variable; has_scalar_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_scalar_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_variable.html:607,Deployability,update,updated,607,"﻿. has_variable. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_variable. has_variable¶. psi4.core.has_variable(key)¶; Whether scalar or array QCVariable key; has been set in global memory. Parameters:; key (str) – Case-insensitive key to global double or Matrix; storage maps. Return type:; bool. table of contents. has_variable; has_variable(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; has_variable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:1261,Deployability,Update,Update,1261,"ed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Ham",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:4327,Deployability,update,update,4327,"nergies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). print_stability_analysis(self, arg0); docstring. push_back_external_potential(self, V); Add an external potential to the private external_potentials list. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self, arg0, arg1); docstring. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:6090,Deployability,Update,Update,6090," the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:10893,Deployability,update,update,10893,"ensity_and_energy(self: psi4.core.HF) → None¶; docstring. scf_type(self: psi4.core.HF) → str¶; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF) → None¶; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.comput",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:13080,Deployability,update,updated,13080,"; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess(); HF.guess_Ca(); HF.guess_Cb(); HF.initialize(); HF.initialize_gtfock_jk(); HF.initialize_jk(); HF.iterations(); HF.jk(); HF.occupation_a(); HF.occupation_b(); HF.onel_Hx(); HF.print_energies(); HF.print_header(); HF.print_orbitals(); HF.print_preiterations(); HF.print_stability_analysis(); HF.push_back_external_potential(); HF.reset_occupation(); HF.rotate_orbitals(); HF.save_density_and_energy(); HF.scf_type(); HF.semicanonicalize(); HF.set_energies(); HF.set_external_cpscf_perturbation(); HF.set_jk(); HF.set_sad_basissets(); HF.set_sad_fitting_basissets(); HF.soscf_update(); HF.stability_analysis(); HF.twoel_Hx(); HF.validate_diis(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; HF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:1900,Energy Efficiency,energy,energy,1900,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self, arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:6010,Energy Efficiency,energy,energy,6010,"he number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and call",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:7072,Energy Efficiency,energy,energy,7072,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. form_C(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Forms the residual of SCF theory. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:7140,Energy Efficiency,energy,energy,7140,"elf: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. form_C(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Forms the residual of SCF theory. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF) → None¶; Forms the initial F matri",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:5928,Integrability,wrap,wrapper,5928,"on_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s te",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:260,Performance,perform,performed,260,"﻿. HF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; HF. HF¶. class psi4.core.HF¶; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:470,Performance,perform,performed,470,"﻿. HF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; HF. HF¶. class psi4.core.HF¶; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:1811,Performance,Perform,Performs,1811,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self, arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:4628,Performance,perform,performed,4628,"ng. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self, arg0, arg1); docstring. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:4843,Performance,perform,performed,4843,"); docstring. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. comput",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:6982,Performance,Perform,Performs,6982,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. form_C(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Forms the residual of SCF theory. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:11236,Security,Validat,ValidationError,11236,"], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess(); HF.guess_Ca(); HF.gue",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:1026,Usability,Clear,Clear,1026,"dules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; HF. HF¶. class psi4.core.HF¶; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:1107,Usability,Clear,Clear,1107,"; HF. HF¶. class psi4.core.HF¶; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(se",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:5646,Usability,Clear,Clear,5646,"pt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:5749,Usability,Clear,Clear,5749,"diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_updat",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:5919,Usability,simpl,simply,5919,"on_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s te",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IDAMAX.html:450,Deployability,update,updated,450,"﻿. IDAMAX. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IDAMAX. IDAMAX¶. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. table of contents. IDAMAX; IDAMAX(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IDAMAX. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IDAMAX.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IDAMAX.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.initialize.html:504,Deployability,update,updated,504,"﻿. initialize. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; initialize. initialize¶. psi4.core.initialize() → bool¶; Called upon psi4 module import to initialize timers, singletons, and I/O. Idempotent. table of contents. initialize; initialize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; initialize. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.initialize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.initialize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralFactory.html:9205,Deployability,update,updated,9205,") → psi4.core.OneBodySOInt¶; Returns a OneBodyInt that computes the SO nabla integral. so_overlap(self: psi4.core.IntegralFactory, deriv: int = 0) → psi4.core.OneBodySOInt¶; Returns a OneBodyInt that computes the SO overlap integrals. so_potential(self: psi4.core.IntegralFactory, deriv: int = 0) → psi4.core.OneBodySOInt¶; Returns a OneBodyInt that computes the SO nuclear attraction integral. so_quadrupole(self: psi4.core.IntegralFactory) → psi4.core.OneBodySOInt¶; Returns a OneBodyInt that computes SO the quadrupole integral. so_traceless_quadrupole(self: psi4.core.IntegralFactory) → psi4.core.OneBodySOInt¶; Returns a OneBodyInt that computes the traceless SO quadrupole integral. table of contents. IntegralFactory; IntegralFactory; IntegralFactory.ao_angular_momentum(); IntegralFactory.ao_dipole(); IntegralFactory.ao_kinetic(); IntegralFactory.ao_multipole_potential(); IntegralFactory.ao_multipoles(); IntegralFactory.ao_nabla(); IntegralFactory.ao_overlap(); IntegralFactory.ao_potential(); IntegralFactory.ao_quadrupole(); IntegralFactory.ao_traceless_quadrupole(); IntegralFactory.electric_field(); IntegralFactory.electrostatic(); IntegralFactory.erf_complement_eri(); IntegralFactory.erf_eri(); IntegralFactory.eri(); IntegralFactory.f12(); IntegralFactory.f12_double_commutator(); IntegralFactory.f12_squared(); IntegralFactory.f12g12(); IntegralFactory.overlap_3c(); IntegralFactory.shells_iterator(); IntegralFactory.so_angular_momentum(); IntegralFactory.so_dipole(); IntegralFactory.so_kinetic(); IntegralFactory.so_multipoles(); IntegralFactory.so_nabla(); IntegralFactory.so_overlap(); IntegralFactory.so_potential(); IntegralFactory.so_quadrupole(); IntegralFactory.so_traceless_quadrupole(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IntegralFactory. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IntegralFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralFactory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralTransform.html:7187,Deployability,update,updated,7187,"grals. update_orbitals(self: psi4.core.IntegralTransform) → None¶; docstring. table of contents. IntegralTransform; IntegralTransform; IntegralTransform.DPD_ID(); IntegralTransform.alpha_corr_to_pitzer(); IntegralTransform.backtransform_density(); IntegralTransform.backtransform_tpdm_restricted(); IntegralTransform.backtransform_tpdm_unrestricted(); IntegralTransform.beta_corr_to_pitzer(); IntegralTransform.compute_fock_like_matrices(); IntegralTransform.get_dpd_id(); IntegralTransform.get_frozen_core_energy(); IntegralTransform.get_keep_dpd_so_ints(); IntegralTransform.get_keep_ht_ints(); IntegralTransform.get_keep_iwl_so_ints(); IntegralTransform.get_memory(); IntegralTransform.get_print(); IntegralTransform.get_psio(); IntegralTransform.get_tei_already_presorted(); IntegralTransform.initialize(); IntegralTransform.nirrep(); IntegralTransform.presort_so_tei(); IntegralTransform.print_dpd_lookup(); IntegralTransform.reset_so_int(); IntegralTransform.set_aa_int_name(); IntegralTransform.set_ab_int_name(); IntegralTransform.set_bb_int_name(); IntegralTransform.set_dpd_id(); IntegralTransform.set_dpd_int_file(); IntegralTransform.set_keep_dpd_so_ints(); IntegralTransform.set_keep_ht_ints(); IntegralTransform.set_keep_iwl_so_ints(); IntegralTransform.set_memory(); IntegralTransform.set_orbitals(); IntegralTransform.set_print(); IntegralTransform.set_psio(); IntegralTransform.set_so_tei_file(); IntegralTransform.set_tei_already_presorted(); IntegralTransform.set_tpdm_already_presorted(); IntegralTransform.set_write_dpd_so_tpdm(); IntegralTransform.transform_tei(); IntegralTransform.transform_tei_first_half(); IntegralTransform.transform_tei_second_half(); IntegralTransform.update_orbitals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IntegralTransform. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IntegralTransform.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralTransform.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntVector.html:3309,Deployability,update,updated,3309,": psi4.core.ProtoIntVector) → None¶; Copy another vector into this. dim(self: psi4.core.IntVector, h: int = 0) → int¶; Returns the number of dimensions per irrep h. dimpi(self: psi4.core.IntVector) → psi4.core.Dimension¶; Returns the Dimension object. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.IntVector, m: int) -> int. Returns a single element value located at m. get(self: psi4.core.IntVector, h: int, m: int) -> int. Returns a single element value located at m in irrep h. get_block(self: psi4.core.IntVector, slice: psi4.core.Slice) → psi4.core.IntVector¶; Get a vector block. init(self: psi4.core.IntVector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. static iota(arg0: psi4.core.Dimension) → psi4.core.IntVector¶. nirrep(self: psi4.core.IntVector) → int¶; Returns the number of irreps. print_out(self: psi4.core.IntVector) → None¶; Prints the vector to the output file. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.IntVector, m: int, val: int) -> None. Sets a single element value located at m. set(self: psi4.core.IntVector, h: int, m: int, val: int) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.IntVector, slice: psi4.core.Slice, block: psi4.core.ProtoIntVector) → None¶; Set a vector block. zero(self: psi4.core.IntVector) → None¶; Zeros the vector. table of contents. IntVector; IntVector; IntVector.name; IntVector.add(); IntVector.clone(); IntVector.copy(); IntVector.dim(); IntVector.dimpi(); IntVector.get(); IntVector.get_block(); IntVector.init(); IntVector.iota(); IntVector.nirrep(); IntVector.print_out(); IntVector.set(); IntVector.set_block(); IntVector.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IntVector. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntVector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IO.html:3662,Deployability,update,updated,3662,"str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the file, if necessary. static set_default_namespace(ns: str) → None¶; Set the current namespace (for PREFIX.NAMESPACE.UNIT file numbering). set_pid(self: psi4.core.IO, pid: str) → None¶; Set process id. static shared_object() → psi4.core.IO¶; Return the global shared object. state(self: psi4.core.IO) → int¶; Return 1 if PSIO library is activated. tocclean(self: psi4.core.IO, unit: int, key: str) → None¶; Delete all TOC entries after the given key. If a blank key is given, the entire TOC will be wiped. tocentry_exists(self: psi4.core.IO, arg0: int, arg1: str) → bool¶; Checks the TOC to see if a particular keyword exists there or not. tocprint(self: psi4.core.IO, arg0: int) → None¶; Print the table of contents for the given unit. tocscan(self: psi4.core.IO, arg0: int, arg1: str) → psi4.core.psio_entry¶; Seek string in binary file. This export is only good for catching None, as returned success object not exported. tocwrite(self: psi4.core.IO, arg0: int) → None¶; Write the table of contents for passed file number. table of contents. IO; IO; IO.change_file_namespace(); IO.close(); IO.exists(); IO.get_default_namespace(); IO.getpid(); IO.open(); IO.open_check(); IO.rehash(); IO.set_default_namespace(); IO.set_pid(); IO.shared_object(); IO.state(); IO.tocclean(); IO.tocentry_exists(); IO.tocprint(); IO.tocscan(); IO.tocwrite(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IO. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IO.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IO.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html:3208,Deployability,update,updated,3208,"4.core.IOManager) → None¶; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager) → str¶; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int) → str¶; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool) → None¶; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager) → None¶; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager) → None¶; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str) → None¶; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str) → None¶; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool) → None¶; Set the specific file number to be retained. static shared_object() → psi4.core.IOManager¶; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str) → None¶; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_specific_retention(); IOManager.shared_object(); IOManager.write_scratch_file(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IOManager. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html:745,Integrability,protocol,protocol,745,"﻿. IOManager. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IOManager. IOManager¶. class psi4.core.IOManager¶; Bases: pybind11_object; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation; Methods Summary. crashclean(self); Clean from disk-mirrored image after crash. get_default_path(self); Return the default path. get_file_path(self, fileno); Get the path for a specific file number. mark_file_for_retention(self, full_path, retain); Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self); Print the current status of PSI4 files. psiclean(self); Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self, path); Set the default path for files to be stored. set_specific_path(self, fileno, path); Set the path for specific file numbers. set_specific_retention(self, fileno, retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self, full_path, text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager) → None¶; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager) → str¶; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int) → str¶; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool) → None¶; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager) → None¶; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager) → None¶; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. se",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html:1915,Integrability,protocol,protocol,1915,"path); Set the path for specific file numbers. set_specific_retention(self, fileno, retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self, full_path, text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager) → None¶; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager) → str¶; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int) → str¶; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool) → None¶; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager) → None¶; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager) → None¶; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str) → None¶; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str) → None¶; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool) → None¶; Set the specific file number to be retained. static shared_object() → psi4.core.IOManager¶; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str) → None¶; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_speci",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IrreducibleRepresentation.html:1087,Deployability,update,updated,1087,"﻿. IrreducibleRepresentation. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation. IrreducibleRepresentation¶. class psi4.core.IrreducibleRepresentation¶; Bases: pybind11_object; An irreducible representation of the point group; Methods Summary. character(self, arg0); Return the character of the i'th symmetry operation for the irrep. symbol(self); Return the symbol for the irrep. Methods Documentation. character(self: psi4.core.IrreducibleRepresentation, arg0: int) → float¶; Return the character of the i’th symmetry operation for the irrep. 0-indexed. symbol(self: psi4.core.IrreducibleRepresentation) → str¶; Return the symbol for the irrep. table of contents. IrreducibleRepresentation; IrreducibleRepresentation; IrreducibleRepresentation.character(); IrreducibleRepresentation.symbol(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IrreducibleRepresentation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IrreducibleRepresentation.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.JK.html:6134,Deployability,update,updated,6134,": psi4.core.JK) → None¶. memory_estimate(self: psi4.core.JK) → int¶. name(self: psi4.core.JK) → str¶. print_header(self: psi4.core.JK) → None¶; docstring. set_cutoff(self: psi4.core.JK, arg0: float) → None¶. set_do_J(self: psi4.core.JK, arg0: bool) → None¶. set_do_K(self: psi4.core.JK, arg0: bool) → None¶. set_do_wK(self: psi4.core.JK, arg0: bool) → None¶. set_early_screening(self: psi4.core.JK, early_screening: bool) → None¶; Use severe screening techniques? Useful in early SCF iterations. set_memory(self: psi4.core.JK, arg0: int) → None¶. set_omega(self: psi4.core.JK, omega: float) → None¶; Dampening term for range separated DFT. set_omega_alpha(self: psi4.core.JK, alpha: float) → None¶; Weight for HF exchange term in range-separated DFT. set_omega_beta(self: psi4.core.JK, beta: float) → None¶; Weight for dampened exchange term in range-separated DFT. set_omp_nthread(self: psi4.core.JK, arg0: int) → None¶. set_print(self: psi4.core.JK, arg0: int) → None¶. set_wcombine(self: psi4.core.JK, wcombine: bool) → None¶; Are Exchange terms in one Matrix. wK(self: psi4.core.JK) → List[psi4.core.Matrix]¶. table of contents. JK; JK; JK.C_add(); JK.C_clear(); JK.C_left_add(); JK.C_right_add(); JK.D(); JK.J(); JK.K(); JK.basisset(); JK.build(); JK.build_JK(); JK.compute(); JK.computed_shells_per_iter(); JK.finalize(); JK.get_early_screening(); JK.get_omega(); JK.get_omega_alpha(); JK.get_omega_beta(); JK.get_wcombine(); JK.initialize(); JK.memory_estimate(); JK.name(); JK.print_header(); JK.set_cutoff(); JK.set_do_J(); JK.set_do_K(); JK.set_do_wK(); JK.set_early_screening(); JK.set_memory(); JK.set_omega(); JK.set_omega_alpha(); JK.set_omega_beta(); JK.set_omp_nthread(); JK.set_print(); JK.set_wcombine(); JK.wK(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; JK. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.JK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.JK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.KineticInt.html:462,Deployability,update,updated,462,"﻿. KineticInt. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; KineticInt. KineticInt¶. class psi4.core.KineticInt¶; Bases: OneBodyAOInt; Computes kinetic integrals. table of contents. KineticInt; KineticInt. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; KineticInt. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.KineticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.KineticInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html:1317,Deployability,update,updated,1317,"﻿. LaplaceDenominator. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator¶. class psi4.core.LaplaceDenominator¶; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator) → psi4.core.Matrix¶; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator) → psi4.core.Matrix¶; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html:290,Energy Efficiency,energy,energy,290,"﻿. LaplaceDenominator. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator¶. class psi4.core.LaplaceDenominator¶; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator) → psi4.core.Matrix¶; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator) → psi4.core.Matrix¶; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.LibXCFunctional.html:2014,Deployability,update,updated,2014,"4 API: Linking C++ and Python; LibXCFunctional. LibXCFunctional¶. class psi4.core.LibXCFunctional¶; Bases: Functional; docstring; Methods Summary. density_cutoff(self); docstring. get_mix_data(self); docstring. query_libxc(self, arg0); query libxc regarding functional parameters. set_density_cutoff(self, arg0); docstring. set_omega(self, arg0); docstring. set_tweak(*args, **kwargs); Overloaded function. xclib_description(); query libxc for version and citation. Methods Documentation. density_cutoff(self: psi4.core.LibXCFunctional) → float¶; docstring. get_mix_data(self: psi4.core.LibXCFunctional) → List[Tuple[str, int, float]]¶; docstring. query_libxc(self: psi4.core.LibXCFunctional, arg0: str) → Dict[str, float]¶; query libxc regarding functional parameters. set_density_cutoff(self: psi4.core.LibXCFunctional, arg0: float) → None¶; docstring. set_omega(self: psi4.core.LibXCFunctional, arg0: float) → None¶; docstring. set_tweak(*args, **kwargs)¶; Overloaded function. set_tweak(self: psi4.core.LibXCFunctional, tweaks: List[float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a list. Deprecated in v1.4. set_tweak(self: psi4.core.LibXCFunctional, tweaks: Dict[str, float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a dictionary of names (usually underscore prepended) and values. New in v1.4. xclib_description() → str¶; query libxc for version and citation. table of contents. LibXCFunctional; LibXCFunctional; LibXCFunctional.density_cutoff(); LibXCFunctional.get_mix_data(); LibXCFunctional.query_libxc(); LibXCFunctional.set_density_cutoff(); LibXCFunctional.set_omega(); LibXCFunctional.set_tweak(); LibXCFunctional.xclib_description(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; LibXCFunctional. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.LibXCFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.LibXCFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html:1207,Deployability,update,updated,1207,"﻿. Localizer. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer¶. class psi4.core.Localizer¶; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0, arg1, arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. converged¶; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. localize(self: psi4.core.Localizer) → None¶; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Localizer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html:468,Performance,Perform,Perform,468,"﻿. Localizer. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer¶. class psi4.core.Localizer¶; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0, arg1, arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. converged¶; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. localize(self: psi4.core.Localizer) → None¶; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Localizer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html:846,Performance,Perform,Perform,846,"﻿. Localizer. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer¶. class psi4.core.Localizer¶; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0, arg1, arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. converged¶; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. localize(self: psi4.core.Localizer) → None¶; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Localizer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:19724,Deployability,update,updated,19724,"¶; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None¶; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None¶; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Matrix. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:3297,Energy Efficiency,power,power,3297,"rix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*args, **kwargs); Overloaded function. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, bl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:3357,Energy Efficiency,power,power,3357,"rix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*args, **kwargs); Overloaded function. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, bl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:13009,Energy Efficiency,power,power,13009,"ucted.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. row",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:13130,Energy Efficiency,power,power,13130,"turn type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0) → int¶; Returns the rows in irrep h. save(*args, **kwargs)¶; Overloa",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:18894,Energy Efficiency,power,power,18894,"¶; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None¶; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None¶; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Matrix. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:16418,Integrability,depend,depending,16418,"ce, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the tran",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:2740,Performance,load,load,2740,"im1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoa",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:2811,Performance,Load,Loads,2811,"into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_column",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:2996,Performance,load,load,2996,"); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*ar",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11109,Performance,load,load,11109,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return typ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11154,Performance,load,load,11154,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_w",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11207,Performance,Load,Loads,11207,"rix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompres",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11278,Performance,load,load,11278,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return th",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11374,Performance,Load,Load,11374,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be seria",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11446,Performance,load,load,11446,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11577,Performance,Load,Load,11577,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11729,Performance,Load,Loads,11729,"e(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11954,Performance,load,load,11954,"x) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:18768,Performance,load,load,18768,"lf: psi4.core.Matrix) → None¶; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None¶; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None¶; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Matrix. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Crea",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:4789,Security,access,accessor,4789,"ix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*args, **kwargs); Overloaded function. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, block); Set a matrix block. subtract(self, arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self, mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy, dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A, B, C, transA, transB, transC); Multiply three matrices together. vector_dot(self, rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name¶; The name of the Matrix. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix) → float¶; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:16713,Security,access,accessor,16713,": psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC)¶; Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix) → float¶; Returns th",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11252,Testability,test,tests,11252,"rix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompres",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:16035,Usability,simpl,simply,16035,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*a",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MatrixFactory.html:920,Deployability,update,updated,920,"﻿. MatrixFactory. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory. MatrixFactory¶. class psi4.core.MatrixFactory¶; Bases: pybind11_object; Creates Matrix objects; Methods Summary. create_matrix(*args, **kwargs); Overloaded function. Methods Documentation. create_matrix(*args, **kwargs)¶; Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matrix. Returns a new matrix object with default dimensions. create_matrix(self: psi4.core.MatrixFactory, arg0: str) -> psi4.core.Matrix. Returns a new Matrix object named name with default dimensions. table of contents. MatrixFactory; MatrixFactory; MatrixFactory.create_matrix(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MatrixFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MatrixFactory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.mcscf.html:494,Deployability,update,updated,494,"﻿. mcscf. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; mcscf. mcscf¶. psi4.core.mcscf(arg0: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). table of contents. mcscf; mcscf(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; mcscf. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.mcscf.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MemDFJK.html:588,Deployability,update,updated,588,"﻿. MemDFJK. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MemDFJK. MemDFJK¶. class psi4.core.MemDFJK¶; Bases: JK; docstring; Methods Summary. dfh(self); Return the DFHelper object. Methods Documentation. dfh(self: psi4.core.MemDFJK) → psi4.core.DFHelper¶; Return the DFHelper object. table of contents. MemDFJK; MemDFJK; MemDFJK.dfh(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MemDFJK. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MemDFJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MemDFJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:21511,Deployability,update,updated,21511,"tsHelper.ao_oei_deriv1(); MintsHelper.ao_oei_deriv2(); MintsHelper.ao_overlap(); MintsHelper.ao_overlap_half_deriv1(); MintsHelper.ao_potential(); MintsHelper.ao_pvp(); MintsHelper.ao_quadrupole(); MintsHelper.ao_tei_deriv1(); MintsHelper.ao_tei_deriv2(); MintsHelper.ao_traceless_quadrupole(); MintsHelper.basisset(); MintsHelper.cdsalcs(); MintsHelper.core_hamiltonian_grad(); MintsHelper.dipole_grad(); MintsHelper.electric_field(); MintsHelper.electric_field_value(); MintsHelper.electrostatic_potential_value(); MintsHelper.f12_cgtg(); MintsHelper.factory(); MintsHelper.induction_operator(); MintsHelper.integral(); MintsHelper.integrals(); MintsHelper.integrals_erf(); MintsHelper.integrals_erfc(); MintsHelper.kinetic_grad(); MintsHelper.mo_elec_dip_deriv1(); MintsHelper.mo_erf_eri(); MintsHelper.mo_eri(); MintsHelper.mo_f12(); MintsHelper.mo_f12_double_commutator(); MintsHelper.mo_f12_squared(); MintsHelper.mo_f12g12(); MintsHelper.mo_oei_deriv1(); MintsHelper.mo_oei_deriv2(); MintsHelper.mo_overlap_half_deriv1(); MintsHelper.mo_spin_eri(); MintsHelper.mo_tei_deriv1(); MintsHelper.mo_tei_deriv2(); MintsHelper.mo_transform(); MintsHelper.multipole_grad(); MintsHelper.nbf(); MintsHelper.one_electron_integrals(); MintsHelper.overlap_grad(); MintsHelper.perturb_grad(); MintsHelper.petite_list(); MintsHelper.petite_list1(); MintsHelper.play(); MintsHelper.potential_grad(); MintsHelper.set_basisset(); MintsHelper.set_print(); MintsHelper.so_angular_momentum(); MintsHelper.so_dipole(); MintsHelper.so_dkh(); MintsHelper.so_kinetic(); MintsHelper.so_nabla(); MintsHelper.so_overlap(); MintsHelper.so_potential(); MintsHelper.so_quadrupole(); MintsHelper.so_traceless_quadrupole(); MintsHelper.sobasisset(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MintsHelper. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:2738,Energy Efficiency,charge,charges,2738,"ion. ao_overlap_half_deriv1(self, side, atom); Half-derivative of AO basis overlap integrals: returns (3 * natoms) matrices. ao_potential(*args, **kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self, atom[, omega, factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self, atom1, atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self, arg0, arg1, arg2); Returns a CdSalcList object. core_hamiltonian_grad(self, arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self, arg0); First nuclear derivative dipole integrals. electric_field(self, origin[, deriv]); Vector electric field integrals. electric_field_value(self, arg0, arg1); Electric field expectation value at given sites. electrostatic_potential_value(self, charges, ...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[, exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self, arg0, arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[, w]); ERF integrals. integrals_erfc(self[, w]); ERFC integrals. kinetic_grad(self, arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self, atom, C1, C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self, omega, C1, C2, C3, C4); MO ERFC Omega Integrals. mo_eri(self, C1, C2, C3, C4); MO ERI Integrals. mo_f12(self, corr, C1, C2, C3, C4); MO F12 Integrals. mo_f12_double_commutator(self, corr, C1, C2, ...);",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:2815,Energy Efficiency,charge,charge,2815,"ap integrals: returns (3 * natoms) matrices. ao_potential(*args, **kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self, atom[, omega, factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self, atom1, atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self, arg0, arg1, arg2); Returns a CdSalcList object. core_hamiltonian_grad(self, arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self, arg0); First nuclear derivative dipole integrals. electric_field(self, origin[, deriv]); Vector electric field integrals. electric_field_value(self, arg0, arg1); Electric field expectation value at given sites. electrostatic_potential_value(self, charges, ...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[, exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self, arg0, arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[, w]); ERF integrals. integrals_erfc(self[, w]); ERFC integrals. kinetic_grad(self, arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self, atom, C1, C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self, omega, C1, C2, C3, C4); MO ERFC Omega Integrals. mo_eri(self, C1, C2, C3, C4); MO ERI Integrals. mo_f12(self, corr, C1, C2, C3, C4); MO F12 Integrals. mo_f12_double_commutator(self, corr, C1, C2, ...); MO F12 double commutator integrals. mo_f12_squared(self, corr, C1, C2, C3, C4);",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:12213,Energy Efficiency,charge,charges,12213,"2 matrices. ao_traceless_quadrupole(self: psi4.core.MintsHelper) → List[psi4.core.Matrix]¶; Vector AO traceless quadrupole integrals. basisset(self: psi4.core.MintsHelper) → psi4.core.BasisSet¶; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool) → psi4.core.CdSalcList¶; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0) → List[psi4.core.Matrix]¶; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix) → psi4.core.Vector¶; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0) → List[Tuple[float, float]]¶; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper) → psi4.core.MatrixFactory¶; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper) → psi4.core.IntegralFactory¶; Integral factory being used. integrals(self: psi4.core.MintsHelper) → None¶; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0) → None¶; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0) → Non",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:12370,Energy Efficiency,charge,charge,12370,"self: psi4.core.MintsHelper) → psi4.core.BasisSet¶; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool) → psi4.core.CdSalcList¶; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0) → List[psi4.core.Matrix]¶; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix) → psi4.core.Vector¶; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0) → List[Tuple[float, float]]¶; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper) → psi4.core.MatrixFactory¶; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper) → psi4.core.IntegralFactory¶; Integral factory being used. integrals(self: psi4.core.MintsHelper) → None¶; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0) → None¶; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0) → None¶; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; First nuclear derivative kinetic int",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:3048,Integrability,contract,contracting,3048,"s: returns (3 * natoms) matrices. ao_tei_deriv2(self, atom1, atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self, arg0, arg1, arg2); Returns a CdSalcList object. core_hamiltonian_grad(self, arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self, arg0); First nuclear derivative dipole integrals. electric_field(self, origin[, deriv]); Vector electric field integrals. electric_field_value(self, arg0, arg1); Electric field expectation value at given sites. electrostatic_potential_value(self, charges, ...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[, exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self, arg0, arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[, w]); ERF integrals. integrals_erfc(self[, w]); ERFC integrals. kinetic_grad(self, arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self, atom, C1, C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self, omega, C1, C2, C3, C4); MO ERFC Omega Integrals. mo_eri(self, C1, C2, C3, C4); MO ERI Integrals. mo_f12(self, corr, C1, C2, C3, C4); MO F12 Integrals. mo_f12_double_commutator(self, corr, C1, C2, ...); MO F12 double commutator integrals. mo_f12_squared(self, corr, C1, C2, C3, C4); MO F12 squared integrals. mo_f12g12(self, corr, C1, C2, C3, C4); MO F12G12 integrals. mo_oei_deriv1(self, oei_type, atom, C1, C2); Gradient of MO basis OEI integrals: returns (3 * natoms) matrices. mo_oei_deriv2(self, oei_type, atom1, atom2, ...); Hessian of ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:12795,Integrability,contract,contracting,12795," dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0) → List[psi4.core.Matrix]¶; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix) → psi4.core.Vector¶; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0) → List[Tuple[float, float]]¶; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper) → psi4.core.MatrixFactory¶; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper) → psi4.core.IntegralFactory¶; Integral factory being used. integrals(self: psi4.core.MintsHelper) → None¶; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0) → None¶; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0) → None¶; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix) → psi4.core.Matrix¶; First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self: psi4.core.MintsHelper, atom: int, C1: psi4.core.Matrix, C2: psi4.core.Matrix) → List[psi4.core.Matrix]¶; Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self: psi4.core.MintsHelper, omega: float, C1: psi4.core.Matrix, C2: psi4.core.Matrix, C3: psi4.core.Matrix, C4: psi4.core.Matrix) → psi4.core.Matrix¶; MO ERFC Omega Integrals. mo_eri(self: psi4.core.MintsHelper, C1: psi4.core.Matrix, C2: psi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MoldenWriter.html:926,Deployability,update,updated,926,"﻿. MoldenWriter. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter. MoldenWriter¶. class psi4.core.MoldenWriter¶; Bases: pybind11_object; Writes wavefunction information in molden format; Methods Summary. write(self, filename, Ca, Cb, Ea, Eb, OccA, ...); Writes wavefunction information in molden format. Methods Documentation. write(self: psi4.core.MoldenWriter, filename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool) → None¶; Writes wavefunction information in molden format. table of contents. MoldenWriter; MoldenWriter; MoldenWriter.write(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MoldenWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MoldenWriter.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MolecularGrid.html:1984,Deployability,update,updated,1984,".  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid. MolecularGrid¶. class psi4.core.MolecularGrid¶; Bases: pybind11_object; docstring; Methods Summary. atomic_blocks(self); Returns a list of blocks. blocks(self); Returns a list of blocks. collocation_size(self); Returns the total collocation size of all blocks. max_functions(self); Returns the maximum number of functions in a block. max_points(self); Returns the maximum number of points in a block. npoints(self); Returns the number of grid points. orientation(self); Returns the orientation of the grid. print(self, arg0, arg1); Prints grid information. Methods Documentation. atomic_blocks(self: psi4.core.MolecularGrid) → List[List[psi4.core.BlockOPoints]]¶; Returns a list of blocks. blocks(self: psi4.core.MolecularGrid) → List[psi4.core.BlockOPoints]¶; Returns a list of blocks. collocation_size(self: psi4.core.MolecularGrid) → int¶; Returns the total collocation size of all blocks. max_functions(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid) → int¶; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid) → psi4.core.Matrix¶; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int) → None¶; Prints grid information. table of contents. MolecularGrid; MolecularGrid; MolecularGrid.atomic_blocks(); MolecularGrid.blocks(); MolecularGrid.collocation_size(); MolecularGrid.max_functions(); MolecularGrid.max_points(); MolecularGrid.npoints(); MolecularGrid.orientation(); MolecularGrid.print(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MolecularGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MolecularGrid.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:2061,Availability,toler,tolerance,2061,"a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom, elea, elez, elem, mass, ...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:2158,Availability,toler,tolerance,2158,"f, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom, elea, elez, elem, mass, ...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:10087,Availability,toler,tolerance,10087,"g0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[, units, atom_format, ...]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg0. true_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self, arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self, i); Return the Vector3 for atom i (0-indexed without dummies). y(self, arg0);",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15276,Availability,fault,faulty,15276,"ts of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol:",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18828,Availability,toler,tolerance,18828,"ts(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int) → float¶; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). format_molecule_for_mol()¶; Returns a string of Molecule formatted for mol2.; Writte",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18982,Availability,toler,tolerance,18982,"ract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int) → float¶; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). format_molecule_for_mol()¶; Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='An",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:20287,Availability,error,error,20287,"ride this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int) → float¶; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). format_molecule_for_mol()¶; Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict) – Dictionary form of Mo",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28617,Availability,error,error,28617,"al_symmetry_number(self: psi4.core.Molecule) → int¶; Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:29908,Availability,error,error,29908,"ertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geom",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:37312,Availability,toler,tolerance,37312,"elf: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool) – Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[so",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:43220,Deployability,update,updated,43220,"nergy_deriv1(); Molecule.nuclear_repulsion_energy_deriv2(); Molecule.orientation_fixed(); Molecule.point_group(); Molecule.print_bond_angles(); Molecule.print_cluster(); Molecule.print_distances(); Molecule.print_in_input_format(); Molecule.print_out(); Molecule.print_out_in_angstrom(); Molecule.print_out_in_bohr(); Molecule.print_out_of_planes(); Molecule.print_rotational_constants(); Molecule.provenance(); Molecule.reinterpret_coordentry(); Molecule.reset_point_group(); Molecule.rotational_constants(); Molecule.rotational_symmetry_number(); Molecule.rotor_type(); Molecule.run_dftd3(); Molecule.run_dftd4(); Molecule.run_gcp(); Molecule.save_string_xyz(); Molecule.save_string_xyz_file(); Molecule.save_xyz_file(); Molecule.schoenflies_symbol(); Molecule.scramble(); Molecule.set_active_fragment(); Molecule.set_active_fragments(); Molecule.set_basis_all_atoms(); Molecule.set_basis_by_label(); Molecule.set_basis_by_number(); Molecule.set_basis_by_symbol(); Molecule.set_comment(); Molecule.set_connectivity(); Molecule.set_full_geometry(); Molecule.set_geometry(); Molecule.set_ghost_fragment(); Molecule.set_ghost_fragments(); Molecule.set_input_units_to_au(); Molecule.set_mass(); Molecule.set_molecular_charge(); Molecule.set_multiplicity(); Molecule.set_name(); Molecule.set_nuclear_charge(); Molecule.set_point_group(); Molecule.set_provenance(); Molecule.set_units(); Molecule.set_variable(); Molecule.symbol(); Molecule.symmetrize(); Molecule.symmetry_from_input(); Molecule.to_arrays(); Molecule.to_dict(); Molecule.to_schema(); Molecule.to_string(); Molecule.translate(); Molecule.true_atomic_number(); Molecule.units(); Molecule.update_geometry(); Molecule.x(); Molecule.xyz(); Molecule.y(); Molecule.z(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:266,Energy Efficiency,charge,charge,266,"﻿. Molecule. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule¶. class psi4.core.Molecule¶; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[, do_plot, verbose, atoms_map, ...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms, bond_threshold, ...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self, arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, Z, x, y, z, symbol, mass, ...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:611,Energy Efficiency,charge,charge,611,"﻿. Molecule. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule¶. class psi4.core.Molecule¶; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[, do_plot, verbose, atoms_map, ...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms, bond_threshold, ...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self, arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, Z, x, y, z, symbol, mass, ...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:904,Energy Efficiency,charge,charge,904,"﻿. Molecule. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule¶. class psi4.core.Molecule¶; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[, do_plot, verbose, atoms_map, ...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms, bond_threshold, ...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self, arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, Z, x, y, z, symbol, mass, ...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1188,Energy Efficiency,charge,charge,1188,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[, do_plot, verbose, atoms_map, ...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms, bond_threshold, ...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self, arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, Z, x, y, z, symbol, mass, ...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1213,Energy Efficiency,charge,charge,1213,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[, do_plot, verbose, atoms_map, ...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms, bond_threshold, ...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self, arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, Z, x, y, z, symbol, mass, ...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1627,Energy Efficiency,charge,charges,1627,"0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, Z, x, y, z, symbol, mass, ...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1906,Energy Efficiency,charge,charge,1906,"ed atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom, elea, elez, elem, mass, ...]); Construct Molecule from unvalidated arrays and variables. from_dict(",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1983,Energy Efficiency,charge,charge,1983,"rloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom, elea, elez, elem, mass, ...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_sc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:3912,Energy Efficiency,charge,charge,3912,"es. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5141,Energy Efficiency,charge,charge,5141,"gments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separato",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5574,Energy Efficiency,energy,energy,5574,"s molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5674,Energy Efficiency,energy,energy,5674,"nit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_r",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5791,Energy Efficiency,energy,energy,5791,"els. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_rotational_constants(self); Print the rotational constants to output file. provenance(self); Gets molecule",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9282,Energy Efficiency,charge,charge,9282,"arg2); Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self, arg0, arg1, arg2); Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self, arg0, arg1, arg2); Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self, arg0); Sets molecule comment. set_connectivity(self, arg0); Sets molecule connectivity. set_full_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); E",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9461,Energy Efficiency,charge,charge,9461,"basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self, arg0); Sets molecule comment. set_connectivity(self, arg0); Sets molecule connectivity. set_full_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema d",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:13152,Energy Efficiency,charge,charge,13152,"ed final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool) – Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool) – Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float) – TODO; run_mirror (bool) – Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int) – . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]¶; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule) – ; seed_atoms (List) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float) – Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool) – If True, also return fragments as list of arrays.; return_molecules (bool) – If True, also return fragments as list of Molecules.; return_molecule (bool) – If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:14995,Energy Efficiency,charge,charge,14995,"rays.; return_molecules (bool) – If True, also return fragments as list of Molecules.; return_molecule (bool) – If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15474,Energy Efficiency,charge,charge,15474,"ch built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15731,Energy Efficiency,charge,charge,15731,"cule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15893,Energy Efficiency,charge,charge,15893,"cule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:16682,Energy Efficiency,charge,charge,16682,"oat, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:16741,Energy Efficiency,charge,charge,16741,", label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.M",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:17331,Energy Efficiency,charge,charges,17331," tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule) → str¶; Gets molecule comment. connectivity(self: psi4.core.Molecule) → List[Tuple[int, int, float]]¶; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: p",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18620,Energy Efficiency,charge,charge,18620,"wargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int) → float¶; Gets mass of atom (0-indexed including dummies). form_",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18731,Energy Efficiency,charge,charge,18731,"si4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int) → float¶; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by cal",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:22852,Energy Efficiency,charge,charge,22852," C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule) → int¶; Gets n in Cnv, etc.; If there is no n (e.g. Td) it’s the highest-order rotation axis. fx(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg0 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg0 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule) → bool¶; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:24568,Energy Efficiency,charge,charge,24568,"str) → float¶; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule) → bool¶; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_r",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:25536,Energy Efficiency,energy,energy,25536,": psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecul",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:25717,Energy Efficiency,energy,energy,25717,"Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:25874,Energy Efficiency,energy,energy,25874,"molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule) → None¶; Prints the m",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28729,Energy Efficiency,energy,energy-only,28729,"ical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28781,Energy Efficiency,efficient,efficient,28781,"ical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28876,Energy Efficiency,energy,energy,28876,"dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28909,Energy Efficiency,energy,energy,28909,"dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28996,Energy Efficiency,energy,energy,28996,":. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecule",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:29076,Energy Efficiency,energy,energy,29076,"& disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficien",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30020,Energy Efficiency,energy,energy-only,30020,"y.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30072,Energy Efficiency,efficient,efficient,30072,"y.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30167,Energy Efficiency,energy,energy,30167,"se=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30200,Energy Efficiency,energy,energy,30200,"se=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30280,Energy Efficiency,energy,energy,30280," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30353,Energy Efficiency,energy,energy,30353," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31034,Energy Efficiency,energy,energy,31034,"nfluences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31099,Energy Efficiency,energy,energy,31099,"nfluences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31731,Energy Efficiency,energy,energy-only,31731,"rogram.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31783,Energy Efficiency,efficient,efficient,31783,"rogram.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31897,Energy Efficiency,energy,energy,31897,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule) – Molecule to perturb.; do_shift (Union[bool, ndarray, List]) – Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31930,Energy Efficiency,energy,energy,31930,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule) – Molecule to perturb.; do_shift (Union[bool, ndarray, List]) – Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:32010,Energy Efficiency,energy,energy,32010,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule) – Molecule to perturb.; do_shift (Union[bool, ndarray, List]) – Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:32083,Energy Efficiency,energy,energy,32083,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule) – Molecule to perturb.; do_shift (Union[bool, ndarray, List]) – Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:35959,Energy Efficiency,charge,charge,35959,"y(self: psi4.core.Molecule, arg0: List[Tuple[int, int, float]]) → None¶; Sets molecule connectivity. set_full_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:36366,Energy Efficiency,charge,charge,36366," set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:39880,Energy Efficiency,charge,charge,39880,"ine the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(); Molecule.deactivate_all_fragments(); Molecule.distance_matrix(); Molecule.extract_subsets(); Molecule.fZ(); Molecule.fcharge(); Molecule.find_highest_point_group(); Molecule.find_point_group(); Molecule.fix_com(); Molecule.fix_orientation(); Molecule.flabel(); Molecule.fmass(); Molecule.form_symmetry_information(); Molecule.format_molecule_for_mol(); Molecule.from_arrays(); Molecule.from_dict(); Molecule.from_schema(); Molecule.from_string(); Molecule.fsymbol(); Molecule.ftrue_atomic_number(); Molecule.full_geometry(); Molecule.full_pg_n(); Molecule.fx(); Molecule.fy(); Molecule.fz(); Molecule.geometry(); Molecule.get_fragment_charges(); Molecule.get_fragment_multiplicities(); Molecule.get_fragment_types(); Molecule.get_fragments(); Molecule.get_full_point_group(); Molecule.get_full_point_group_with_n(); Molecule.get_variable(); Molecule.has_zmatrix(); Molec",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:11488,Integrability,Wrap,Wraps,11488,"s, atom_format, ...]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg0. true_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self, arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self, i); Return the Vector3 for atom i (0-indexed without dummies). y(self, arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self, arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule]) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (Union[Molecule, Molecule]) – Molecule to match.; atoms_map (bool) – Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool) – Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool) – Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:20465,Integrability,wrap,wrapper,20465,"). fmass(self: psi4.core.Molecule, atom: int) → float¶; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). format_molecule_for_mol()¶; Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict) – Dictionary form of Molecule following known schema.; return_dict (bool) – Additionally return Molecule dictionary intermediate.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; verbose (int) – Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict) – Dictionary representation of instance.; Only provided if return_dict is True. classm",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:21006,Integrability,wrap,wrapper,21006,"o_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict) – Dictionary form of Molecule following known schema.; return_dict (bool) – Additionally return Molecule dictionary intermediate.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; verbose (int) – Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fsymbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed including d",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30417,Integrability,wrap,wraps,30417," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30456,Integrability,wrap,wraps,30456," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31374,Integrability,interface,interface,31374,"3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:912,Modifiability,extend,extended,912,"﻿. Molecule. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule¶. class psi4.core.Molecule¶; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[, do_plot, verbose, atoms_map, ...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms, bond_threshold, ...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self, arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self, Z, x, y, z, symbol, mass, ...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. basis_on_atom(self, arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self, atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:2898,Modifiability,variab,variables,2898,"ion. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom, elea, elez, elem, mass, ...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4450,Modifiability,variab,variable,4450,"; Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4482,Modifiability,variab,variables,4482,"; Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4808,Modifiability,variab,variable,4808,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4843,Modifiability,variab,variables,4843,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9817,Modifiability,variab,variable,9817,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[, units, atom_format, ...]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg0. true_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9856,Modifiability,variab,variables,9856,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[, units, atom_format, ...]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg0. true_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:10863,Modifiability,variab,variable,10863,"e variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[, units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[, units, atom_format, ...]); Format a string representation of QM molecule. translate(self, arg0); Translates molecule by arg0. true_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self, arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self, i); Return the Vector3 for atom i (0-indexed without dummies). y(self, arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self, arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule]) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with re",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15901,Modifiability,extend,extended,15901,"cule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; ——-; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:20447,Modifiability,variab,variables,20447,"; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int) → float¶; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). format_molecule_for_mol()¶; Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict) – Dictionary form of Molecule following known schema.; return_dict (bool) – Additionally return Molecule dictionary intermediate.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; verbose (int) – Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molec",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:23589,Modifiability,variab,variable,23589,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule) → bool¶; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
